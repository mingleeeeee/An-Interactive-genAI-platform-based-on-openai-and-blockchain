'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var viem = require('viem');
var dotenv = require('dotenv');
var chains = require('viem/chains');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var dotenv__namespace = /*#__PURE__*/_interopNamespace(dotenv);

function toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}

function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == typeof i ? i : i + "";
}

function _defineProperty(obj, key, value) {
  key = toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
      _defineProperty(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      var F = function () {};
      return {
        s: F,
        n: function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function (e) {
          throw e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true,
    didErr = false,
    err;
  return {
    s: function () {
      it = it.call(o);
    },
    n: function () {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function (e) {
      didErr = true;
      err = e;
    },
    f: function () {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

function _regeneratorRuntime() {
  _regeneratorRuntime = function () {
    return e;
  };
  var t,
    e = {},
    r = Object.prototype,
    n = r.hasOwnProperty,
    o = Object.defineProperty || function (t, e, r) {
      t[e] = r.value;
    },
    i = "function" == typeof Symbol ? Symbol : {},
    a = i.iterator || "@@iterator",
    c = i.asyncIterator || "@@asyncIterator",
    u = i.toStringTag || "@@toStringTag";
  function define(t, e, r) {
    return Object.defineProperty(t, e, {
      value: r,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), t[e];
  }
  try {
    define({}, "");
  } catch (t) {
    define = function (t, e, r) {
      return t[e] = r;
    };
  }
  function wrap(t, e, r, n) {
    var i = e && e.prototype instanceof Generator ? e : Generator,
      a = Object.create(i.prototype),
      c = new Context(n || []);
    return o(a, "_invoke", {
      value: makeInvokeMethod(t, r, c)
    }), a;
  }
  function tryCatch(t, e, r) {
    try {
      return {
        type: "normal",
        arg: t.call(e, r)
      };
    } catch (t) {
      return {
        type: "throw",
        arg: t
      };
    }
  }
  e.wrap = wrap;
  var h = "suspendedStart",
    l = "suspendedYield",
    f = "executing",
    s = "completed",
    y = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var p = {};
  define(p, a, function () {
    return this;
  });
  var d = Object.getPrototypeOf,
    v = d && d(d(values([])));
  v && v !== r && n.call(v, a) && (p = v);
  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
  function defineIteratorMethods(t) {
    ["next", "throw", "return"].forEach(function (e) {
      define(t, e, function (t) {
        return this._invoke(e, t);
      });
    });
  }
  function AsyncIterator(t, e) {
    function invoke(r, o, i, a) {
      var c = tryCatch(t[r], t, o);
      if ("throw" !== c.type) {
        var u = c.arg,
          h = u.value;
        return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
          invoke("next", t, i, a);
        }, function (t) {
          invoke("throw", t, i, a);
        }) : e.resolve(h).then(function (t) {
          u.value = t, i(u);
        }, function (t) {
          return invoke("throw", t, i, a);
        });
      }
      a(c.arg);
    }
    var r;
    o(this, "_invoke", {
      value: function (t, n) {
        function callInvokeWithMethodAndArg() {
          return new e(function (e, r) {
            invoke(t, n, e, r);
          });
        }
        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(e, r, n) {
    var o = h;
    return function (i, a) {
      if (o === f) throw Error("Generator is already running");
      if (o === s) {
        if ("throw" === i) throw a;
        return {
          value: t,
          done: !0
        };
      }
      for (n.method = i, n.arg = a;;) {
        var c = n.delegate;
        if (c) {
          var u = maybeInvokeDelegate(c, n);
          if (u) {
            if (u === y) continue;
            return u;
          }
        }
        if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
          if (o === h) throw o = s, n.arg;
          n.dispatchException(n.arg);
        } else "return" === n.method && n.abrupt("return", n.arg);
        o = f;
        var p = tryCatch(e, r, n);
        if ("normal" === p.type) {
          if (o = n.done ? s : l, p.arg === y) continue;
          return {
            value: p.arg,
            done: n.done
          };
        }
        "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
      }
    };
  }
  function maybeInvokeDelegate(e, r) {
    var n = r.method,
      o = e.iterator[n];
    if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
    var i = tryCatch(o, e.iterator, r.arg);
    if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
    var a = i.arg;
    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
  }
  function pushTryEntry(t) {
    var e = {
      tryLoc: t[0]
    };
    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
  }
  function resetTryEntry(t) {
    var e = t.completion || {};
    e.type = "normal", delete e.arg, t.completion = e;
  }
  function Context(t) {
    this.tryEntries = [{
      tryLoc: "root"
    }], t.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(e) {
    if (e || "" === e) {
      var r = e[a];
      if (r) return r.call(e);
      if ("function" == typeof e.next) return e;
      if (!isNaN(e.length)) {
        var o = -1,
          i = function next() {
            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
            return next.value = t, next.done = !0, next;
          };
        return i.next = i;
      }
    }
    throw new TypeError(typeof e + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), o(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
    var e = "function" == typeof t && t.constructor;
    return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
  }, e.mark = function (t) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
  }, e.awrap = function (t) {
    return {
      __await: t
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
    return this;
  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
    void 0 === i && (i = Promise);
    var a = new AsyncIterator(wrap(t, r, n, o), i);
    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
      return t.done ? t.value : a.next();
    });
  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
    return this;
  }), define(g, "toString", function () {
    return "[object Generator]";
  }), e.keys = function (t) {
    var e = Object(t),
      r = [];
    for (var n in e) r.push(n);
    return r.reverse(), function next() {
      for (; r.length;) {
        var t = r.pop();
        if (t in e) return next.value = t, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, e.values = values, Context.prototype = {
    constructor: Context,
    reset: function (e) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
    },
    stop: function () {
      this.done = !0;
      var t = this.tryEntries[0].completion;
      if ("throw" === t.type) throw t.arg;
      return this.rval;
    },
    dispatchException: function (e) {
      if (this.done) throw e;
      var r = this;
      function handle(n, o) {
        return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
      }
      for (var o = this.tryEntries.length - 1; o >= 0; --o) {
        var i = this.tryEntries[o],
          a = i.completion;
        if ("root" === i.tryLoc) return handle("end");
        if (i.tryLoc <= this.prev) {
          var c = n.call(i, "catchLoc"),
            u = n.call(i, "finallyLoc");
          if (c && u) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          } else if (c) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
          } else {
            if (!u) throw Error("try statement without catch or finally");
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          }
        }
      }
    },
    abrupt: function (t, e) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var o = this.tryEntries[r];
        if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
          var i = o;
          break;
        }
      }
      i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
      var a = i ? i.completion : {};
      return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
    },
    complete: function (t, e) {
      if ("throw" === t.type) throw t.arg;
      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
    },
    finish: function (t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
      }
    },
    catch: function (t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.tryLoc === t) {
          var n = r.completion;
          if ("throw" === n.type) {
            var o = n.arg;
            resetTryEntry(r);
          }
          return o;
        }
      }
      throw Error("illegal catch attempt");
    },
    delegateYield: function (e, r, n) {
      return this.delegate = {
        iterator: values(e),
        resultName: r,
        nextLoc: n
      }, "next" === this.method && (this.arg = t), y;
    }
  }, e;
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}

function chainStringToViemChain(chainId) {
  switch (chainId) {
    case "11155111":
    case "sepolia":
      return chains.sepolia;
    default:
      throw new Error("chainId ".concat(chainId, " not supported"));
  }
}
var chain = {
  sepolia: 11155111n,
  11155111: 11155111n
};

function handleError(error, msg) {
  if (error instanceof Error) {
    throw new Error("".concat(msg, ": ").concat(error.message));
  }
  throw new Error("".concat(msg, ": Unknown error type"));
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
  } catch (t) {}
  return (_isNativeReflectConstruct = function () {
    return !!t;
  })();
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}

function _callSuper(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// AccessController
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/**
 * [__View Contract on Sepolia Etherscan__](https://sepolia.etherscan.io/address/0xF9936a224b3Deb6f9A4645ccAfa66f7ECe83CF0A)
 */
var accessControllerAbi = [{
  type: "constructor",
  inputs: [{
    name: "ipAccountRegistry",
    internalType: "address",
    type: "address"
  }, {
    name: "moduleRegistry",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "nonpayable"
}, {
  type: "error",
  inputs: [{
    name: "signer",
    internalType: "address",
    type: "address"
  }, {
    name: "to",
    internalType: "address",
    type: "address"
  }],
  name: "AccessController__BothCallerAndRecipientAreNotRegisteredModule"
}, {
  type: "error",
  inputs: [],
  name: "AccessController__CallerIsNotIPAccountOrOwner"
}, {
  type: "error",
  inputs: [{
    name: "ipAccount",
    internalType: "address",
    type: "address"
  }],
  name: "AccessController__IPAccountIsNotValid"
}, {
  type: "error",
  inputs: [],
  name: "AccessController__IPAccountIsZeroAddress"
}, {
  type: "error",
  inputs: [{
    name: "ipAccount",
    internalType: "address",
    type: "address"
  }, {
    name: "signer",
    internalType: "address",
    type: "address"
  }, {
    name: "to",
    internalType: "address",
    type: "address"
  }, {
    name: "func",
    internalType: "bytes4",
    type: "bytes4"
  }],
  name: "AccessController__PermissionDenied"
}, {
  type: "error",
  inputs: [],
  name: "AccessController__PermissionIsNotValid"
}, {
  type: "error",
  inputs: [],
  name: "AccessController__SignerIsZeroAddress"
}, {
  type: "error",
  inputs: [],
  name: "AccessController__ToAndFuncAreZeroAddressShouldCallSetAllPermissions"
}, {
  type: "error",
  inputs: [],
  name: "AccessController__ZeroAccessManager"
}, {
  type: "error",
  inputs: [],
  name: "AccessController__ZeroIPAccountRegistry"
}, {
  type: "error",
  inputs: [],
  name: "AccessController__ZeroModuleRegistry"
}, {
  type: "error",
  inputs: [{
    name: "authority",
    internalType: "address",
    type: "address"
  }],
  name: "AccessManagedInvalidAuthority"
}, {
  type: "error",
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address"
  }, {
    name: "delay",
    internalType: "uint32",
    type: "uint32"
  }],
  name: "AccessManagedRequiredDelay"
}, {
  type: "error",
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address"
  }],
  name: "AccessManagedUnauthorized"
}, {
  type: "error",
  inputs: [{
    name: "target",
    internalType: "address",
    type: "address"
  }],
  name: "AddressEmptyCode"
}, {
  type: "error",
  inputs: [{
    name: "implementation",
    internalType: "address",
    type: "address"
  }],
  name: "ERC1967InvalidImplementation"
}, {
  type: "error",
  inputs: [],
  name: "ERC1967NonPayable"
}, {
  type: "error",
  inputs: [],
  name: "EnforcedPause"
}, {
  type: "error",
  inputs: [],
  name: "ExpectedPause"
}, {
  type: "error",
  inputs: [],
  name: "FailedInnerCall"
}, {
  type: "error",
  inputs: [],
  name: "InvalidInitialization"
}, {
  type: "error",
  inputs: [],
  name: "NotInitializing"
}, {
  type: "error",
  inputs: [],
  name: "UUPSUnauthorizedCallContext"
}, {
  type: "error",
  inputs: [{
    name: "slot",
    internalType: "bytes32",
    type: "bytes32"
  }],
  name: "UUPSUnsupportedProxiableUUID"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "authority",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "AuthorityUpdated"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "version",
    internalType: "uint64",
    type: "uint64",
    indexed: false
  }],
  name: "Initialized"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "account",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "Paused"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "ipAccountOwner",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "ipAccount",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "signer",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "to",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "func",
    internalType: "bytes4",
    type: "bytes4",
    indexed: false
  }, {
    name: "permission",
    internalType: "uint8",
    type: "uint8",
    indexed: false
  }],
  name: "PermissionSet"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "account",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "Unpaused"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "implementation",
    internalType: "address",
    type: "address",
    indexed: true
  }],
  name: "Upgraded"
}, {
  type: "function",
  inputs: [],
  name: "IP_ACCOUNT_REGISTRY",
  outputs: [{
    name: "",
    internalType: "contract IIPAccountRegistry",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "MODULE_REGISTRY",
  outputs: [{
    name: "",
    internalType: "contract IModuleRegistry",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "UPGRADE_INTERFACE_VERSION",
  outputs: [{
    name: "",
    internalType: "string",
    type: "string"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "accessManager",
    internalType: "address",
    type: "address"
  }],
  name: "__ProtocolPausable_init",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "authority",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "ipAccount",
    internalType: "address",
    type: "address"
  }, {
    name: "signer",
    internalType: "address",
    type: "address"
  }, {
    name: "to",
    internalType: "address",
    type: "address"
  }, {
    name: "func",
    internalType: "bytes4",
    type: "bytes4"
  }],
  name: "checkPermission",
  outputs: [],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "ipAccount",
    internalType: "address",
    type: "address"
  }, {
    name: "signer",
    internalType: "address",
    type: "address"
  }, {
    name: "to",
    internalType: "address",
    type: "address"
  }, {
    name: "func",
    internalType: "bytes4",
    type: "bytes4"
  }],
  name: "getPermission",
  outputs: [{
    name: "",
    internalType: "uint8",
    type: "uint8"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "accessManager",
    internalType: "address",
    type: "address"
  }],
  name: "initialize",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "isConsumingScheduledOp",
  outputs: [{
    name: "",
    internalType: "bytes4",
    type: "bytes4"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "pause",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "paused",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "proxiableUUID",
  outputs: [{
    name: "",
    internalType: "bytes32",
    type: "bytes32"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "ipAccount",
    internalType: "address",
    type: "address"
  }, {
    name: "signer",
    internalType: "address",
    type: "address"
  }, {
    name: "permission",
    internalType: "uint8",
    type: "uint8"
  }],
  name: "setAllPermissions",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "newAuthority",
    internalType: "address",
    type: "address"
  }],
  name: "setAuthority",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "permissions",
    internalType: "struct AccessPermission.Permission[]",
    type: "tuple[]",
    components: [{
      name: "ipAccount",
      internalType: "address",
      type: "address"
    }, {
      name: "signer",
      internalType: "address",
      type: "address"
    }, {
      name: "to",
      internalType: "address",
      type: "address"
    }, {
      name: "func",
      internalType: "bytes4",
      type: "bytes4"
    }, {
      name: "permission",
      internalType: "uint8",
      type: "uint8"
    }]
  }],
  name: "setBatchPermissions",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "ipAccount",
    internalType: "address",
    type: "address"
  }, {
    name: "signer",
    internalType: "address",
    type: "address"
  }, {
    name: "to",
    internalType: "address",
    type: "address"
  }, {
    name: "func",
    internalType: "bytes4",
    type: "bytes4"
  }, {
    name: "permission",
    internalType: "uint8",
    type: "uint8"
  }],
  name: "setPermission",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "unpause",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "newImplementation",
    internalType: "address",
    type: "address"
  }, {
    name: "data",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "upgradeToAndCall",
  outputs: [],
  stateMutability: "payable"
}];

/**
 * [__View Contract on Sepolia Etherscan__](https://sepolia.etherscan.io/address/0xF9936a224b3Deb6f9A4645ccAfa66f7ECe83CF0A)
 */
var accessControllerAddress = {
  11155111: "0xF9936a224b3Deb6f9A4645ccAfa66f7ECe83CF0A"
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// DisputeModule
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/**
 * [__View Contract on Sepolia Etherscan__](https://sepolia.etherscan.io/address/0xEB7B1dd43B81A7be1fA427515a2b173B454A9832)
 */
var disputeModuleAbi = [{
  type: "constructor",
  inputs: [{
    name: "accessController",
    internalType: "address",
    type: "address"
  }, {
    name: "ipAssetRegistry",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseRegistry",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "nonpayable"
}, {
  type: "error",
  inputs: [{
    name: "ipAccount",
    internalType: "address",
    type: "address"
  }],
  name: "AccessControlled__NotIpAccount"
}, {
  type: "error",
  inputs: [],
  name: "AccessControlled__ZeroAddress"
}, {
  type: "error",
  inputs: [{
    name: "authority",
    internalType: "address",
    type: "address"
  }],
  name: "AccessManagedInvalidAuthority"
}, {
  type: "error",
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address"
  }, {
    name: "delay",
    internalType: "uint32",
    type: "uint32"
  }],
  name: "AccessManagedRequiredDelay"
}, {
  type: "error",
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address"
  }],
  name: "AccessManagedUnauthorized"
}, {
  type: "error",
  inputs: [{
    name: "target",
    internalType: "address",
    type: "address"
  }],
  name: "AddressEmptyCode"
}, {
  type: "error",
  inputs: [],
  name: "DisputeModule__NotAbleToResolve"
}, {
  type: "error",
  inputs: [],
  name: "DisputeModule__NotDerivative"
}, {
  type: "error",
  inputs: [],
  name: "DisputeModule__NotDisputeInitiator"
}, {
  type: "error",
  inputs: [],
  name: "DisputeModule__NotInDisputeState"
}, {
  type: "error",
  inputs: [],
  name: "DisputeModule__NotRegisteredIpId"
}, {
  type: "error",
  inputs: [],
  name: "DisputeModule__NotWhitelistedArbitrationPolicy"
}, {
  type: "error",
  inputs: [],
  name: "DisputeModule__NotWhitelistedArbitrationRelayer"
}, {
  type: "error",
  inputs: [],
  name: "DisputeModule__NotWhitelistedDisputeTag"
}, {
  type: "error",
  inputs: [],
  name: "DisputeModule__ParentDisputeNotResolved"
}, {
  type: "error",
  inputs: [],
  name: "DisputeModule__ParentIpIdMismatch"
}, {
  type: "error",
  inputs: [],
  name: "DisputeModule__ParentNotTagged"
}, {
  type: "error",
  inputs: [],
  name: "DisputeModule__ZeroAccessController"
}, {
  type: "error",
  inputs: [],
  name: "DisputeModule__ZeroAccessManager"
}, {
  type: "error",
  inputs: [],
  name: "DisputeModule__ZeroArbitrationPolicy"
}, {
  type: "error",
  inputs: [],
  name: "DisputeModule__ZeroArbitrationRelayer"
}, {
  type: "error",
  inputs: [],
  name: "DisputeModule__ZeroDisputeTag"
}, {
  type: "error",
  inputs: [],
  name: "DisputeModule__ZeroIPAssetRegistry"
}, {
  type: "error",
  inputs: [],
  name: "DisputeModule__ZeroLicenseRegistry"
}, {
  type: "error",
  inputs: [],
  name: "DisputeModule__ZeroLinkToDisputeEvidence"
}, {
  type: "error",
  inputs: [{
    name: "implementation",
    internalType: "address",
    type: "address"
  }],
  name: "ERC1967InvalidImplementation"
}, {
  type: "error",
  inputs: [],
  name: "ERC1967NonPayable"
}, {
  type: "error",
  inputs: [],
  name: "EnforcedPause"
}, {
  type: "error",
  inputs: [],
  name: "ExpectedPause"
}, {
  type: "error",
  inputs: [],
  name: "FailedInnerCall"
}, {
  type: "error",
  inputs: [],
  name: "InvalidInitialization"
}, {
  type: "error",
  inputs: [],
  name: "NotInitializing"
}, {
  type: "error",
  inputs: [],
  name: "ReentrancyGuardReentrantCall"
}, {
  type: "error",
  inputs: [{
    name: "str",
    internalType: "string",
    type: "string"
  }],
  name: "StringTooLong"
}, {
  type: "error",
  inputs: [],
  name: "UUPSUnauthorizedCallContext"
}, {
  type: "error",
  inputs: [{
    name: "slot",
    internalType: "bytes32",
    type: "bytes32"
  }],
  name: "UUPSUnsupportedProxiableUUID"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "arbitrationPolicy",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "ArbitrationPolicySet"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "arbitrationPolicy",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "allowed",
    internalType: "bool",
    type: "bool",
    indexed: false
  }],
  name: "ArbitrationPolicyWhitelistUpdated"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "arbitrationPolicy",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "arbitrationRelayer",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "allowed",
    internalType: "bool",
    type: "bool",
    indexed: false
  }],
  name: "ArbitrationRelayerWhitelistUpdated"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "authority",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "AuthorityUpdated"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "arbitrationPolicy",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "DefaultArbitrationPolicyUpdated"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "parentIpId",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "derivativeIpId",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "parentDisputeId",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }, {
    name: "tag",
    internalType: "bytes32",
    type: "bytes32",
    indexed: false
  }],
  name: "DerivativeTaggedOnParentInfringement"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "disputeId",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }, {
    name: "data",
    internalType: "bytes",
    type: "bytes",
    indexed: false
  }],
  name: "DisputeCancelled"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "disputeId",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }, {
    name: "decision",
    internalType: "bool",
    type: "bool",
    indexed: false
  }, {
    name: "data",
    internalType: "bytes",
    type: "bytes",
    indexed: false
  }],
  name: "DisputeJudgementSet"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "disputeId",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }, {
    name: "targetIpId",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "disputeInitiator",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "arbitrationPolicy",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "linkToDisputeEvidence",
    internalType: "bytes32",
    type: "bytes32",
    indexed: false
  }, {
    name: "targetTag",
    internalType: "bytes32",
    type: "bytes32",
    indexed: false
  }, {
    name: "data",
    internalType: "bytes",
    type: "bytes",
    indexed: false
  }],
  name: "DisputeRaised"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "disputeId",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }],
  name: "DisputeResolved"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "version",
    internalType: "uint64",
    type: "uint64",
    indexed: false
  }],
  name: "Initialized"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "account",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "Paused"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "tag",
    internalType: "bytes32",
    type: "bytes32",
    indexed: false
  }, {
    name: "allowed",
    internalType: "bool",
    type: "bool",
    indexed: false
  }],
  name: "TagWhitelistUpdated"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "account",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "Unpaused"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "implementation",
    internalType: "address",
    type: "address",
    indexed: true
  }],
  name: "Upgraded"
}, {
  type: "function",
  inputs: [],
  name: "ACCESS_CONTROLLER",
  outputs: [{
    name: "",
    internalType: "contract IAccessController",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "IN_DISPUTE",
  outputs: [{
    name: "",
    internalType: "bytes32",
    type: "bytes32"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "IP_ACCOUNT_REGISTRY",
  outputs: [{
    name: "",
    internalType: "contract IIPAccountRegistry",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "IP_ASSET_REGISTRY",
  outputs: [{
    name: "",
    internalType: "contract IIPAssetRegistry",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "LICENSE_REGISTRY",
  outputs: [{
    name: "",
    internalType: "contract ILicenseRegistry",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "UPGRADE_INTERFACE_VERSION",
  outputs: [{
    name: "",
    internalType: "string",
    type: "string"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "accessManager",
    internalType: "address",
    type: "address"
  }],
  name: "__ProtocolPausable_init",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }],
  name: "arbitrationPolicies",
  outputs: [{
    name: "policy",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "authority",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "baseArbitrationPolicy",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "disputeId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "data",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "cancelDispute",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "disputeCounter",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "disputeId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "disputes",
  outputs: [{
    name: "targetIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "disputeInitiator",
    internalType: "address",
    type: "address"
  }, {
    name: "arbitrationPolicy",
    internalType: "address",
    type: "address"
  }, {
    name: "linkToDisputeEvidence",
    internalType: "bytes32",
    type: "bytes32"
  }, {
    name: "targetTag",
    internalType: "bytes32",
    type: "bytes32"
  }, {
    name: "currentTag",
    internalType: "bytes32",
    type: "bytes32"
  }, {
    name: "parentDisputeId",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "accessManager",
    internalType: "address",
    type: "address"
  }],
  name: "initialize",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "isConsumingScheduledOp",
  outputs: [{
    name: "",
    internalType: "bytes4",
    type: "bytes4"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }],
  name: "isIpTagged",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "arbitrationPolicy",
    internalType: "address",
    type: "address"
  }],
  name: "isWhitelistedArbitrationPolicy",
  outputs: [{
    name: "allowed",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "arbitrationPolicy",
    internalType: "address",
    type: "address"
  }, {
    name: "arbitrationRelayer",
    internalType: "address",
    type: "address"
  }],
  name: "isWhitelistedArbitrationRelayer",
  outputs: [{
    name: "allowed",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "tag",
    internalType: "bytes32",
    type: "bytes32"
  }],
  name: "isWhitelistedDisputeTag",
  outputs: [{
    name: "allowed",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "data",
    internalType: "bytes[]",
    type: "bytes[]"
  }],
  name: "multicall",
  outputs: [{
    name: "results",
    internalType: "bytes[]",
    type: "bytes[]"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "name",
  outputs: [{
    name: "",
    internalType: "string",
    type: "string"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "pause",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "paused",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "proxiableUUID",
  outputs: [{
    name: "",
    internalType: "bytes32",
    type: "bytes32"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "targetIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "linkToDisputeEvidence",
    internalType: "string",
    type: "string"
  }, {
    name: "targetTag",
    internalType: "bytes32",
    type: "bytes32"
  }, {
    name: "data",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "raiseDispute",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "disputeId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "data",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "resolveDispute",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "arbitrationPolicy",
    internalType: "address",
    type: "address"
  }],
  name: "setArbitrationPolicy",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "newAuthority",
    internalType: "address",
    type: "address"
  }],
  name: "setAuthority",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "arbitrationPolicy",
    internalType: "address",
    type: "address"
  }],
  name: "setBaseArbitrationPolicy",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "disputeId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "decision",
    internalType: "bool",
    type: "bool"
  }, {
    name: "data",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "setDisputeJudgement",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "interfaceId",
    internalType: "bytes4",
    type: "bytes4"
  }],
  name: "supportsInterface",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "parentIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "derivativeIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "parentDisputeId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "tagDerivativeIfParentInfringed",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "unpause",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "newImplementation",
    internalType: "address",
    type: "address"
  }, {
    name: "data",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "upgradeToAndCall",
  outputs: [],
  stateMutability: "payable"
}, {
  type: "function",
  inputs: [{
    name: "arbitrationPolicy",
    internalType: "address",
    type: "address"
  }, {
    name: "allowed",
    internalType: "bool",
    type: "bool"
  }],
  name: "whitelistArbitrationPolicy",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "arbitrationPolicy",
    internalType: "address",
    type: "address"
  }, {
    name: "arbPolicyRelayer",
    internalType: "address",
    type: "address"
  }, {
    name: "allowed",
    internalType: "bool",
    type: "bool"
  }],
  name: "whitelistArbitrationRelayer",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "tag",
    internalType: "bytes32",
    type: "bytes32"
  }, {
    name: "allowed",
    internalType: "bool",
    type: "bool"
  }],
  name: "whitelistDisputeTag",
  outputs: [],
  stateMutability: "nonpayable"
}];

/**
 * [__View Contract on Sepolia Etherscan__](https://sepolia.etherscan.io/address/0xEB7B1dd43B81A7be1fA427515a2b173B454A9832)
 */
var disputeModuleAddress = {
  11155111: "0xEB7B1dd43B81A7be1fA427515a2b173B454A9832"
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// IPAccountImpl
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/**
 * [__View Contract on Sepolia Etherscan__](https://sepolia.etherscan.io/address/0x36a5f0D61f6Bab3C6Dde211E5a6762Cb18a8060d)
 */
var ipAccountImplAbi = [{
  type: "constructor",
  inputs: [{
    name: "accessController",
    internalType: "address",
    type: "address"
  }, {
    name: "ipAssetRegistry",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseRegistry",
    internalType: "address",
    type: "address"
  }, {
    name: "moduleRegistry",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "nonpayable"
}, {
  type: "error",
  inputs: [{
    name: "module",
    internalType: "address",
    type: "address"
  }],
  name: "IPAccountStorage__NotRegisteredModule"
}, {
  type: "error",
  inputs: [],
  name: "IPAccount__ExpiredSignature"
}, {
  type: "error",
  inputs: [],
  name: "IPAccount__InvalidCalldata"
}, {
  type: "error",
  inputs: [],
  name: "IPAccount__InvalidSignature"
}, {
  type: "error",
  inputs: [],
  name: "IPAccount__InvalidSigner"
}, {
  type: "error",
  inputs: [],
  name: "IPAccount__ZeroAccessController"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "to",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "value",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }, {
    name: "data",
    internalType: "bytes",
    type: "bytes",
    indexed: false
  }, {
    name: "nonce",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }],
  name: "Executed"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "to",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "value",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }, {
    name: "data",
    internalType: "bytes",
    type: "bytes",
    indexed: false
  }, {
    name: "nonce",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }, {
    name: "deadline",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }, {
    name: "signer",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "signature",
    internalType: "bytes",
    type: "bytes",
    indexed: false
  }],
  name: "ExecutedWithSig"
}, {
  type: "function",
  inputs: [],
  name: "ACCESS_CONTROLLER",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "IP_ASSET_REGISTRY",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "LICENSE_REGISTRY",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "MODULE_REGISTRY",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "",
    internalType: "bytes32",
    type: "bytes32"
  }, {
    name: "",
    internalType: "bytes32",
    type: "bytes32"
  }],
  name: "bytes32Data",
  outputs: [{
    name: "",
    internalType: "bytes32",
    type: "bytes32"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "",
    internalType: "bytes32",
    type: "bytes32"
  }, {
    name: "",
    internalType: "bytes32",
    type: "bytes32"
  }],
  name: "bytesData",
  outputs: [{
    name: "",
    internalType: "bytes",
    type: "bytes"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "to",
    internalType: "address",
    type: "address"
  }, {
    name: "value",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "data",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "execute",
  outputs: [{
    name: "result",
    internalType: "bytes",
    type: "bytes"
  }],
  stateMutability: "payable"
}, {
  type: "function",
  inputs: [{
    name: "to",
    internalType: "address",
    type: "address"
  }, {
    name: "value",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "data",
    internalType: "bytes",
    type: "bytes"
  }, {
    name: "signer",
    internalType: "address",
    type: "address"
  }, {
    name: "deadline",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "signature",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "executeWithSig",
  outputs: [{
    name: "result",
    internalType: "bytes",
    type: "bytes"
  }],
  stateMutability: "payable"
}, {
  type: "function",
  inputs: [{
    name: "key",
    internalType: "bytes32",
    type: "bytes32"
  }],
  name: "getBytes",
  outputs: [{
    name: "",
    internalType: "bytes",
    type: "bytes"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "namespace",
    internalType: "bytes32",
    type: "bytes32"
  }, {
    name: "key",
    internalType: "bytes32",
    type: "bytes32"
  }],
  name: "getBytes",
  outputs: [{
    name: "",
    internalType: "bytes",
    type: "bytes"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "namespace",
    internalType: "bytes32",
    type: "bytes32"
  }, {
    name: "key",
    internalType: "bytes32",
    type: "bytes32"
  }],
  name: "getBytes32",
  outputs: [{
    name: "",
    internalType: "bytes32",
    type: "bytes32"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "key",
    internalType: "bytes32",
    type: "bytes32"
  }],
  name: "getBytes32",
  outputs: [{
    name: "",
    internalType: "bytes32",
    type: "bytes32"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "signer",
    internalType: "address",
    type: "address"
  }, {
    name: "data",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "isValidSigner",
  outputs: [{
    name: "",
    internalType: "bytes4",
    type: "bytes4"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }, {
    name: "",
    internalType: "address",
    type: "address"
  }, {
    name: "",
    internalType: "uint256[]",
    type: "uint256[]"
  }, {
    name: "",
    internalType: "uint256[]",
    type: "uint256[]"
  }, {
    name: "",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "onERC1155BatchReceived",
  outputs: [{
    name: "",
    internalType: "bytes4",
    type: "bytes4"
  }],
  stateMutability: "pure"
}, {
  type: "function",
  inputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }, {
    name: "",
    internalType: "address",
    type: "address"
  }, {
    name: "",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "onERC1155Received",
  outputs: [{
    name: "",
    internalType: "bytes4",
    type: "bytes4"
  }],
  stateMutability: "pure"
}, {
  type: "function",
  inputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }, {
    name: "",
    internalType: "address",
    type: "address"
  }, {
    name: "",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "onERC721Received",
  outputs: [{
    name: "",
    internalType: "bytes4",
    type: "bytes4"
  }],
  stateMutability: "pure"
}, {
  type: "function",
  inputs: [],
  name: "owner",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "key",
    internalType: "bytes32",
    type: "bytes32"
  }, {
    name: "value",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "setBytes",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "key",
    internalType: "bytes32",
    type: "bytes32"
  }, {
    name: "value",
    internalType: "bytes32",
    type: "bytes32"
  }],
  name: "setBytes32",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "state",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "interfaceId",
    internalType: "bytes4",
    type: "bytes4"
  }],
  name: "supportsInterface",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "token",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "",
    internalType: "address",
    type: "address"
  }, {
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "receive",
  stateMutability: "payable"
}];

/**
 * [__View Contract on Sepolia Etherscan__](https://sepolia.etherscan.io/address/0x36a5f0D61f6Bab3C6Dde211E5a6762Cb18a8060d)
 */
var ipAccountImplAddress = {
  11155111: "0x36a5f0D61f6Bab3C6Dde211E5a6762Cb18a8060d"
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// IPAssetRegistry
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/**
 * [__View Contract on Sepolia Etherscan__](https://sepolia.etherscan.io/address/0xd43fE0d865cb5C26b1351d3eAf2E3064BE3276F6)
 */
var ipAssetRegistryAbi = [{
  type: "constructor",
  inputs: [{
    name: "erc6551Registry",
    internalType: "address",
    type: "address"
  }, {
    name: "ipAccountImpl",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "nonpayable"
}, {
  type: "error",
  inputs: [{
    name: "authority",
    internalType: "address",
    type: "address"
  }],
  name: "AccessManagedInvalidAuthority"
}, {
  type: "error",
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address"
  }, {
    name: "delay",
    internalType: "uint32",
    type: "uint32"
  }],
  name: "AccessManagedRequiredDelay"
}, {
  type: "error",
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address"
  }],
  name: "AccessManagedUnauthorized"
}, {
  type: "error",
  inputs: [{
    name: "target",
    internalType: "address",
    type: "address"
  }],
  name: "AddressEmptyCode"
}, {
  type: "error",
  inputs: [{
    name: "implementation",
    internalType: "address",
    type: "address"
  }],
  name: "ERC1967InvalidImplementation"
}, {
  type: "error",
  inputs: [],
  name: "ERC1967NonPayable"
}, {
  type: "error",
  inputs: [],
  name: "EnforcedPause"
}, {
  type: "error",
  inputs: [],
  name: "ExpectedPause"
}, {
  type: "error",
  inputs: [],
  name: "FailedInnerCall"
}, {
  type: "error",
  inputs: [],
  name: "IPAccountRegistry_ZeroIpAccountImpl"
}, {
  type: "error",
  inputs: [],
  name: "IPAssetRegistry__AlreadyRegistered"
}, {
  type: "error",
  inputs: [{
    name: "contractAddress",
    internalType: "address",
    type: "address"
  }, {
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "IPAssetRegistry__InvalidToken"
}, {
  type: "error",
  inputs: [{
    name: "contractAddress",
    internalType: "address",
    type: "address"
  }],
  name: "IPAssetRegistry__UnsupportedIERC721"
}, {
  type: "error",
  inputs: [{
    name: "contractAddress",
    internalType: "address",
    type: "address"
  }],
  name: "IPAssetRegistry__UnsupportedIERC721Metadata"
}, {
  type: "error",
  inputs: [],
  name: "IPAssetRegistry__ZeroAccessManager"
}, {
  type: "error",
  inputs: [],
  name: "InvalidInitialization"
}, {
  type: "error",
  inputs: [],
  name: "NotInitializing"
}, {
  type: "error",
  inputs: [{
    name: "value",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "length",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "StringsInsufficientHexLength"
}, {
  type: "error",
  inputs: [],
  name: "UUPSUnauthorizedCallContext"
}, {
  type: "error",
  inputs: [{
    name: "slot",
    internalType: "bytes32",
    type: "bytes32"
  }],
  name: "UUPSUnsupportedProxiableUUID"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "authority",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "AuthorityUpdated"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "account",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "implementation",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "chainId",
    internalType: "uint256",
    type: "uint256",
    indexed: true
  }, {
    name: "tokenContract",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "tokenId",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }],
  name: "IPAccountRegistered"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "chainId",
    internalType: "uint256",
    type: "uint256",
    indexed: true
  }, {
    name: "tokenContract",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "tokenId",
    internalType: "uint256",
    type: "uint256",
    indexed: true
  }, {
    name: "name",
    internalType: "string",
    type: "string",
    indexed: false
  }, {
    name: "uri",
    internalType: "string",
    type: "string",
    indexed: false
  }, {
    name: "registrationDate",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }],
  name: "IPRegistered"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "version",
    internalType: "uint64",
    type: "uint64",
    indexed: false
  }],
  name: "Initialized"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "account",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "Paused"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "account",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "Unpaused"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "implementation",
    internalType: "address",
    type: "address",
    indexed: true
  }],
  name: "Upgraded"
}, {
  type: "function",
  inputs: [],
  name: "ERC6551_PUBLIC_REGISTRY",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "IP_ACCOUNT_IMPL",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "IP_ACCOUNT_SALT",
  outputs: [{
    name: "",
    internalType: "bytes32",
    type: "bytes32"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "UPGRADE_INTERFACE_VERSION",
  outputs: [{
    name: "",
    internalType: "string",
    type: "string"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "accessManager",
    internalType: "address",
    type: "address"
  }],
  name: "__ProtocolPausable_init",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "authority",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "getIPAccountImpl",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "accessManager",
    internalType: "address",
    type: "address"
  }],
  name: "initialize",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "chainId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "tokenContract",
    internalType: "address",
    type: "address"
  }, {
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "ipAccount",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "chainId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "tokenContract",
    internalType: "address",
    type: "address"
  }, {
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "ipId",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "isConsumingScheduledOp",
  outputs: [{
    name: "",
    internalType: "bytes4",
    type: "bytes4"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "id",
    internalType: "address",
    type: "address"
  }],
  name: "isRegistered",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "pause",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "paused",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "proxiableUUID",
  outputs: [{
    name: "",
    internalType: "bytes32",
    type: "bytes32"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "chainid",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "tokenContract",
    internalType: "address",
    type: "address"
  }, {
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "register",
  outputs: [{
    name: "id",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "chainId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "tokenContract",
    internalType: "address",
    type: "address"
  }, {
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "registerIpAccount",
  outputs: [{
    name: "ipAccountAddress",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "newAuthority",
    internalType: "address",
    type: "address"
  }],
  name: "setAuthority",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "totalSupply",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "unpause",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "newImplementation",
    internalType: "address",
    type: "address"
  }, {
    name: "data",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "upgradeToAndCall",
  outputs: [],
  stateMutability: "payable"
}];

/**
 * [__View Contract on Sepolia Etherscan__](https://sepolia.etherscan.io/address/0xd43fE0d865cb5C26b1351d3eAf2E3064BE3276F6)
 */
var ipAssetRegistryAddress = {
  11155111: "0xd43fE0d865cb5C26b1351d3eAf2E3064BE3276F6"
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// IpRoyaltyVaultImpl
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/**
 * [__View Contract on Sepolia Etherscan__](https://sepolia.etherscan.io/address/0xD6c2AfB61085f1359d47159f2271BDD0EeBf19C2)
 */
var ipRoyaltyVaultImplAbi = [{
  type: "constructor",
  inputs: [{
    name: "royaltyPolicyLAP",
    internalType: "address",
    type: "address"
  }, {
    name: "disputeModule",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "nonpayable"
}, {
  type: "error",
  inputs: [],
  name: "IpRoyaltyVault__AlreadyClaimed"
}, {
  type: "error",
  inputs: [],
  name: "IpRoyaltyVault__ClaimerNotAnAncestor"
}, {
  type: "error",
  inputs: [],
  name: "IpRoyaltyVault__EnforcedPause"
}, {
  type: "error",
  inputs: [],
  name: "IpRoyaltyVault__IpTagged"
}, {
  type: "error",
  inputs: [],
  name: "IpRoyaltyVault__NotRoyaltyPolicyLAP"
}, {
  type: "error",
  inputs: [],
  name: "IpRoyaltyVault__SnapshotIntervalTooShort"
}, {
  type: "error",
  inputs: [],
  name: "IpRoyaltyVault__ZeroDisputeModule"
}, {
  type: "error",
  inputs: [],
  name: "IpRoyaltyVault__ZeroRoyaltyPolicyLAP"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "owner",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "spender",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "value",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }],
  name: "Approval"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "version",
    internalType: "uint8",
    type: "uint8",
    indexed: false
  }],
  name: "Initialized"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "claimer",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "token",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "amount",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }],
  name: "RevenueTokenClaimed"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "ancestorIpId",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "royaltyTokensCollected",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }],
  name: "RoyaltyTokensCollected"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "id",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }],
  name: "Snapshot"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "snapshotId",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }, {
    name: "snapshotTimestamp",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }, {
    name: "unclaimedTokens",
    internalType: "uint32",
    type: "uint32",
    indexed: false
  }],
  name: "SnapshotCompleted"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "from",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "to",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "value",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }],
  name: "Transfer"
}, {
  type: "function",
  inputs: [],
  name: "DISPUTE_MODULE",
  outputs: [{
    name: "",
    internalType: "contract IDisputeModule",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "ROYALTY_POLICY_LAP",
  outputs: [{
    name: "",
    internalType: "contract IRoyaltyPolicyLAP",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "token",
    internalType: "address",
    type: "address"
  }],
  name: "addIpRoyaltyVaultTokens",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "owner",
    internalType: "address",
    type: "address"
  }, {
    name: "spender",
    internalType: "address",
    type: "address"
  }],
  name: "allowance",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "token",
    internalType: "address",
    type: "address"
  }],
  name: "ancestorsVaultAmount",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "spender",
    internalType: "address",
    type: "address"
  }, {
    name: "amount",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "approve",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "account",
    internalType: "address",
    type: "address"
  }],
  name: "balanceOf",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "account",
    internalType: "address",
    type: "address"
  }, {
    name: "snapshotId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "balanceOfAt",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "snapshotIds",
    internalType: "uint256[]",
    type: "uint256[]"
  }, {
    name: "token",
    internalType: "address",
    type: "address"
  }],
  name: "claimRevenueBySnapshotBatch",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "snapshotId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "tokenList",
    internalType: "address[]",
    type: "address[]"
  }],
  name: "claimRevenueByTokenBatch",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "token",
    internalType: "address",
    type: "address"
  }],
  name: "claimVaultAmount",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "snapshotId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "token",
    internalType: "address",
    type: "address"
  }],
  name: "claimableAtSnapshot",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "account",
    internalType: "address",
    type: "address"
  }, {
    name: "snapshotId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "token",
    internalType: "address",
    type: "address"
  }],
  name: "claimableRevenue",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "ancestorIpId",
    internalType: "address",
    type: "address"
  }],
  name: "collectRoyaltyTokens",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "decimals",
  outputs: [{
    name: "",
    internalType: "uint8",
    type: "uint8"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "spender",
    internalType: "address",
    type: "address"
  }, {
    name: "subtractedValue",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "decreaseAllowance",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "spender",
    internalType: "address",
    type: "address"
  }, {
    name: "addedValue",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "increaseAllowance",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "name",
    internalType: "string",
    type: "string"
  }, {
    name: "symbol",
    internalType: "string",
    type: "string"
  }, {
    name: "supply",
    internalType: "uint32",
    type: "uint32"
  }, {
    name: "unclaimedTokens",
    internalType: "uint32",
    type: "uint32"
  }, {
    name: "ipIdAddress",
    internalType: "address",
    type: "address"
  }],
  name: "initialize",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "ipId",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "snapshotId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "claimer",
    internalType: "address",
    type: "address"
  }, {
    name: "token",
    internalType: "address",
    type: "address"
  }],
  name: "isClaimedAtSnapshot",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "ancestorIpId",
    internalType: "address",
    type: "address"
  }],
  name: "isCollectedByAncestor",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "lastSnapshotTimestamp",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "name",
  outputs: [{
    name: "",
    internalType: "string",
    type: "string"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "snapshot",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "symbol",
  outputs: [{
    name: "",
    internalType: "string",
    type: "string"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "tokens",
  outputs: [{
    name: "",
    internalType: "address[]",
    type: "address[]"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "totalSupply",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "snapshotId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "totalSupplyAt",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "to",
    internalType: "address",
    type: "address"
  }, {
    name: "amount",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "transfer",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "from",
    internalType: "address",
    type: "address"
  }, {
    name: "to",
    internalType: "address",
    type: "address"
  }, {
    name: "amount",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "transferFrom",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "snapshotId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "unclaimedAtSnapshot",
  outputs: [{
    name: "",
    internalType: "uint32",
    type: "uint32"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "unclaimedRoyaltyTokens",
  outputs: [{
    name: "",
    internalType: "uint32",
    type: "uint32"
  }],
  stateMutability: "view"
}];

/**
 * [__View Contract on Sepolia Etherscan__](https://sepolia.etherscan.io/address/0xD6c2AfB61085f1359d47159f2271BDD0EeBf19C2)
 */
var ipRoyaltyVaultImplAddress = {
  11155111: "0xD6c2AfB61085f1359d47159f2271BDD0EeBf19C2"
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// LicenseRegistry
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/**
 * [__View Contract on Sepolia Etherscan__](https://sepolia.etherscan.io/address/0x4f4b1bf7135C7ff1462826CCA81B048Ed19562ed)
 */
var licenseRegistryAbi = [{
  type: "constructor",
  inputs: [{
    name: "licensingModule",
    internalType: "address",
    type: "address"
  }, {
    name: "disputeModule",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "nonpayable"
}, {
  type: "error",
  inputs: [{
    name: "authority",
    internalType: "address",
    type: "address"
  }],
  name: "AccessManagedInvalidAuthority"
}, {
  type: "error",
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address"
  }, {
    name: "delay",
    internalType: "uint32",
    type: "uint32"
  }],
  name: "AccessManagedRequiredDelay"
}, {
  type: "error",
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address"
  }],
  name: "AccessManagedUnauthorized"
}, {
  type: "error",
  inputs: [{
    name: "target",
    internalType: "address",
    type: "address"
  }],
  name: "AddressEmptyCode"
}, {
  type: "error",
  inputs: [{
    name: "implementation",
    internalType: "address",
    type: "address"
  }],
  name: "ERC1967InvalidImplementation"
}, {
  type: "error",
  inputs: [],
  name: "ERC1967NonPayable"
}, {
  type: "error",
  inputs: [],
  name: "FailedInnerCall"
}, {
  type: "error",
  inputs: [],
  name: "InvalidInitialization"
}, {
  type: "error",
  inputs: [],
  name: "LicenseRegistry__CallerNotLicensingModule"
}, {
  type: "error",
  inputs: [{
    name: "childIpId",
    internalType: "address",
    type: "address"
  }],
  name: "LicenseRegistry__DerivativeAlreadyRegistered"
}, {
  type: "error",
  inputs: [{
    name: "childIpId",
    internalType: "address",
    type: "address"
  }],
  name: "LicenseRegistry__DerivativeIpAlreadyHasLicense"
}, {
  type: "error",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }],
  name: "LicenseRegistry__DerivativeIsParent"
}, {
  type: "error",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "LicenseRegistry__DuplicateLicense"
}, {
  type: "error",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "index",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "length",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "LicenseRegistry__IndexOutOfBounds"
}, {
  type: "error",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }],
  name: "LicenseRegistry__IpExpired"
}, {
  type: "error",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "LicenseRegistry__LicenseTermsAlreadyAttached"
}, {
  type: "error",
  inputs: [{
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "LicenseRegistry__LicenseTermsNotExists"
}, {
  type: "error",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "LicenseRegistry__LicensorIpHasNoLicenseTerms"
}, {
  type: "error",
  inputs: [],
  name: "LicenseRegistry__NoParentIp"
}, {
  type: "error",
  inputs: [{
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }],
  name: "LicenseRegistry__NotLicenseTemplate"
}, {
  type: "error",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }],
  name: "LicenseRegistry__ParentIpExpired"
}, {
  type: "error",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "LicenseRegistry__ParentIpHasNoLicenseTerms"
}, {
  type: "error",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }],
  name: "LicenseRegistry__ParentIpTagged"
}, {
  type: "error",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }],
  name: "LicenseRegistry__ParentIpUnmatchedLicenseTemplate"
}, {
  type: "error",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "newLicenseTemplate",
    internalType: "address",
    type: "address"
  }],
  name: "LicenseRegistry__UnmatchedLicenseTemplate"
}, {
  type: "error",
  inputs: [{
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }],
  name: "LicenseRegistry__UnregisteredLicenseTemplate"
}, {
  type: "error",
  inputs: [],
  name: "LicenseRegistry__ZeroAccessManager"
}, {
  type: "error",
  inputs: [],
  name: "LicenseRegistry__ZeroDisputeModule"
}, {
  type: "error",
  inputs: [],
  name: "LicenseRegistry__ZeroLicensingModule"
}, {
  type: "error",
  inputs: [],
  name: "LicensingModule__DerivativesCannotAddLicenseTerms"
}, {
  type: "error",
  inputs: [{
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "LicensingModule__LicenseTermsNotFound"
}, {
  type: "error",
  inputs: [],
  name: "NotInitializing"
}, {
  type: "error",
  inputs: [],
  name: "UUPSUnauthorizedCallContext"
}, {
  type: "error",
  inputs: [{
    name: "slot",
    internalType: "bytes32",
    type: "bytes32"
  }],
  name: "UUPSUnsupportedProxiableUUID"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "authority",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "AuthorityUpdated"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "expireTime",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }],
  name: "ExpirationTimeSet"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "version",
    internalType: "uint64",
    type: "uint64",
    indexed: false
  }],
  name: "Initialized"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "licenseTemplate",
    internalType: "address",
    type: "address",
    indexed: true
  }],
  name: "LicenseTemplateRegistered"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "licensingConfig",
    internalType: "struct Licensing.LicensingConfig",
    type: "tuple",
    components: [{
      name: "isSet",
      internalType: "bool",
      type: "bool"
    }, {
      name: "mintingFee",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "licensingHook",
      internalType: "address",
      type: "address"
    }, {
      name: "hookData",
      internalType: "bytes",
      type: "bytes"
    }],
    indexed: false
  }],
  name: "LicensingConfigSetForIP"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "licenseTemplate",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256",
    indexed: true
  }],
  name: "LicensingConfigSetForLicense"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "implementation",
    internalType: "address",
    type: "address",
    indexed: true
  }],
  name: "Upgraded"
}, {
  type: "function",
  inputs: [],
  name: "DISPUTE_MODULE",
  outputs: [{
    name: "",
    internalType: "contract IDisputeModule",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "EXPIRATION_TIME",
  outputs: [{
    name: "",
    internalType: "bytes32",
    type: "bytes32"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "LICENSING_MODULE",
  outputs: [{
    name: "",
    internalType: "contract ILicensingModule",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "UPGRADE_INTERFACE_VERSION",
  outputs: [{
    name: "",
    internalType: "string",
    type: "string"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "attachLicenseTermsToIp",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "authority",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "exists",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "index",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "getAttachedLicenseTerms",
  outputs: [{
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }],
  name: "getAttachedLicenseTermsCount",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "getDefaultLicenseTerms",
  outputs: [{
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "parentIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "index",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "getDerivativeIp",
  outputs: [{
    name: "childIpId",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "parentIpId",
    internalType: "address",
    type: "address"
  }],
  name: "getDerivativeIpCount",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }],
  name: "getExpireTime",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "getLicensingConfig",
  outputs: [{
    name: "",
    internalType: "struct Licensing.LicensingConfig",
    type: "tuple",
    components: [{
      name: "isSet",
      internalType: "bool",
      type: "bool"
    }, {
      name: "mintingFee",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "licensingHook",
      internalType: "address",
      type: "address"
    }, {
      name: "hookData",
      internalType: "bytes",
      type: "bytes"
    }]
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "childIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "index",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "getParentIp",
  outputs: [{
    name: "parentIpId",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "childIpId",
    internalType: "address",
    type: "address"
  }],
  name: "getParentIpCount",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "parentIpId",
    internalType: "address",
    type: "address"
  }],
  name: "hasDerivativeIps",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "hasIpAttachedLicenseTerms",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "accessManager",
    internalType: "address",
    type: "address"
  }],
  name: "initialize",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "isConsumingScheduledOp",
  outputs: [{
    name: "",
    internalType: "bytes4",
    type: "bytes4"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "childIpId",
    internalType: "address",
    type: "address"
  }],
  name: "isDerivativeIp",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }],
  name: "isExpiredNow",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "parentIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "childIpId",
    internalType: "address",
    type: "address"
  }],
  name: "isParentIp",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }],
  name: "isRegisteredLicenseTemplate",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "proxiableUUID",
  outputs: [{
    name: "",
    internalType: "bytes32",
    type: "bytes32"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "childIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "parentIpIds",
    internalType: "address[]",
    type: "address[]"
  }, {
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTermsIds",
    internalType: "uint256[]",
    type: "uint256[]"
  }],
  name: "registerDerivativeIp",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }],
  name: "registerLicenseTemplate",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "newAuthority",
    internalType: "address",
    type: "address"
  }],
  name: "setAuthority",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "newLicenseTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "newLicenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "setDefaultLicenseTerms",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "expireTime",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "setExpireTime",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "licensingConfig",
    internalType: "struct Licensing.LicensingConfig",
    type: "tuple",
    components: [{
      name: "isSet",
      internalType: "bool",
      type: "bool"
    }, {
      name: "mintingFee",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "licensingHook",
      internalType: "address",
      type: "address"
    }, {
      name: "hookData",
      internalType: "bytes",
      type: "bytes"
    }]
  }],
  name: "setLicensingConfigForIp",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "licensingConfig",
    internalType: "struct Licensing.LicensingConfig",
    type: "tuple",
    components: [{
      name: "isSet",
      internalType: "bool",
      type: "bool"
    }, {
      name: "mintingFee",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "licensingHook",
      internalType: "address",
      type: "address"
    }, {
      name: "hookData",
      internalType: "bytes",
      type: "bytes"
    }]
  }],
  name: "setLicensingConfigForLicense",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "newImplementation",
    internalType: "address",
    type: "address"
  }, {
    name: "data",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "upgradeToAndCall",
  outputs: [],
  stateMutability: "payable"
}, {
  type: "function",
  inputs: [{
    name: "licensorIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "isMintedByIpOwner",
    internalType: "bool",
    type: "bool"
  }],
  name: "verifyMintLicenseToken",
  outputs: [{
    name: "",
    internalType: "struct Licensing.LicensingConfig",
    type: "tuple",
    components: [{
      name: "isSet",
      internalType: "bool",
      type: "bool"
    }, {
      name: "mintingFee",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "licensingHook",
      internalType: "address",
      type: "address"
    }, {
      name: "hookData",
      internalType: "bytes",
      type: "bytes"
    }]
  }],
  stateMutability: "view"
}];

/**
 * [__View Contract on Sepolia Etherscan__](https://sepolia.etherscan.io/address/0x4f4b1bf7135C7ff1462826CCA81B048Ed19562ed)
 */
var licenseRegistryAddress = {
  11155111: "0x4f4b1bf7135C7ff1462826CCA81B048Ed19562ed"
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// LicenseToken
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/**
 * [__View Contract on Sepolia Etherscan__](https://sepolia.etherscan.io/address/0x1333c78A821c9a576209B01a16dDCEF881cAb6f2)
 */
var licenseTokenAbi = [{
  type: "constructor",
  inputs: [{
    name: "licensingModule",
    internalType: "address",
    type: "address"
  }, {
    name: "disputeModule",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "nonpayable"
}, {
  type: "error",
  inputs: [{
    name: "authority",
    internalType: "address",
    type: "address"
  }],
  name: "AccessManagedInvalidAuthority"
}, {
  type: "error",
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address"
  }, {
    name: "delay",
    internalType: "uint32",
    type: "uint32"
  }],
  name: "AccessManagedRequiredDelay"
}, {
  type: "error",
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address"
  }],
  name: "AccessManagedUnauthorized"
}, {
  type: "error",
  inputs: [{
    name: "target",
    internalType: "address",
    type: "address"
  }],
  name: "AddressEmptyCode"
}, {
  type: "error",
  inputs: [{
    name: "implementation",
    internalType: "address",
    type: "address"
  }],
  name: "ERC1967InvalidImplementation"
}, {
  type: "error",
  inputs: [],
  name: "ERC1967NonPayable"
}, {
  type: "error",
  inputs: [],
  name: "ERC721EnumerableForbiddenBatchMint"
}, {
  type: "error",
  inputs: [{
    name: "sender",
    internalType: "address",
    type: "address"
  }, {
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "owner",
    internalType: "address",
    type: "address"
  }],
  name: "ERC721IncorrectOwner"
}, {
  type: "error",
  inputs: [{
    name: "operator",
    internalType: "address",
    type: "address"
  }, {
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "ERC721InsufficientApproval"
}, {
  type: "error",
  inputs: [{
    name: "approver",
    internalType: "address",
    type: "address"
  }],
  name: "ERC721InvalidApprover"
}, {
  type: "error",
  inputs: [{
    name: "operator",
    internalType: "address",
    type: "address"
  }],
  name: "ERC721InvalidOperator"
}, {
  type: "error",
  inputs: [{
    name: "owner",
    internalType: "address",
    type: "address"
  }],
  name: "ERC721InvalidOwner"
}, {
  type: "error",
  inputs: [{
    name: "receiver",
    internalType: "address",
    type: "address"
  }],
  name: "ERC721InvalidReceiver"
}, {
  type: "error",
  inputs: [{
    name: "sender",
    internalType: "address",
    type: "address"
  }],
  name: "ERC721InvalidSender"
}, {
  type: "error",
  inputs: [{
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "ERC721NonexistentToken"
}, {
  type: "error",
  inputs: [{
    name: "owner",
    internalType: "address",
    type: "address"
  }, {
    name: "index",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "ERC721OutOfBoundsIndex"
}, {
  type: "error",
  inputs: [],
  name: "FailedInnerCall"
}, {
  type: "error",
  inputs: [],
  name: "InvalidInitialization"
}, {
  type: "error",
  inputs: [{
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "anotherLicenseTemplate",
    internalType: "address",
    type: "address"
  }],
  name: "LicenseToken__AllLicenseTokensMustFromSameLicenseTemplate"
}, {
  type: "error",
  inputs: [],
  name: "LicenseToken__CallerNotLicensingModule"
}, {
  type: "error",
  inputs: [{
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "iPowner",
    internalType: "address",
    type: "address"
  }, {
    name: "tokenOwner",
    internalType: "address",
    type: "address"
  }],
  name: "LicenseToken__NotLicenseTokenOwner"
}, {
  type: "error",
  inputs: [],
  name: "LicenseToken__NotTransferable"
}, {
  type: "error",
  inputs: [{
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "LicenseToken__RevokedLicense"
}, {
  type: "error",
  inputs: [],
  name: "LicenseToken__ZeroAccessManager"
}, {
  type: "error",
  inputs: [],
  name: "NotInitializing"
}, {
  type: "error",
  inputs: [{
    name: "value",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "length",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "StringsInsufficientHexLength"
}, {
  type: "error",
  inputs: [],
  name: "UUPSUnauthorizedCallContext"
}, {
  type: "error",
  inputs: [{
    name: "slot",
    internalType: "bytes32",
    type: "bytes32"
  }],
  name: "UUPSUnsupportedProxiableUUID"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "owner",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "approved",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "tokenId",
    internalType: "uint256",
    type: "uint256",
    indexed: true
  }],
  name: "Approval"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "owner",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "operator",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "approved",
    internalType: "bool",
    type: "bool",
    indexed: false
  }],
  name: "ApprovalForAll"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "authority",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "AuthorityUpdated"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "_fromTokenId",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }, {
    name: "_toTokenId",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }],
  name: "BatchMetadataUpdate"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "version",
    internalType: "uint64",
    type: "uint64",
    indexed: false
  }],
  name: "Initialized"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "minter",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "receiver",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "tokenId",
    internalType: "uint256",
    type: "uint256",
    indexed: true
  }],
  name: "LicenseTokenMinted"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "from",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "to",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "tokenId",
    internalType: "uint256",
    type: "uint256",
    indexed: true
  }],
  name: "Transfer"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "implementation",
    internalType: "address",
    type: "address",
    indexed: true
  }],
  name: "Upgraded"
}, {
  type: "function",
  inputs: [],
  name: "DISPUTE_MODULE",
  outputs: [{
    name: "",
    internalType: "contract IDisputeModule",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "LICENSING_MODULE",
  outputs: [{
    name: "",
    internalType: "contract ILicensingModule",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "UPGRADE_INTERFACE_VERSION",
  outputs: [{
    name: "",
    internalType: "string",
    type: "string"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "to",
    internalType: "address",
    type: "address"
  }, {
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "approve",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "authority",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "owner",
    internalType: "address",
    type: "address"
  }],
  name: "balanceOf",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "holder",
    internalType: "address",
    type: "address"
  }, {
    name: "tokenIds",
    internalType: "uint256[]",
    type: "uint256[]"
  }],
  name: "burnLicenseTokens",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "getApproved",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "getLicenseTemplate",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "getLicenseTermsId",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "getLicenseTokenMetadata",
  outputs: [{
    name: "",
    internalType: "struct ILicenseToken.LicenseTokenMetadata",
    type: "tuple",
    components: [{
      name: "licensorIpId",
      internalType: "address",
      type: "address"
    }, {
      name: "licenseTemplate",
      internalType: "address",
      type: "address"
    }, {
      name: "licenseTermsId",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "transferable",
      internalType: "bool",
      type: "bool"
    }]
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "getLicensorIpId",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "accessManager",
    internalType: "address",
    type: "address"
  }, {
    name: "imageUrl",
    internalType: "string",
    type: "string"
  }],
  name: "initialize",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "owner",
    internalType: "address",
    type: "address"
  }, {
    name: "operator",
    internalType: "address",
    type: "address"
  }],
  name: "isApprovedForAll",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "isConsumingScheduledOp",
  outputs: [{
    name: "",
    internalType: "bytes4",
    type: "bytes4"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "isLicenseTokenRevoked",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "licensorIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "amount",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "minter",
    internalType: "address",
    type: "address"
  }, {
    name: "receiver",
    internalType: "address",
    type: "address"
  }],
  name: "mintLicenseTokens",
  outputs: [{
    name: "startLicenseTokenId",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "name",
  outputs: [{
    name: "",
    internalType: "string",
    type: "string"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "ownerOf",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "proxiableUUID",
  outputs: [{
    name: "",
    internalType: "bytes32",
    type: "bytes32"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "from",
    internalType: "address",
    type: "address"
  }, {
    name: "to",
    internalType: "address",
    type: "address"
  }, {
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "safeTransferFrom",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "from",
    internalType: "address",
    type: "address"
  }, {
    name: "to",
    internalType: "address",
    type: "address"
  }, {
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "data",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "safeTransferFrom",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "operator",
    internalType: "address",
    type: "address"
  }, {
    name: "approved",
    internalType: "bool",
    type: "bool"
  }],
  name: "setApprovalForAll",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "newAuthority",
    internalType: "address",
    type: "address"
  }],
  name: "setAuthority",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "url",
    internalType: "string",
    type: "string"
  }],
  name: "setLicensingImageUrl",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "interfaceId",
    internalType: "bytes4",
    type: "bytes4"
  }],
  name: "supportsInterface",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "symbol",
  outputs: [{
    name: "",
    internalType: "string",
    type: "string"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "index",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "tokenByIndex",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "owner",
    internalType: "address",
    type: "address"
  }, {
    name: "index",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "tokenOfOwnerByIndex",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "id",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "tokenURI",
  outputs: [{
    name: "",
    internalType: "string",
    type: "string"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "totalMintedTokens",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "totalSupply",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "from",
    internalType: "address",
    type: "address"
  }, {
    name: "to",
    internalType: "address",
    type: "address"
  }, {
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "transferFrom",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "newImplementation",
    internalType: "address",
    type: "address"
  }, {
    name: "data",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "upgradeToAndCall",
  outputs: [],
  stateMutability: "payable"
}, {
  type: "function",
  inputs: [{
    name: "childIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "childIpOwner",
    internalType: "address",
    type: "address"
  }, {
    name: "tokenIds",
    internalType: "uint256[]",
    type: "uint256[]"
  }],
  name: "validateLicenseTokensForDerivative",
  outputs: [{
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "licensorIpIds",
    internalType: "address[]",
    type: "address[]"
  }, {
    name: "licenseTermsIds",
    internalType: "uint256[]",
    type: "uint256[]"
  }],
  stateMutability: "view"
}];

/**
 * [__View Contract on Sepolia Etherscan__](https://sepolia.etherscan.io/address/0x1333c78A821c9a576209B01a16dDCEF881cAb6f2)
 */
var licenseTokenAddress = {
  11155111: "0x1333c78A821c9a576209B01a16dDCEF881cAb6f2"
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// LicensingModule
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/**
 * [__View Contract on Sepolia Etherscan__](https://sepolia.etherscan.io/address/0xe89b0EaA8a0949738efA80bB531a165FB3456CBe)
 */
var licensingModuleAbi = [{
  type: "constructor",
  inputs: [{
    name: "accessController",
    internalType: "address",
    type: "address"
  }, {
    name: "ipAccountRegistry",
    internalType: "address",
    type: "address"
  }, {
    name: "moduleRegistry",
    internalType: "address",
    type: "address"
  }, {
    name: "royaltyModule",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseRegistry",
    internalType: "address",
    type: "address"
  }, {
    name: "disputeModule",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseToken",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "nonpayable"
}, {
  type: "error",
  inputs: [{
    name: "ipAccount",
    internalType: "address",
    type: "address"
  }],
  name: "AccessControlled__NotIpAccount"
}, {
  type: "error",
  inputs: [],
  name: "AccessControlled__ZeroAddress"
}, {
  type: "error",
  inputs: [{
    name: "authority",
    internalType: "address",
    type: "address"
  }],
  name: "AccessManagedInvalidAuthority"
}, {
  type: "error",
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address"
  }, {
    name: "delay",
    internalType: "uint32",
    type: "uint32"
  }],
  name: "AccessManagedRequiredDelay"
}, {
  type: "error",
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address"
  }],
  name: "AccessManagedUnauthorized"
}, {
  type: "error",
  inputs: [{
    name: "target",
    internalType: "address",
    type: "address"
  }],
  name: "AddressEmptyCode"
}, {
  type: "error",
  inputs: [{
    name: "implementation",
    internalType: "address",
    type: "address"
  }],
  name: "ERC1967InvalidImplementation"
}, {
  type: "error",
  inputs: [],
  name: "ERC1967NonPayable"
}, {
  type: "error",
  inputs: [],
  name: "EnforcedPause"
}, {
  type: "error",
  inputs: [],
  name: "ExpectedPause"
}, {
  type: "error",
  inputs: [],
  name: "FailedInnerCall"
}, {
  type: "error",
  inputs: [],
  name: "InvalidInitialization"
}, {
  type: "error",
  inputs: [],
  name: "LicensingModule__DisputedIpId"
}, {
  type: "error",
  inputs: [{
    name: "royaltyPolicy",
    internalType: "address",
    type: "address"
  }, {
    name: "anotherRoyaltyPolicy",
    internalType: "address",
    type: "address"
  }],
  name: "LicensingModule__IncompatibleRoyaltyPolicy"
}, {
  type: "error",
  inputs: [{
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "LicensingModule__InvalidLicenseTermsId"
}, {
  type: "error",
  inputs: [{
    name: "hook",
    internalType: "address",
    type: "address"
  }],
  name: "LicensingModule__InvalidLicensingHook"
}, {
  type: "error",
  inputs: [{
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "licensorIpId",
    internalType: "address",
    type: "address"
  }],
  name: "LicensingModule__LicenseDenyMintLicenseToken"
}, {
  type: "error",
  inputs: [{
    name: "childIpId",
    internalType: "address",
    type: "address"
  }],
  name: "LicensingModule__LicenseNotCompatibleForDerivative"
}, {
  type: "error",
  inputs: [{
    name: "ipLength",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "licenseTermsLength",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "LicensingModule__LicenseTermsLengthMismatch"
}, {
  type: "error",
  inputs: [{
    name: "childIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTokenIds",
    internalType: "uint256[]",
    type: "uint256[]"
  }],
  name: "LicensingModule__LicenseTokenNotCompatibleForDerivative"
}, {
  type: "error",
  inputs: [],
  name: "LicensingModule__MintAmountZero"
}, {
  type: "error",
  inputs: [],
  name: "LicensingModule__NoLicenseToken"
}, {
  type: "error",
  inputs: [],
  name: "LicensingModule__NoParentIp"
}, {
  type: "error",
  inputs: [],
  name: "LicensingModule__ReceiverZeroAddress"
}, {
  type: "error",
  inputs: [],
  name: "LicensingModule__ZeroAccessManager"
}, {
  type: "error",
  inputs: [],
  name: "LicensingModule__ZeroDisputeModule"
}, {
  type: "error",
  inputs: [],
  name: "LicensingModule__ZeroLicenseRegistry"
}, {
  type: "error",
  inputs: [],
  name: "LicensingModule__ZeroLicenseToken"
}, {
  type: "error",
  inputs: [],
  name: "LicensingModule__ZeroModuleRegistry"
}, {
  type: "error",
  inputs: [],
  name: "LicensingModule__ZeroRoyaltyModule"
}, {
  type: "error",
  inputs: [],
  name: "NotInitializing"
}, {
  type: "error",
  inputs: [],
  name: "ReentrancyGuardReentrantCall"
}, {
  type: "error",
  inputs: [],
  name: "UUPSUnauthorizedCallContext"
}, {
  type: "error",
  inputs: [{
    name: "slot",
    internalType: "bytes32",
    type: "bytes32"
  }],
  name: "UUPSUnsupportedProxiableUUID"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "authority",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "AuthorityUpdated"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "childIpId",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "licenseTokenIds",
    internalType: "uint256[]",
    type: "uint256[]",
    indexed: false
  }, {
    name: "parentIpIds",
    internalType: "address[]",
    type: "address[]",
    indexed: false
  }, {
    name: "licenseTermsIds",
    internalType: "uint256[]",
    type: "uint256[]",
    indexed: false
  }, {
    name: "licenseTemplate",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "DerivativeRegistered"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "version",
    internalType: "uint64",
    type: "uint64",
    indexed: false
  }],
  name: "Initialized"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "ipId",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "licenseTemplate",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }],
  name: "LicenseTermsAttached"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "licensorIpId",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "licenseTemplate",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256",
    indexed: true
  }, {
    name: "amount",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }, {
    name: "receiver",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "startLicenseTokenId",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }],
  name: "LicenseTokensMinted"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "account",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "Paused"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "account",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "Unpaused"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "implementation",
    internalType: "address",
    type: "address",
    indexed: true
  }],
  name: "Upgraded"
}, {
  type: "function",
  inputs: [],
  name: "ACCESS_CONTROLLER",
  outputs: [{
    name: "",
    internalType: "contract IAccessController",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "DISPUTE_MODULE",
  outputs: [{
    name: "",
    internalType: "contract IDisputeModule",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "IP_ACCOUNT_REGISTRY",
  outputs: [{
    name: "",
    internalType: "contract IIPAccountRegistry",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "LICENSE_NFT",
  outputs: [{
    name: "",
    internalType: "contract ILicenseToken",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "LICENSE_REGISTRY",
  outputs: [{
    name: "",
    internalType: "contract ILicenseRegistry",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "MODULE_REGISTRY",
  outputs: [{
    name: "",
    internalType: "contract IModuleRegistry",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "ROYALTY_MODULE",
  outputs: [{
    name: "",
    internalType: "contract RoyaltyModule",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "UPGRADE_INTERFACE_VERSION",
  outputs: [{
    name: "",
    internalType: "string",
    type: "string"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "accessManager",
    internalType: "address",
    type: "address"
  }],
  name: "__ProtocolPausable_init",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "attachLicenseTerms",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "authority",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "accessManager",
    internalType: "address",
    type: "address"
  }],
  name: "initialize",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "isConsumingScheduledOp",
  outputs: [{
    name: "",
    internalType: "bytes4",
    type: "bytes4"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "licensorIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "amount",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "receiver",
    internalType: "address",
    type: "address"
  }, {
    name: "royaltyContext",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "mintLicenseTokens",
  outputs: [{
    name: "startLicenseTokenId",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "name",
  outputs: [{
    name: "",
    internalType: "string",
    type: "string"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "pause",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "paused",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "proxiableUUID",
  outputs: [{
    name: "",
    internalType: "bytes32",
    type: "bytes32"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "childIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "parentIpIds",
    internalType: "address[]",
    type: "address[]"
  }, {
    name: "licenseTermsIds",
    internalType: "uint256[]",
    type: "uint256[]"
  }, {
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "royaltyContext",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "registerDerivative",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "childIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTokenIds",
    internalType: "uint256[]",
    type: "uint256[]"
  }, {
    name: "royaltyContext",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "registerDerivativeWithLicenseTokens",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "newAuthority",
    internalType: "address",
    type: "address"
  }],
  name: "setAuthority",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "licensingConfig",
    internalType: "struct Licensing.LicensingConfig",
    type: "tuple",
    components: [{
      name: "isSet",
      internalType: "bool",
      type: "bool"
    }, {
      name: "mintingFee",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "licensingHook",
      internalType: "address",
      type: "address"
    }, {
      name: "hookData",
      internalType: "bytes",
      type: "bytes"
    }]
  }],
  name: "setLicensingConfig",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "interfaceId",
    internalType: "bytes4",
    type: "bytes4"
  }],
  name: "supportsInterface",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "unpause",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "newImplementation",
    internalType: "address",
    type: "address"
  }, {
    name: "data",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "upgradeToAndCall",
  outputs: [],
  stateMutability: "payable"
}];

/**
 * [__View Contract on Sepolia Etherscan__](https://sepolia.etherscan.io/address/0xe89b0EaA8a0949738efA80bB531a165FB3456CBe)
 */
var licensingModuleAddress = {
  11155111: "0xe89b0EaA8a0949738efA80bB531a165FB3456CBe"
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// PILicenseTemplate
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/**
 * [__View Contract on Sepolia Etherscan__](https://sepolia.etherscan.io/address/0x260B6CB6284c89dbE660c0004233f7bB99B5edE7)
 */
var piLicenseTemplateAbi = [{
  type: "constructor",
  inputs: [{
    name: "accessController",
    internalType: "address",
    type: "address"
  }, {
    name: "ipAccountRegistry",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseRegistry",
    internalType: "address",
    type: "address"
  }, {
    name: "royaltyModule",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "nonpayable"
}, {
  type: "error",
  inputs: [{
    name: "ipAccount",
    internalType: "address",
    type: "address"
  }],
  name: "AccessControlled__NotIpAccount"
}, {
  type: "error",
  inputs: [],
  name: "AccessControlled__ZeroAddress"
}, {
  type: "error",
  inputs: [{
    name: "authority",
    internalType: "address",
    type: "address"
  }],
  name: "AccessManagedInvalidAuthority"
}, {
  type: "error",
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address"
  }, {
    name: "delay",
    internalType: "uint32",
    type: "uint32"
  }],
  name: "AccessManagedRequiredDelay"
}, {
  type: "error",
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address"
  }],
  name: "AccessManagedUnauthorized"
}, {
  type: "error",
  inputs: [{
    name: "target",
    internalType: "address",
    type: "address"
  }],
  name: "AddressEmptyCode"
}, {
  type: "error",
  inputs: [{
    name: "implementation",
    internalType: "address",
    type: "address"
  }],
  name: "ERC1967InvalidImplementation"
}, {
  type: "error",
  inputs: [],
  name: "ERC1967NonPayable"
}, {
  type: "error",
  inputs: [],
  name: "FailedInnerCall"
}, {
  type: "error",
  inputs: [],
  name: "InvalidInitialization"
}, {
  type: "error",
  inputs: [],
  name: "NotInitializing"
}, {
  type: "error",
  inputs: [],
  name: "PILicenseTemplate__CommercialDisabled_CantAddAttribution"
}, {
  type: "error",
  inputs: [],
  name: "PILicenseTemplate__CommercialDisabled_CantAddCommercializers"
}, {
  type: "error",
  inputs: [],
  name: "PILicenseTemplate__CommercialDisabled_CantAddRevShare"
}, {
  type: "error",
  inputs: [],
  name: "PILicenseTemplate__CommercialDisabled_CantAddRoyaltyPolicy"
}, {
  type: "error",
  inputs: [],
  name: "PILicenseTemplate__CommercialEnabled_RoyaltyPolicyRequired"
}, {
  type: "error",
  inputs: [{
    name: "checker",
    internalType: "address",
    type: "address"
  }],
  name: "PILicenseTemplate__CommercializerCheckerDoesNotSupportHook"
}, {
  type: "error",
  inputs: [],
  name: "PILicenseTemplate__CurrencyTokenNotWhitelisted"
}, {
  type: "error",
  inputs: [],
  name: "PILicenseTemplate__DerivativesDisabled_CantAddApproval"
}, {
  type: "error",
  inputs: [],
  name: "PILicenseTemplate__DerivativesDisabled_CantAddAttribution"
}, {
  type: "error",
  inputs: [],
  name: "PILicenseTemplate__DerivativesDisabled_CantAddReciprocal"
}, {
  type: "error",
  inputs: [],
  name: "PILicenseTemplate__RoyaltyPolicyNotWhitelisted"
}, {
  type: "error",
  inputs: [],
  name: "PILicenseTemplate__RoyaltyPolicyRequiresCurrencyToken"
}, {
  type: "error",
  inputs: [],
  name: "PILicenseTemplate__ZeroAccessManager"
}, {
  type: "error",
  inputs: [],
  name: "PILicenseTemplate__ZeroLicenseRegistry"
}, {
  type: "error",
  inputs: [],
  name: "PILicenseTemplate__ZeroRoyaltyModule"
}, {
  type: "error",
  inputs: [],
  name: "ReentrancyGuardReentrantCall"
}, {
  type: "error",
  inputs: [{
    name: "value",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "length",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "StringsInsufficientHexLength"
}, {
  type: "error",
  inputs: [],
  name: "UUPSUnauthorizedCallContext"
}, {
  type: "error",
  inputs: [{
    name: "slot",
    internalType: "bytes32",
    type: "bytes32"
  }],
  name: "UUPSUnsupportedProxiableUUID"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "authority",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "AuthorityUpdated"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256",
    indexed: true
  }, {
    name: "ipId",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "caller",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "approved",
    internalType: "bool",
    type: "bool",
    indexed: false
  }],
  name: "DerivativeApproved"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "version",
    internalType: "uint64",
    type: "uint64",
    indexed: false
  }],
  name: "Initialized"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256",
    indexed: true
  }, {
    name: "licenseTemplate",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "licenseTerms",
    internalType: "bytes",
    type: "bytes",
    indexed: false
  }],
  name: "LicenseTermsRegistered"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "implementation",
    internalType: "address",
    type: "address",
    indexed: true
  }],
  name: "Upgraded"
}, {
  type: "function",
  inputs: [],
  name: "ACCESS_CONTROLLER",
  outputs: [{
    name: "",
    internalType: "contract IAccessController",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "IP_ACCOUNT_REGISTRY",
  outputs: [{
    name: "",
    internalType: "contract IIPAccountRegistry",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "LICENSE_REGISTRY",
  outputs: [{
    name: "",
    internalType: "contract ILicenseRegistry",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "ROYALTY_MODULE",
  outputs: [{
    name: "",
    internalType: "contract IRoyaltyModule",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "UPGRADE_INTERFACE_VERSION",
  outputs: [{
    name: "",
    internalType: "string",
    type: "string"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "authority",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "exists",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "licenseTermsIds",
    internalType: "uint256[]",
    type: "uint256[]"
  }, {
    name: "start",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "getEarlierExpireTime",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "start",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "getExpireTime",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "selectedLicenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "getLicenseTerms",
  outputs: [{
    name: "terms",
    internalType: "struct PILTerms",
    type: "tuple",
    components: [{
      name: "transferable",
      internalType: "bool",
      type: "bool"
    }, {
      name: "royaltyPolicy",
      internalType: "address",
      type: "address"
    }, {
      name: "mintingFee",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "expiration",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "commercialUse",
      internalType: "bool",
      type: "bool"
    }, {
      name: "commercialAttribution",
      internalType: "bool",
      type: "bool"
    }, {
      name: "commercializerChecker",
      internalType: "address",
      type: "address"
    }, {
      name: "commercializerCheckerData",
      internalType: "bytes",
      type: "bytes"
    }, {
      name: "commercialRevShare",
      internalType: "uint32",
      type: "uint32"
    }, {
      name: "commercialRevCelling",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "derivativesAllowed",
      internalType: "bool",
      type: "bool"
    }, {
      name: "derivativesAttribution",
      internalType: "bool",
      type: "bool"
    }, {
      name: "derivativesApproval",
      internalType: "bool",
      type: "bool"
    }, {
      name: "derivativesReciprocal",
      internalType: "bool",
      type: "bool"
    }, {
      name: "derivativeRevCelling",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "currency",
      internalType: "address",
      type: "address"
    }, {
      name: "uri",
      internalType: "string",
      type: "string"
    }]
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "terms",
    internalType: "struct PILTerms",
    type: "tuple",
    components: [{
      name: "transferable",
      internalType: "bool",
      type: "bool"
    }, {
      name: "royaltyPolicy",
      internalType: "address",
      type: "address"
    }, {
      name: "mintingFee",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "expiration",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "commercialUse",
      internalType: "bool",
      type: "bool"
    }, {
      name: "commercialAttribution",
      internalType: "bool",
      type: "bool"
    }, {
      name: "commercializerChecker",
      internalType: "address",
      type: "address"
    }, {
      name: "commercializerCheckerData",
      internalType: "bytes",
      type: "bytes"
    }, {
      name: "commercialRevShare",
      internalType: "uint32",
      type: "uint32"
    }, {
      name: "commercialRevCelling",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "derivativesAllowed",
      internalType: "bool",
      type: "bool"
    }, {
      name: "derivativesAttribution",
      internalType: "bool",
      type: "bool"
    }, {
      name: "derivativesApproval",
      internalType: "bool",
      type: "bool"
    }, {
      name: "derivativesReciprocal",
      internalType: "bool",
      type: "bool"
    }, {
      name: "derivativeRevCelling",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "currency",
      internalType: "address",
      type: "address"
    }, {
      name: "uri",
      internalType: "string",
      type: "string"
    }]
  }],
  name: "getLicenseTermsId",
  outputs: [{
    name: "selectedLicenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "getLicenseTermsURI",
  outputs: [{
    name: "",
    internalType: "string",
    type: "string"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "getMetadataURI",
  outputs: [{
    name: "",
    internalType: "string",
    type: "string"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "getRoyaltyPolicy",
  outputs: [{
    name: "royaltyPolicy",
    internalType: "address",
    type: "address"
  }, {
    name: "royaltyData",
    internalType: "bytes",
    type: "bytes"
  }, {
    name: "mintingFee",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "currency",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "accessManager",
    internalType: "address",
    type: "address"
  }, {
    name: "name",
    internalType: "string",
    type: "string"
  }, {
    name: "metadataURI",
    internalType: "string",
    type: "string"
  }],
  name: "initialize",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "isConsumingScheduledOp",
  outputs: [{
    name: "",
    internalType: "bytes4",
    type: "bytes4"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "parentIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "childIpId",
    internalType: "address",
    type: "address"
  }],
  name: "isDerivativeApproved",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "isLicenseTransferable",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "name",
  outputs: [{
    name: "",
    internalType: "string",
    type: "string"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "proxiableUUID",
  outputs: [{
    name: "",
    internalType: "bytes32",
    type: "bytes32"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "terms",
    internalType: "struct PILTerms",
    type: "tuple",
    components: [{
      name: "transferable",
      internalType: "bool",
      type: "bool"
    }, {
      name: "royaltyPolicy",
      internalType: "address",
      type: "address"
    }, {
      name: "mintingFee",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "expiration",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "commercialUse",
      internalType: "bool",
      type: "bool"
    }, {
      name: "commercialAttribution",
      internalType: "bool",
      type: "bool"
    }, {
      name: "commercializerChecker",
      internalType: "address",
      type: "address"
    }, {
      name: "commercializerCheckerData",
      internalType: "bytes",
      type: "bytes"
    }, {
      name: "commercialRevShare",
      internalType: "uint32",
      type: "uint32"
    }, {
      name: "commercialRevCelling",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "derivativesAllowed",
      internalType: "bool",
      type: "bool"
    }, {
      name: "derivativesAttribution",
      internalType: "bool",
      type: "bool"
    }, {
      name: "derivativesApproval",
      internalType: "bool",
      type: "bool"
    }, {
      name: "derivativesReciprocal",
      internalType: "bool",
      type: "bool"
    }, {
      name: "derivativeRevCelling",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "currency",
      internalType: "address",
      type: "address"
    }, {
      name: "uri",
      internalType: "string",
      type: "string"
    }]
  }],
  name: "registerLicenseTerms",
  outputs: [{
    name: "id",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "parentIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "childIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "approved",
    internalType: "bool",
    type: "bool"
  }],
  name: "setApproval",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "newAuthority",
    internalType: "address",
    type: "address"
  }],
  name: "setAuthority",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "interfaceId",
    internalType: "bytes4",
    type: "bytes4"
  }],
  name: "supportsInterface",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "toJson",
  outputs: [{
    name: "",
    internalType: "string",
    type: "string"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "totalRegisteredLicenseTerms",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "newImplementation",
    internalType: "address",
    type: "address"
  }, {
    name: "data",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "upgradeToAndCall",
  outputs: [],
  stateMutability: "payable"
}, {
  type: "function",
  inputs: [{
    name: "licenseTermsIds",
    internalType: "uint256[]",
    type: "uint256[]"
  }],
  name: "verifyCompatibleLicenses",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "licensee",
    internalType: "address",
    type: "address"
  }, {
    name: "licensorIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "verifyMintLicenseToken",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "childIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "parentIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "licensee",
    internalType: "address",
    type: "address"
  }],
  name: "verifyRegisterDerivative",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "childIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "parentIpIds",
    internalType: "address[]",
    type: "address[]"
  }, {
    name: "licenseTermsIds",
    internalType: "uint256[]",
    type: "uint256[]"
  }, {
    name: "childIpOwner",
    internalType: "address",
    type: "address"
  }],
  name: "verifyRegisterDerivativeForAllParents",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "nonpayable"
}];

/**
 * [__View Contract on Sepolia Etherscan__](https://sepolia.etherscan.io/address/0x260B6CB6284c89dbE660c0004233f7bB99B5edE7)
 */
var piLicenseTemplateAddress = {
  11155111: "0x260B6CB6284c89dbE660c0004233f7bB99B5edE7"
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// RoyaltyModule
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/**
 * [__View Contract on Sepolia Etherscan__](https://sepolia.etherscan.io/address/0xFAE961dd2b87CD5818dbCDc2591e6AB0b50E96b0)
 */
var royaltyModuleAbi = [{
  type: "constructor",
  inputs: [{
    name: "licensingModule",
    internalType: "address",
    type: "address"
  }, {
    name: "disputeModule",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseRegistry",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "nonpayable"
}, {
  type: "error",
  inputs: [{
    name: "authority",
    internalType: "address",
    type: "address"
  }],
  name: "AccessManagedInvalidAuthority"
}, {
  type: "error",
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address"
  }, {
    name: "delay",
    internalType: "uint32",
    type: "uint32"
  }],
  name: "AccessManagedRequiredDelay"
}, {
  type: "error",
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address"
  }],
  name: "AccessManagedUnauthorized"
}, {
  type: "error",
  inputs: [{
    name: "target",
    internalType: "address",
    type: "address"
  }],
  name: "AddressEmptyCode"
}, {
  type: "error",
  inputs: [{
    name: "implementation",
    internalType: "address",
    type: "address"
  }],
  name: "ERC1967InvalidImplementation"
}, {
  type: "error",
  inputs: [],
  name: "ERC1967NonPayable"
}, {
  type: "error",
  inputs: [],
  name: "EnforcedPause"
}, {
  type: "error",
  inputs: [],
  name: "ExpectedPause"
}, {
  type: "error",
  inputs: [],
  name: "FailedInnerCall"
}, {
  type: "error",
  inputs: [],
  name: "InvalidInitialization"
}, {
  type: "error",
  inputs: [],
  name: "NotInitializing"
}, {
  type: "error",
  inputs: [],
  name: "ReentrancyGuardReentrantCall"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyModule__CanOnlyMintSelectedPolicy"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyModule__IncompatibleRoyaltyPolicy"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyModule__IpIsExpired"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyModule__IpIsTagged"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyModule__NoParentsOnLinking"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyModule__NoRoyaltyPolicySet"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyModule__NotAllowedCaller"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyModule__NotWhitelistedRoyaltyPolicy"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyModule__NotWhitelistedRoyaltyToken"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyModule__ZeroAccessManager"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyModule__ZeroDisputeModule"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyModule__ZeroLicenseRegistry"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyModule__ZeroLicensingModule"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyModule__ZeroRoyaltyPolicy"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyModule__ZeroRoyaltyToken"
}, {
  type: "error",
  inputs: [],
  name: "UUPSUnauthorizedCallContext"
}, {
  type: "error",
  inputs: [{
    name: "slot",
    internalType: "bytes32",
    type: "bytes32"
  }],
  name: "UUPSUnsupportedProxiableUUID"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "authority",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "AuthorityUpdated"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "version",
    internalType: "uint64",
    type: "uint64",
    indexed: false
  }],
  name: "Initialized"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "receiverIpId",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "payerAddress",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "token",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "amount",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }],
  name: "LicenseMintingFeePaid"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "account",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "Paused"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "receiverIpId",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "payerIpId",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "sender",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "token",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "amount",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }],
  name: "RoyaltyPaid"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "royaltyPolicy",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "allowed",
    internalType: "bool",
    type: "bool",
    indexed: false
  }],
  name: "RoyaltyPolicyWhitelistUpdated"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "token",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "allowed",
    internalType: "bool",
    type: "bool",
    indexed: false
  }],
  name: "RoyaltyTokenWhitelistUpdated"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "account",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "Unpaused"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "implementation",
    internalType: "address",
    type: "address",
    indexed: true
  }],
  name: "Upgraded"
}, {
  type: "function",
  inputs: [],
  name: "DISPUTE_MODULE",
  outputs: [{
    name: "",
    internalType: "contract IDisputeModule",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "LICENSE_REGISTRY",
  outputs: [{
    name: "",
    internalType: "contract ILicenseRegistry",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "LICENSING_MODULE",
  outputs: [{
    name: "",
    internalType: "contract ILicensingModule",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "UPGRADE_INTERFACE_VERSION",
  outputs: [{
    name: "",
    internalType: "string",
    type: "string"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "accessManager",
    internalType: "address",
    type: "address"
  }],
  name: "__ProtocolPausable_init",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "authority",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "accessManager",
    internalType: "address",
    type: "address"
  }],
  name: "initialize",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "isConsumingScheduledOp",
  outputs: [{
    name: "",
    internalType: "bytes4",
    type: "bytes4"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "royaltyPolicy",
    internalType: "address",
    type: "address"
  }],
  name: "isWhitelistedRoyaltyPolicy",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "token",
    internalType: "address",
    type: "address"
  }],
  name: "isWhitelistedRoyaltyToken",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "name",
  outputs: [{
    name: "",
    internalType: "string",
    type: "string"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "royaltyPolicy",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseData",
    internalType: "bytes",
    type: "bytes"
  }, {
    name: "externalData",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "onLicenseMinting",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "royaltyPolicy",
    internalType: "address",
    type: "address"
  }, {
    name: "parentIpIds",
    internalType: "address[]",
    type: "address[]"
  }, {
    name: "licenseData",
    internalType: "bytes[]",
    type: "bytes[]"
  }, {
    name: "externalData",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "onLinkToParents",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "pause",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "paused",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "receiverIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "payerAddress",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseRoyaltyPolicy",
    internalType: "address",
    type: "address"
  }, {
    name: "token",
    internalType: "address",
    type: "address"
  }, {
    name: "amount",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "payLicenseMintingFee",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "receiverIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "payerIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "token",
    internalType: "address",
    type: "address"
  }, {
    name: "amount",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "payRoyaltyOnBehalf",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "proxiableUUID",
  outputs: [{
    name: "",
    internalType: "bytes32",
    type: "bytes32"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }],
  name: "royaltyPolicies",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "newAuthority",
    internalType: "address",
    type: "address"
  }],
  name: "setAuthority",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "interfaceId",
    internalType: "bytes4",
    type: "bytes4"
  }],
  name: "supportsInterface",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "unpause",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "newImplementation",
    internalType: "address",
    type: "address"
  }, {
    name: "data",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "upgradeToAndCall",
  outputs: [],
  stateMutability: "payable"
}, {
  type: "function",
  inputs: [{
    name: "royaltyPolicy",
    internalType: "address",
    type: "address"
  }, {
    name: "allowed",
    internalType: "bool",
    type: "bool"
  }],
  name: "whitelistRoyaltyPolicy",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "token",
    internalType: "address",
    type: "address"
  }, {
    name: "allowed",
    internalType: "bool",
    type: "bool"
  }],
  name: "whitelistRoyaltyToken",
  outputs: [],
  stateMutability: "nonpayable"
}];

/**
 * [__View Contract on Sepolia Etherscan__](https://sepolia.etherscan.io/address/0xFAE961dd2b87CD5818dbCDc2591e6AB0b50E96b0)
 */
var royaltyModuleAddress = {
  11155111: "0xFAE961dd2b87CD5818dbCDc2591e6AB0b50E96b0"
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// RoyaltyPolicyLAP
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/**
 * [__View Contract on Sepolia Etherscan__](https://sepolia.etherscan.io/address/0xAAbaf349C7a2A84564F9CC4Ac130B3f19A718E86)
 */
var royaltyPolicyLapAbi = [{
  type: "constructor",
  inputs: [{
    name: "royaltyModule",
    internalType: "address",
    type: "address"
  }, {
    name: "licensingModule",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "nonpayable"
}, {
  type: "error",
  inputs: [{
    name: "authority",
    internalType: "address",
    type: "address"
  }],
  name: "AccessManagedInvalidAuthority"
}, {
  type: "error",
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address"
  }, {
    name: "delay",
    internalType: "uint32",
    type: "uint32"
  }],
  name: "AccessManagedRequiredDelay"
}, {
  type: "error",
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address"
  }],
  name: "AccessManagedUnauthorized"
}, {
  type: "error",
  inputs: [{
    name: "target",
    internalType: "address",
    type: "address"
  }],
  name: "AddressEmptyCode"
}, {
  type: "error",
  inputs: [{
    name: "account",
    internalType: "address",
    type: "address"
  }],
  name: "AddressInsufficientBalance"
}, {
  type: "error",
  inputs: [{
    name: "implementation",
    internalType: "address",
    type: "address"
  }],
  name: "ERC1967InvalidImplementation"
}, {
  type: "error",
  inputs: [],
  name: "ERC1967NonPayable"
}, {
  type: "error",
  inputs: [],
  name: "EnforcedPause"
}, {
  type: "error",
  inputs: [],
  name: "ExpectedPause"
}, {
  type: "error",
  inputs: [],
  name: "FailedInnerCall"
}, {
  type: "error",
  inputs: [],
  name: "InvalidInitialization"
}, {
  type: "error",
  inputs: [],
  name: "NotInitializing"
}, {
  type: "error",
  inputs: [],
  name: "ReentrancyGuardReentrantCall"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyPolicyLAP__AboveAncestorsLimit"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyPolicyLAP__AboveParentLimit"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyPolicyLAP__AboveRoyaltyStackLimit"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyPolicyLAP__InvalidParentRoyaltiesLength"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyPolicyLAP__LastPositionNotAbleToMintLicense"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyPolicyLAP__NotRoyaltyModule"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyPolicyLAP__UnlinkableToParents"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyPolicyLAP__ZeroAccessManager"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyPolicyLAP__ZeroIpRoyaltyVaultBeacon"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyPolicyLAP__ZeroLicensingModule"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyPolicyLAP__ZeroRoyaltyModule"
}, {
  type: "error",
  inputs: [{
    name: "token",
    internalType: "address",
    type: "address"
  }],
  name: "SafeERC20FailedOperation"
}, {
  type: "error",
  inputs: [],
  name: "UUPSUnauthorizedCallContext"
}, {
  type: "error",
  inputs: [{
    name: "slot",
    internalType: "bytes32",
    type: "bytes32"
  }],
  name: "UUPSUnsupportedProxiableUUID"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "authority",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "AuthorityUpdated"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "version",
    internalType: "uint64",
    type: "uint64",
    indexed: false
  }],
  name: "Initialized"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "account",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "Paused"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "ipRoyaltyVault",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "royaltyStack",
    internalType: "uint32",
    type: "uint32",
    indexed: false
  }, {
    name: "targetAncestors",
    internalType: "address[]",
    type: "address[]",
    indexed: false
  }, {
    name: "targetRoyaltyAmount",
    internalType: "uint32[]",
    type: "uint32[]",
    indexed: false
  }],
  name: "PolicyInitialized"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "token",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "vault",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "RevenueTokenAddedToVault"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "account",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "Unpaused"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "implementation",
    internalType: "address",
    type: "address",
    indexed: true
  }],
  name: "Upgraded"
}, {
  type: "function",
  inputs: [],
  name: "LICENSING_MODULE",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "MAX_ANCESTORS",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "MAX_PARENTS",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "ROYALTY_MODULE",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "TOTAL_RT_SUPPLY",
  outputs: [{
    name: "",
    internalType: "uint32",
    type: "uint32"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "UPGRADE_INTERFACE_VERSION",
  outputs: [{
    name: "",
    internalType: "string",
    type: "string"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "accessManager",
    internalType: "address",
    type: "address"
  }],
  name: "__ProtocolPausable_init",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "authority",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "getIpRoyaltyVaultBeacon",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }],
  name: "getRoyaltyData",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }, {
    name: "",
    internalType: "address",
    type: "address"
  }, {
    name: "",
    internalType: "uint32",
    type: "uint32"
  }, {
    name: "",
    internalType: "address[]",
    type: "address[]"
  }, {
    name: "",
    internalType: "uint32[]",
    type: "uint32[]"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "getSnapshotInterval",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "accessManager",
    internalType: "address",
    type: "address"
  }],
  name: "initialize",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "isConsumingScheduledOp",
  outputs: [{
    name: "",
    internalType: "bytes4",
    type: "bytes4"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseData",
    internalType: "bytes",
    type: "bytes"
  }, {
    name: "externalData",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "onLicenseMinting",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "parentIpIds",
    internalType: "address[]",
    type: "address[]"
  }, {
    name: "licenseData",
    internalType: "bytes[]",
    type: "bytes[]"
  }, {
    name: "externalData",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "onLinkToParents",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address"
  }, {
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "token",
    internalType: "address",
    type: "address"
  }, {
    name: "amount",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "onRoyaltyPayment",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "pause",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "paused",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "proxiableUUID",
  outputs: [{
    name: "",
    internalType: "bytes32",
    type: "bytes32"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "newAuthority",
    internalType: "address",
    type: "address"
  }],
  name: "setAuthority",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "beacon",
    internalType: "address",
    type: "address"
  }],
  name: "setIpRoyaltyVaultBeacon",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "timestampInterval",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "setSnapshotInterval",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "unpause",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "newImplementation",
    internalType: "address",
    type: "address"
  }, {
    name: "data",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "upgradeToAndCall",
  outputs: [],
  stateMutability: "payable"
}, {
  type: "function",
  inputs: [{
    name: "newVault",
    internalType: "address",
    type: "address"
  }],
  name: "upgradeVaults",
  outputs: [],
  stateMutability: "nonpayable"
}];

/**
 * [__View Contract on Sepolia Etherscan__](https://sepolia.etherscan.io/address/0xAAbaf349C7a2A84564F9CC4Ac130B3f19A718E86)
 */
var royaltyPolicyLapAddress = {
  11155111: "0xAAbaf349C7a2A84564F9CC4Ac130B3f19A718E86"
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SPG
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/**
 * [__View Contract on Sepolia Etherscan__](https://sepolia.etherscan.io/address/0x69415CE984A79a3Cfbe3F51024C63b6C107331e3)
 */
var spgAbi = [{
  type: "constructor",
  inputs: [{
    name: "accessController",
    internalType: "address",
    type: "address"
  }, {
    name: "ipAssetRegistry",
    internalType: "address",
    type: "address"
  }, {
    name: "licensingModule",
    internalType: "address",
    type: "address"
  }, {
    name: "coreMetadataModule",
    internalType: "address",
    type: "address"
  }, {
    name: "pilTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseToken",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "nonpayable"
}, {
  type: "error",
  inputs: [{
    name: "authority",
    internalType: "address",
    type: "address"
  }],
  name: "AccessManagedInvalidAuthority"
}, {
  type: "error",
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address"
  }, {
    name: "delay",
    internalType: "uint32",
    type: "uint32"
  }],
  name: "AccessManagedRequiredDelay"
}, {
  type: "error",
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address"
  }],
  name: "AccessManagedUnauthorized"
}, {
  type: "error",
  inputs: [{
    name: "target",
    internalType: "address",
    type: "address"
  }],
  name: "AddressEmptyCode"
}, {
  type: "error",
  inputs: [{
    name: "implementation",
    internalType: "address",
    type: "address"
  }],
  name: "ERC1967InvalidImplementation"
}, {
  type: "error",
  inputs: [],
  name: "ERC1967NonPayable"
}, {
  type: "error",
  inputs: [],
  name: "FailedInnerCall"
}, {
  type: "error",
  inputs: [],
  name: "InvalidInitialization"
}, {
  type: "error",
  inputs: [],
  name: "NotInitializing"
}, {
  type: "error",
  inputs: [],
  name: "SPG__CallerNotMinterRole"
}, {
  type: "error",
  inputs: [],
  name: "SPG__EmptyLicenseTokens"
}, {
  type: "error",
  inputs: [],
  name: "SPG__ZeroAddressParam"
}, {
  type: "error",
  inputs: [],
  name: "UUPSUnauthorizedCallContext"
}, {
  type: "error",
  inputs: [{
    name: "slot",
    internalType: "bytes32",
    type: "bytes32"
  }],
  name: "UUPSUnsupportedProxiableUUID"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "authority",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "AuthorityUpdated"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "nftContract",
    internalType: "address",
    type: "address",
    indexed: true
  }],
  name: "CollectionCreated"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "version",
    internalType: "uint64",
    type: "uint64",
    indexed: false
  }],
  name: "Initialized"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "implementation",
    internalType: "address",
    type: "address",
    indexed: true
  }],
  name: "Upgraded"
}, {
  type: "function",
  inputs: [],
  name: "ACCESS_CONTROLLER",
  outputs: [{
    name: "",
    internalType: "contract IAccessController",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "CORE_METADATA_MODULE",
  outputs: [{
    name: "",
    internalType: "contract ICoreMetadataModule",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "IP_ASSET_REGISTRY",
  outputs: [{
    name: "",
    internalType: "contract IIPAssetRegistry",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "LICENSE_TOKEN",
  outputs: [{
    name: "",
    internalType: "contract ILicenseToken",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "LICENSING_MODULE",
  outputs: [{
    name: "",
    internalType: "contract ILicensingModule",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "PIL_TEMPLATE",
  outputs: [{
    name: "",
    internalType: "contract IPILicenseTemplate",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "UPGRADE_INTERFACE_VERSION",
  outputs: [{
    name: "",
    internalType: "string",
    type: "string"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "authority",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "name",
    internalType: "string",
    type: "string"
  }, {
    name: "symbol",
    internalType: "string",
    type: "string"
  }, {
    name: "maxSupply",
    internalType: "uint32",
    type: "uint32"
  }, {
    name: "mintCost",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "mintToken",
    internalType: "address",
    type: "address"
  }, {
    name: "owner",
    internalType: "address",
    type: "address"
  }],
  name: "createCollection",
  outputs: [{
    name: "nftContract",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "accessManager",
    internalType: "address",
    type: "address"
  }],
  name: "initialize",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "isConsumingScheduledOp",
  outputs: [{
    name: "",
    internalType: "bytes4",
    type: "bytes4"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "nftContract",
    internalType: "address",
    type: "address"
  }, {
    name: "recipient",
    internalType: "address",
    type: "address"
  }, {
    name: "metadata",
    internalType: "struct IStoryProtocolGateway.IPMetadata",
    type: "tuple",
    components: [{
      name: "metadataURI",
      internalType: "string",
      type: "string"
    }, {
      name: "metadataHash",
      internalType: "bytes32",
      type: "bytes32"
    }, {
      name: "nftMetadataHash",
      internalType: "bytes32",
      type: "bytes32"
    }]
  }],
  name: "mintAndRegisterIp",
  outputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "nftContract",
    internalType: "address",
    type: "address"
  }, {
    name: "recipient",
    internalType: "address",
    type: "address"
  }, {
    name: "metadata",
    internalType: "struct IStoryProtocolGateway.IPMetadata",
    type: "tuple",
    components: [{
      name: "metadataURI",
      internalType: "string",
      type: "string"
    }, {
      name: "metadataHash",
      internalType: "bytes32",
      type: "bytes32"
    }, {
      name: "nftMetadataHash",
      internalType: "bytes32",
      type: "bytes32"
    }]
  }, {
    name: "terms",
    internalType: "struct PILTerms",
    type: "tuple",
    components: [{
      name: "transferable",
      internalType: "bool",
      type: "bool"
    }, {
      name: "royaltyPolicy",
      internalType: "address",
      type: "address"
    }, {
      name: "mintingFee",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "expiration",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "commercialUse",
      internalType: "bool",
      type: "bool"
    }, {
      name: "commercialAttribution",
      internalType: "bool",
      type: "bool"
    }, {
      name: "commercializerChecker",
      internalType: "address",
      type: "address"
    }, {
      name: "commercializerCheckerData",
      internalType: "bytes",
      type: "bytes"
    }, {
      name: "commercialRevShare",
      internalType: "uint32",
      type: "uint32"
    }, {
      name: "commercialRevCelling",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "derivativesAllowed",
      internalType: "bool",
      type: "bool"
    }, {
      name: "derivativesAttribution",
      internalType: "bool",
      type: "bool"
    }, {
      name: "derivativesApproval",
      internalType: "bool",
      type: "bool"
    }, {
      name: "derivativesReciprocal",
      internalType: "bool",
      type: "bool"
    }, {
      name: "derivativeRevCelling",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "currency",
      internalType: "address",
      type: "address"
    }, {
      name: "uri",
      internalType: "string",
      type: "string"
    }]
  }],
  name: "mintAndRegisterIpAndAttachPILTerms",
  outputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "nftContract",
    internalType: "address",
    type: "address"
  }, {
    name: "derivData",
    internalType: "struct IStoryProtocolGateway.MakeDerivative",
    type: "tuple",
    components: [{
      name: "parentIpIds",
      internalType: "address[]",
      type: "address[]"
    }, {
      name: "licenseTemplate",
      internalType: "address",
      type: "address"
    }, {
      name: "licenseTermsIds",
      internalType: "uint256[]",
      type: "uint256[]"
    }, {
      name: "royaltyContext",
      internalType: "bytes",
      type: "bytes"
    }]
  }, {
    name: "metadata",
    internalType: "struct IStoryProtocolGateway.IPMetadata",
    type: "tuple",
    components: [{
      name: "metadataURI",
      internalType: "string",
      type: "string"
    }, {
      name: "metadataHash",
      internalType: "bytes32",
      type: "bytes32"
    }, {
      name: "nftMetadataHash",
      internalType: "bytes32",
      type: "bytes32"
    }]
  }, {
    name: "recipient",
    internalType: "address",
    type: "address"
  }],
  name: "mintAndRegisterIpAndMakeDerivative",
  outputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "nftContract",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTokenIds",
    internalType: "uint256[]",
    type: "uint256[]"
  }, {
    name: "royaltyContext",
    internalType: "bytes",
    type: "bytes"
  }, {
    name: "metadata",
    internalType: "struct IStoryProtocolGateway.IPMetadata",
    type: "tuple",
    components: [{
      name: "metadataURI",
      internalType: "string",
      type: "string"
    }, {
      name: "metadataHash",
      internalType: "bytes32",
      type: "bytes32"
    }, {
      name: "nftMetadataHash",
      internalType: "bytes32",
      type: "bytes32"
    }]
  }, {
    name: "recipient",
    internalType: "address",
    type: "address"
  }],
  name: "mintAndRegisterIpAndMakeDerivativeWithLicenseTokens",
  outputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "proxiableUUID",
  outputs: [{
    name: "",
    internalType: "bytes32",
    type: "bytes32"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "nftContract",
    internalType: "address",
    type: "address"
  }, {
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "metadata",
    internalType: "struct IStoryProtocolGateway.IPMetadata",
    type: "tuple",
    components: [{
      name: "metadataURI",
      internalType: "string",
      type: "string"
    }, {
      name: "metadataHash",
      internalType: "bytes32",
      type: "bytes32"
    }, {
      name: "nftMetadataHash",
      internalType: "bytes32",
      type: "bytes32"
    }]
  }, {
    name: "terms",
    internalType: "struct PILTerms",
    type: "tuple",
    components: [{
      name: "transferable",
      internalType: "bool",
      type: "bool"
    }, {
      name: "royaltyPolicy",
      internalType: "address",
      type: "address"
    }, {
      name: "mintingFee",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "expiration",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "commercialUse",
      internalType: "bool",
      type: "bool"
    }, {
      name: "commercialAttribution",
      internalType: "bool",
      type: "bool"
    }, {
      name: "commercializerChecker",
      internalType: "address",
      type: "address"
    }, {
      name: "commercializerCheckerData",
      internalType: "bytes",
      type: "bytes"
    }, {
      name: "commercialRevShare",
      internalType: "uint32",
      type: "uint32"
    }, {
      name: "commercialRevCelling",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "derivativesAllowed",
      internalType: "bool",
      type: "bool"
    }, {
      name: "derivativesAttribution",
      internalType: "bool",
      type: "bool"
    }, {
      name: "derivativesApproval",
      internalType: "bool",
      type: "bool"
    }, {
      name: "derivativesReciprocal",
      internalType: "bool",
      type: "bool"
    }, {
      name: "derivativeRevCelling",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "currency",
      internalType: "address",
      type: "address"
    }, {
      name: "uri",
      internalType: "string",
      type: "string"
    }]
  }, {
    name: "sigMetadata",
    internalType: "struct IStoryProtocolGateway.SignatureData",
    type: "tuple",
    components: [{
      name: "signer",
      internalType: "address",
      type: "address"
    }, {
      name: "deadline",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "signature",
      internalType: "bytes",
      type: "bytes"
    }]
  }, {
    name: "sigAttach",
    internalType: "struct IStoryProtocolGateway.SignatureData",
    type: "tuple",
    components: [{
      name: "signer",
      internalType: "address",
      type: "address"
    }, {
      name: "deadline",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "signature",
      internalType: "bytes",
      type: "bytes"
    }]
  }],
  name: "registerIpAndAttachPILTerms",
  outputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "nftContract",
    internalType: "address",
    type: "address"
  }, {
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "derivData",
    internalType: "struct IStoryProtocolGateway.MakeDerivative",
    type: "tuple",
    components: [{
      name: "parentIpIds",
      internalType: "address[]",
      type: "address[]"
    }, {
      name: "licenseTemplate",
      internalType: "address",
      type: "address"
    }, {
      name: "licenseTermsIds",
      internalType: "uint256[]",
      type: "uint256[]"
    }, {
      name: "royaltyContext",
      internalType: "bytes",
      type: "bytes"
    }]
  }, {
    name: "metadata",
    internalType: "struct IStoryProtocolGateway.IPMetadata",
    type: "tuple",
    components: [{
      name: "metadataURI",
      internalType: "string",
      type: "string"
    }, {
      name: "metadataHash",
      internalType: "bytes32",
      type: "bytes32"
    }, {
      name: "nftMetadataHash",
      internalType: "bytes32",
      type: "bytes32"
    }]
  }, {
    name: "sigMetadata",
    internalType: "struct IStoryProtocolGateway.SignatureData",
    type: "tuple",
    components: [{
      name: "signer",
      internalType: "address",
      type: "address"
    }, {
      name: "deadline",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "signature",
      internalType: "bytes",
      type: "bytes"
    }]
  }, {
    name: "sigRegister",
    internalType: "struct IStoryProtocolGateway.SignatureData",
    type: "tuple",
    components: [{
      name: "signer",
      internalType: "address",
      type: "address"
    }, {
      name: "deadline",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "signature",
      internalType: "bytes",
      type: "bytes"
    }]
  }],
  name: "registerIpAndMakeDerivative",
  outputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "nftContract",
    internalType: "address",
    type: "address"
  }, {
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "licenseTokenIds",
    internalType: "uint256[]",
    type: "uint256[]"
  }, {
    name: "royaltyContext",
    internalType: "bytes",
    type: "bytes"
  }, {
    name: "metadata",
    internalType: "struct IStoryProtocolGateway.IPMetadata",
    type: "tuple",
    components: [{
      name: "metadataURI",
      internalType: "string",
      type: "string"
    }, {
      name: "metadataHash",
      internalType: "bytes32",
      type: "bytes32"
    }, {
      name: "nftMetadataHash",
      internalType: "bytes32",
      type: "bytes32"
    }]
  }, {
    name: "sigMetadata",
    internalType: "struct IStoryProtocolGateway.SignatureData",
    type: "tuple",
    components: [{
      name: "signer",
      internalType: "address",
      type: "address"
    }, {
      name: "deadline",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "signature",
      internalType: "bytes",
      type: "bytes"
    }]
  }, {
    name: "sigRegister",
    internalType: "struct IStoryProtocolGateway.SignatureData",
    type: "tuple",
    components: [{
      name: "signer",
      internalType: "address",
      type: "address"
    }, {
      name: "deadline",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "signature",
      internalType: "bytes",
      type: "bytes"
    }]
  }],
  name: "registerIpAndMakeDerivativeWithLicenseTokens",
  outputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "terms",
    internalType: "struct PILTerms",
    type: "tuple",
    components: [{
      name: "transferable",
      internalType: "bool",
      type: "bool"
    }, {
      name: "royaltyPolicy",
      internalType: "address",
      type: "address"
    }, {
      name: "mintingFee",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "expiration",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "commercialUse",
      internalType: "bool",
      type: "bool"
    }, {
      name: "commercialAttribution",
      internalType: "bool",
      type: "bool"
    }, {
      name: "commercializerChecker",
      internalType: "address",
      type: "address"
    }, {
      name: "commercializerCheckerData",
      internalType: "bytes",
      type: "bytes"
    }, {
      name: "commercialRevShare",
      internalType: "uint32",
      type: "uint32"
    }, {
      name: "commercialRevCelling",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "derivativesAllowed",
      internalType: "bool",
      type: "bool"
    }, {
      name: "derivativesAttribution",
      internalType: "bool",
      type: "bool"
    }, {
      name: "derivativesApproval",
      internalType: "bool",
      type: "bool"
    }, {
      name: "derivativesReciprocal",
      internalType: "bool",
      type: "bool"
    }, {
      name: "derivativeRevCelling",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "currency",
      internalType: "address",
      type: "address"
    }, {
      name: "uri",
      internalType: "string",
      type: "string"
    }]
  }],
  name: "registerPILTermsAndAttach",
  outputs: [{
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "newAuthority",
    internalType: "address",
    type: "address"
  }],
  name: "setAuthority",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "newNftContractBeacon",
    internalType: "address",
    type: "address"
  }],
  name: "setNftContractBeacon",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "newNftContract",
    internalType: "address",
    type: "address"
  }],
  name: "upgradeCollections",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "newImplementation",
    internalType: "address",
    type: "address"
  }, {
    name: "data",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "upgradeToAndCall",
  outputs: [],
  stateMutability: "payable"
}];

/**
 * [__View Contract on Sepolia Etherscan__](https://sepolia.etherscan.io/address/0x69415CE984A79a3Cfbe3F51024C63b6C107331e3)
 */
var spgAddress = {
  11155111: "0x69415CE984A79a3Cfbe3F51024C63b6C107331e3"
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SDK
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// COMMON =============================================================

function getAddress(address, chainId) {
  return address[chainId || 0] || "0x";
}

// Contract AccessController =============================================================

/**
 * AccessControllerPermissionSetEvent
 *
 * @param ipAccountOwner address
 * @param ipAccount address
 * @param signer address
 * @param to address
 * @param func bytes4
 * @param permission uint8
 */

/**
 * AccessControllerSetPermissionRequest
 *
 * @param ipAccount address
 * @param signer address
 * @param to address
 * @param func bytes4
 * @param permission uint8
 */

/**
 * contract AccessController event
 */
var AccessControllerEventClient = /*#__PURE__*/function () {
  function AccessControllerEventClient(rpcClient, address) {
    var _rpcClient$chain;
    _classCallCheck(this, AccessControllerEventClient);
    this.address = address || getAddress(accessControllerAddress, (_rpcClient$chain = rpcClient.chain) === null || _rpcClient$chain === void 0 ? void 0 : _rpcClient$chain.id);
    this.rpcClient = rpcClient;
  }

  /**
   * event PermissionSet for contract AccessController
   */
  return _createClass(AccessControllerEventClient, [{
    key: "watchPermissionSetEvent",
    value: function watchPermissionSetEvent(_onLogs) {
      return this.rpcClient.watchContractEvent({
        abi: accessControllerAbi,
        address: this.address,
        eventName: "PermissionSet",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event PermissionSet for contract AccessController
     */
  }, {
    key: "parseTxPermissionSetEvent",
    value: function parseTxPermissionSetEvent(txReceipt) {
      var targetLogs = [];
      var _iterator = _createForOfIteratorHelper(txReceipt.logs),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var log = _step.value;
          try {
            var event = viem.decodeEventLog({
              abi: accessControllerAbi,
              eventName: "PermissionSet",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "PermissionSet") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return targetLogs;
    }
  }]);
}();

/**
 * contract AccessController write method
 */
var AccessControllerClient = /*#__PURE__*/function (_AccessControllerEven) {
  function AccessControllerClient(rpcClient, wallet, address) {
    var _this;
    _classCallCheck(this, AccessControllerClient);
    _this = _callSuper(this, AccessControllerClient, [rpcClient, address]);
    _this.wallet = wallet;
    return _this;
  }

  /**
   * method setPermission for contract AccessController
   *
   * @param request AccessControllerSetPermissionRequest
   * @return Promise<WriteContractReturnType>
   */
  _inherits(AccessControllerClient, _AccessControllerEven);
  return _createClass(AccessControllerClient, [{
    key: "setPermission",
    value: (function () {
      var _setPermission = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {
        var _yield$this$rpcClient, call;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.rpcClient.simulateContract({
                abi: accessControllerAbi,
                address: this.address,
                functionName: "setPermission",
                account: this.wallet.account,
                args: [request.ipAccount, request.signer, request.to, request.func, request.permission]
              });
            case 2:
              _yield$this$rpcClient = _context.sent;
              call = _yield$this$rpcClient.request;
              _context.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context.abrupt("return", _context.sent);
            case 7:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function setPermission(_x) {
        return _setPermission.apply(this, arguments);
      }
      return setPermission;
    }())
  }]);
}(AccessControllerEventClient);

// Contract DisputeModule =============================================================

/**
 * DisputeModuleDisputeCancelledEvent
 *
 * @param disputeId uint256
 * @param data bytes
 */

/**
 * DisputeModuleDisputeRaisedEvent
 *
 * @param disputeId uint256
 * @param targetIpId address
 * @param disputeInitiator address
 * @param arbitrationPolicy address
 * @param linkToDisputeEvidence bytes32
 * @param targetTag bytes32
 * @param data bytes
 */

/**
 * DisputeModuleDisputeResolvedEvent
 *
 * @param disputeId uint256
 */

/**
 * DisputeModuleCancelDisputeRequest
 *
 * @param disputeId uint256
 * @param data bytes
 */

/**
 * DisputeModuleRaiseDisputeRequest
 *
 * @param targetIpId address
 * @param linkToDisputeEvidence string
 * @param targetTag bytes32
 * @param data bytes
 */

/**
 * DisputeModuleResolveDisputeRequest
 *
 * @param disputeId uint256
 * @param data bytes
 */

/**
 * contract DisputeModule event
 */
var DisputeModuleEventClient = /*#__PURE__*/function () {
  function DisputeModuleEventClient(rpcClient, address) {
    var _rpcClient$chain3;
    _classCallCheck(this, DisputeModuleEventClient);
    this.address = address || getAddress(disputeModuleAddress, (_rpcClient$chain3 = rpcClient.chain) === null || _rpcClient$chain3 === void 0 ? void 0 : _rpcClient$chain3.id);
    this.rpcClient = rpcClient;
  }

  /**
   * event DisputeCancelled for contract DisputeModule
   */
  return _createClass(DisputeModuleEventClient, [{
    key: "watchDisputeCancelledEvent",
    value: function watchDisputeCancelledEvent(_onLogs2) {
      return this.rpcClient.watchContractEvent({
        abi: disputeModuleAbi,
        address: this.address,
        eventName: "DisputeCancelled",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs2(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event DisputeCancelled for contract DisputeModule
     */
  }, {
    key: "parseTxDisputeCancelledEvent",
    value: function parseTxDisputeCancelledEvent(txReceipt) {
      var targetLogs = [];
      var _iterator2 = _createForOfIteratorHelper(txReceipt.logs),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var log = _step2.value;
          try {
            var event = viem.decodeEventLog({
              abi: disputeModuleAbi,
              eventName: "DisputeCancelled",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "DisputeCancelled") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return targetLogs;
    }

    /**
     * event DisputeRaised for contract DisputeModule
     */
  }, {
    key: "watchDisputeRaisedEvent",
    value: function watchDisputeRaisedEvent(_onLogs3) {
      return this.rpcClient.watchContractEvent({
        abi: disputeModuleAbi,
        address: this.address,
        eventName: "DisputeRaised",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs3(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event DisputeRaised for contract DisputeModule
     */
  }, {
    key: "parseTxDisputeRaisedEvent",
    value: function parseTxDisputeRaisedEvent(txReceipt) {
      var targetLogs = [];
      var _iterator3 = _createForOfIteratorHelper(txReceipt.logs),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var log = _step3.value;
          try {
            var event = viem.decodeEventLog({
              abi: disputeModuleAbi,
              eventName: "DisputeRaised",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "DisputeRaised") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      return targetLogs;
    }

    /**
     * event DisputeResolved for contract DisputeModule
     */
  }, {
    key: "watchDisputeResolvedEvent",
    value: function watchDisputeResolvedEvent(_onLogs4) {
      return this.rpcClient.watchContractEvent({
        abi: disputeModuleAbi,
        address: this.address,
        eventName: "DisputeResolved",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs4(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event DisputeResolved for contract DisputeModule
     */
  }, {
    key: "parseTxDisputeResolvedEvent",
    value: function parseTxDisputeResolvedEvent(txReceipt) {
      var targetLogs = [];
      var _iterator4 = _createForOfIteratorHelper(txReceipt.logs),
        _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var log = _step4.value;
          try {
            var event = viem.decodeEventLog({
              abi: disputeModuleAbi,
              eventName: "DisputeResolved",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "DisputeResolved") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
      return targetLogs;
    }
  }]);
}();

/**
 * contract DisputeModule write method
 */
var DisputeModuleClient = /*#__PURE__*/function (_DisputeModuleEventCl) {
  function DisputeModuleClient(rpcClient, wallet, address) {
    var _this2;
    _classCallCheck(this, DisputeModuleClient);
    _this2 = _callSuper(this, DisputeModuleClient, [rpcClient, address]);
    _this2.wallet = wallet;
    return _this2;
  }

  /**
   * method cancelDispute for contract DisputeModule
   *
   * @param request DisputeModuleCancelDisputeRequest
   * @return Promise<WriteContractReturnType>
   */
  _inherits(DisputeModuleClient, _DisputeModuleEventCl);
  return _createClass(DisputeModuleClient, [{
    key: "cancelDispute",
    value: (function () {
      var _cancelDispute = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(request) {
        var _yield$this$rpcClient3, call;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return this.rpcClient.simulateContract({
                abi: disputeModuleAbi,
                address: this.address,
                functionName: "cancelDispute",
                account: this.wallet.account,
                args: [request.disputeId, request.data]
              });
            case 2:
              _yield$this$rpcClient3 = _context3.sent;
              call = _yield$this$rpcClient3.request;
              _context3.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context3.abrupt("return", _context3.sent);
            case 7:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function cancelDispute(_x3) {
        return _cancelDispute.apply(this, arguments);
      }
      return cancelDispute;
    }()
    /**
     * method raiseDispute for contract DisputeModule
     *
     * @param request DisputeModuleRaiseDisputeRequest
     * @return Promise<WriteContractReturnType>
     */
    )
  }, {
    key: "raiseDispute",
    value: (function () {
      var _raiseDispute = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(request) {
        var _yield$this$rpcClient4, call;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return this.rpcClient.simulateContract({
                abi: disputeModuleAbi,
                address: this.address,
                functionName: "raiseDispute",
                account: this.wallet.account,
                args: [request.targetIpId, request.linkToDisputeEvidence, request.targetTag, request.data]
              });
            case 2:
              _yield$this$rpcClient4 = _context4.sent;
              call = _yield$this$rpcClient4.request;
              _context4.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context4.abrupt("return", _context4.sent);
            case 7:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function raiseDispute(_x4) {
        return _raiseDispute.apply(this, arguments);
      }
      return raiseDispute;
    }()
    /**
     * method resolveDispute for contract DisputeModule
     *
     * @param request DisputeModuleResolveDisputeRequest
     * @return Promise<WriteContractReturnType>
     */
    )
  }, {
    key: "resolveDispute",
    value: (function () {
      var _resolveDispute = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(request) {
        var _yield$this$rpcClient5, call;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _context5.next = 2;
              return this.rpcClient.simulateContract({
                abi: disputeModuleAbi,
                address: this.address,
                functionName: "resolveDispute",
                account: this.wallet.account,
                args: [request.disputeId, request.data]
              });
            case 2:
              _yield$this$rpcClient5 = _context5.sent;
              call = _yield$this$rpcClient5.request;
              _context5.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context5.abrupt("return", _context5.sent);
            case 7:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function resolveDispute(_x5) {
        return _resolveDispute.apply(this, arguments);
      }
      return resolveDispute;
    }())
  }]);
}(DisputeModuleEventClient);

// Contract IPAccountImpl =============================================================

/**
 * IpAccountImplExecuteRequest
 *
 * @param to address
 * @param value uint256
 * @param data bytes
 */

/**
 * IpAccountImplExecuteWithSigRequest
 *
 * @param to address
 * @param value uint256
 * @param data bytes
 * @param signer address
 * @param deadline uint256
 * @param signature bytes
 */

/**
 * contract IPAccountImpl readonly method
 */
var IpAccountImplReadOnlyClient = /*#__PURE__*/function () {
  function IpAccountImplReadOnlyClient(rpcClient, address) {
    var _rpcClient$chain4;
    _classCallCheck(this, IpAccountImplReadOnlyClient);
    this.address = address || getAddress(ipAccountImplAddress, (_rpcClient$chain4 = rpcClient.chain) === null || _rpcClient$chain4 === void 0 ? void 0 : _rpcClient$chain4.id);
    this.rpcClient = rpcClient;
  }

  /**
   * method state for contract IPAccountImpl
   *
   * @param request IpAccountImplStateRequest
   * @return Promise<IpAccountImplStateResponse>
   */
  return _createClass(IpAccountImplReadOnlyClient, [{
    key: "state",
    value: (function () {
      var _state = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              _context6.next = 2;
              return this.rpcClient.readContract({
                abi: ipAccountImplAbi,
                address: this.address,
                functionName: "state"
              });
            case 2:
              return _context6.abrupt("return", _context6.sent);
            case 3:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function state() {
        return _state.apply(this, arguments);
      }
      return state;
    }())
  }]);
}();

/**
 * contract IPAccountImpl write method
 */
var IpAccountImplClient = /*#__PURE__*/function (_IpAccountImplReadOnl) {
  function IpAccountImplClient(rpcClient, wallet, address) {
    var _this3;
    _classCallCheck(this, IpAccountImplClient);
    _this3 = _callSuper(this, IpAccountImplClient, [rpcClient, address]);
    _this3.wallet = wallet;
    return _this3;
  }

  /**
   * method execute for contract IPAccountImpl
   *
   * @param request IpAccountImplExecuteRequest
   * @return Promise<WriteContractReturnType>
   */
  _inherits(IpAccountImplClient, _IpAccountImplReadOnl);
  return _createClass(IpAccountImplClient, [{
    key: "execute",
    value: (function () {
      var _execute = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(request) {
        var _yield$this$rpcClient6, call;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              _context7.next = 2;
              return this.rpcClient.simulateContract({
                abi: ipAccountImplAbi,
                address: this.address,
                functionName: "execute",
                account: this.wallet.account,
                args: [request.to, request.value, request.data]
              });
            case 2:
              _yield$this$rpcClient6 = _context7.sent;
              call = _yield$this$rpcClient6.request;
              _context7.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context7.abrupt("return", _context7.sent);
            case 7:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));
      function execute(_x6) {
        return _execute.apply(this, arguments);
      }
      return execute;
    }()
    /**
     * method executeWithSig for contract IPAccountImpl
     *
     * @param request IpAccountImplExecuteWithSigRequest
     * @return Promise<WriteContractReturnType>
     */
    )
  }, {
    key: "executeWithSig",
    value: (function () {
      var _executeWithSig = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(request) {
        var _yield$this$rpcClient7, call;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              _context8.next = 2;
              return this.rpcClient.simulateContract({
                abi: ipAccountImplAbi,
                address: this.address,
                functionName: "executeWithSig",
                account: this.wallet.account,
                args: [request.to, request.value, request.data, request.signer, request.deadline, request.signature]
              });
            case 2:
              _yield$this$rpcClient7 = _context8.sent;
              call = _yield$this$rpcClient7.request;
              _context8.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context8.abrupt("return", _context8.sent);
            case 7:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this);
      }));
      function executeWithSig(_x7) {
        return _executeWithSig.apply(this, arguments);
      }
      return executeWithSig;
    }())
  }]);
}(IpAccountImplReadOnlyClient);

// Contract IPAssetRegistry =============================================================

/**
 * IpAssetRegistryIpAccountRegisteredEvent
 *
 * @param account address
 * @param implementation address
 * @param chainId uint256
 * @param tokenContract address
 * @param tokenId uint256
 */

/**
 * IpAssetRegistryIpRegisteredEvent
 *
 * @param ipId address
 * @param chainId uint256
 * @param tokenContract address
 * @param tokenId uint256
 * @param name string
 * @param uri string
 * @param registrationDate uint256
 */

/**
 * IpAssetRegistryIpIdRequest
 *
 * @param chainId uint256
 * @param tokenContract address
 * @param tokenId uint256
 */

/**
 * IpAssetRegistryIsRegisteredRequest
 *
 * @param id address
 */

/**
 * IpAssetRegistryRegisterRequest
 *
 * @param chainid uint256
 * @param tokenContract address
 * @param tokenId uint256
 */

/**
 * contract IPAssetRegistry event
 */
var IpAssetRegistryEventClient = /*#__PURE__*/function () {
  function IpAssetRegistryEventClient(rpcClient, address) {
    var _rpcClient$chain5;
    _classCallCheck(this, IpAssetRegistryEventClient);
    this.address = address || getAddress(ipAssetRegistryAddress, (_rpcClient$chain5 = rpcClient.chain) === null || _rpcClient$chain5 === void 0 ? void 0 : _rpcClient$chain5.id);
    this.rpcClient = rpcClient;
  }

  /**
   * event IPAccountRegistered for contract IPAssetRegistry
   */
  return _createClass(IpAssetRegistryEventClient, [{
    key: "watchIpAccountRegisteredEvent",
    value: function watchIpAccountRegisteredEvent(_onLogs5) {
      return this.rpcClient.watchContractEvent({
        abi: ipAssetRegistryAbi,
        address: this.address,
        eventName: "IPAccountRegistered",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs5(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event IPAccountRegistered for contract IPAssetRegistry
     */
  }, {
    key: "parseTxIpAccountRegisteredEvent",
    value: function parseTxIpAccountRegisteredEvent(txReceipt) {
      var targetLogs = [];
      var _iterator5 = _createForOfIteratorHelper(txReceipt.logs),
        _step5;
      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var log = _step5.value;
          try {
            var event = viem.decodeEventLog({
              abi: ipAssetRegistryAbi,
              eventName: "IPAccountRegistered",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "IPAccountRegistered") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
      return targetLogs;
    }

    /**
     * event IPRegistered for contract IPAssetRegistry
     */
  }, {
    key: "watchIpRegisteredEvent",
    value: function watchIpRegisteredEvent(_onLogs6) {
      return this.rpcClient.watchContractEvent({
        abi: ipAssetRegistryAbi,
        address: this.address,
        eventName: "IPRegistered",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs6(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event IPRegistered for contract IPAssetRegistry
     */
  }, {
    key: "parseTxIpRegisteredEvent",
    value: function parseTxIpRegisteredEvent(txReceipt) {
      var targetLogs = [];
      var _iterator6 = _createForOfIteratorHelper(txReceipt.logs),
        _step6;
      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var log = _step6.value;
          try {
            var event = viem.decodeEventLog({
              abi: ipAssetRegistryAbi,
              eventName: "IPRegistered",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "IPRegistered") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }
      return targetLogs;
    }
  }]);
}();

/**
 * contract IPAssetRegistry readonly method
 */
var IpAssetRegistryReadOnlyClient = /*#__PURE__*/function (_IpAssetRegistryEvent) {
  function IpAssetRegistryReadOnlyClient(rpcClient, address) {
    _classCallCheck(this, IpAssetRegistryReadOnlyClient);
    return _callSuper(this, IpAssetRegistryReadOnlyClient, [rpcClient, address]);
  }

  /**
   * method ipId for contract IPAssetRegistry
   *
   * @param request IpAssetRegistryIpIdRequest
   * @return Promise<IpAssetRegistryIpIdResponse>
   */
  _inherits(IpAssetRegistryReadOnlyClient, _IpAssetRegistryEvent);
  return _createClass(IpAssetRegistryReadOnlyClient, [{
    key: "ipId",
    value: (function () {
      var _ipId = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(request) {
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              _context9.next = 2;
              return this.rpcClient.readContract({
                abi: ipAssetRegistryAbi,
                address: this.address,
                functionName: "ipId",
                args: [request.chainId, request.tokenContract, request.tokenId]
              });
            case 2:
              return _context9.abrupt("return", _context9.sent);
            case 3:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this);
      }));
      function ipId(_x8) {
        return _ipId.apply(this, arguments);
      }
      return ipId;
    }()
    /**
     * method isRegistered for contract IPAssetRegistry
     *
     * @param request IpAssetRegistryIsRegisteredRequest
     * @return Promise<IpAssetRegistryIsRegisteredResponse>
     */
    )
  }, {
    key: "isRegistered",
    value: (function () {
      var _isRegistered = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(request) {
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              _context10.next = 2;
              return this.rpcClient.readContract({
                abi: ipAssetRegistryAbi,
                address: this.address,
                functionName: "isRegistered",
                args: [request.id]
              });
            case 2:
              return _context10.abrupt("return", _context10.sent);
            case 3:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this);
      }));
      function isRegistered(_x9) {
        return _isRegistered.apply(this, arguments);
      }
      return isRegistered;
    }())
  }]);
}(IpAssetRegistryEventClient);

/**
 * contract IPAssetRegistry write method
 */
var IpAssetRegistryClient = /*#__PURE__*/function (_IpAssetRegistryReadO) {
  function IpAssetRegistryClient(rpcClient, wallet, address) {
    var _this4;
    _classCallCheck(this, IpAssetRegistryClient);
    _this4 = _callSuper(this, IpAssetRegistryClient, [rpcClient, address]);
    _this4.wallet = wallet;
    return _this4;
  }

  /**
   * method register for contract IPAssetRegistry
   *
   * @param request IpAssetRegistryRegisterRequest
   * @return Promise<WriteContractReturnType>
   */
  _inherits(IpAssetRegistryClient, _IpAssetRegistryReadO);
  return _createClass(IpAssetRegistryClient, [{
    key: "register",
    value: (function () {
      var _register = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(request) {
        var _yield$this$rpcClient8, call;
        return _regeneratorRuntime().wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              _context11.next = 2;
              return this.rpcClient.simulateContract({
                abi: ipAssetRegistryAbi,
                address: this.address,
                functionName: "register",
                account: this.wallet.account,
                args: [request.chainid, request.tokenContract, request.tokenId]
              });
            case 2:
              _yield$this$rpcClient8 = _context11.sent;
              call = _yield$this$rpcClient8.request;
              _context11.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context11.abrupt("return", _context11.sent);
            case 7:
            case "end":
              return _context11.stop();
          }
        }, _callee11, this);
      }));
      function register(_x10) {
        return _register.apply(this, arguments);
      }
      return register;
    }())
  }]);
}(IpAssetRegistryReadOnlyClient);

// Contract IpRoyaltyVaultImpl =============================================================

/**
 * IpRoyaltyVaultImplRevenueTokenClaimedEvent
 *
 * @param claimer address
 * @param token address
 * @param amount uint256
 */

/**
 * IpRoyaltyVaultImplRoyaltyTokensCollectedEvent
 *
 * @param ancestorIpId address
 * @param royaltyTokensCollected uint256
 */

/**
 * IpRoyaltyVaultImplSnapshotCompletedEvent
 *
 * @param snapshotId uint256
 * @param snapshotTimestamp uint256
 * @param unclaimedTokens uint32
 */

/**
 * IpRoyaltyVaultImplClaimableRevenueRequest
 *
 * @param account address
 * @param snapshotId uint256
 * @param token address
 */

/**
 * IpRoyaltyVaultImplClaimRevenueBySnapshotBatchRequest
 *
 * @param snapshotIds uint256[]
 * @param token address
 */

/**
 * IpRoyaltyVaultImplClaimRevenueByTokenBatchRequest
 *
 * @param snapshotId uint256
 * @param tokenList address[]
 */

/**
 * IpRoyaltyVaultImplCollectRoyaltyTokensRequest
 *
 * @param ancestorIpId address
 */

/**
 * contract IpRoyaltyVaultImpl event
 */
var IpRoyaltyVaultImplEventClient = /*#__PURE__*/function () {
  function IpRoyaltyVaultImplEventClient(rpcClient, address) {
    var _rpcClient$chain6;
    _classCallCheck(this, IpRoyaltyVaultImplEventClient);
    this.address = address || getAddress(ipRoyaltyVaultImplAddress, (_rpcClient$chain6 = rpcClient.chain) === null || _rpcClient$chain6 === void 0 ? void 0 : _rpcClient$chain6.id);
    this.rpcClient = rpcClient;
  }

  /**
   * event RevenueTokenClaimed for contract IpRoyaltyVaultImpl
   */
  return _createClass(IpRoyaltyVaultImplEventClient, [{
    key: "watchRevenueTokenClaimedEvent",
    value: function watchRevenueTokenClaimedEvent(_onLogs7) {
      return this.rpcClient.watchContractEvent({
        abi: ipRoyaltyVaultImplAbi,
        address: this.address,
        eventName: "RevenueTokenClaimed",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs7(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event RevenueTokenClaimed for contract IpRoyaltyVaultImpl
     */
  }, {
    key: "parseTxRevenueTokenClaimedEvent",
    value: function parseTxRevenueTokenClaimedEvent(txReceipt) {
      var targetLogs = [];
      var _iterator7 = _createForOfIteratorHelper(txReceipt.logs),
        _step7;
      try {
        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
          var log = _step7.value;
          try {
            var event = viem.decodeEventLog({
              abi: ipRoyaltyVaultImplAbi,
              eventName: "RevenueTokenClaimed",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "RevenueTokenClaimed") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator7.e(err);
      } finally {
        _iterator7.f();
      }
      return targetLogs;
    }

    /**
     * event RoyaltyTokensCollected for contract IpRoyaltyVaultImpl
     */
  }, {
    key: "watchRoyaltyTokensCollectedEvent",
    value: function watchRoyaltyTokensCollectedEvent(_onLogs8) {
      return this.rpcClient.watchContractEvent({
        abi: ipRoyaltyVaultImplAbi,
        address: this.address,
        eventName: "RoyaltyTokensCollected",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs8(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event RoyaltyTokensCollected for contract IpRoyaltyVaultImpl
     */
  }, {
    key: "parseTxRoyaltyTokensCollectedEvent",
    value: function parseTxRoyaltyTokensCollectedEvent(txReceipt) {
      var targetLogs = [];
      var _iterator8 = _createForOfIteratorHelper(txReceipt.logs),
        _step8;
      try {
        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
          var log = _step8.value;
          try {
            var event = viem.decodeEventLog({
              abi: ipRoyaltyVaultImplAbi,
              eventName: "RoyaltyTokensCollected",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "RoyaltyTokensCollected") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator8.e(err);
      } finally {
        _iterator8.f();
      }
      return targetLogs;
    }

    /**
     * event SnapshotCompleted for contract IpRoyaltyVaultImpl
     */
  }, {
    key: "watchSnapshotCompletedEvent",
    value: function watchSnapshotCompletedEvent(_onLogs9) {
      return this.rpcClient.watchContractEvent({
        abi: ipRoyaltyVaultImplAbi,
        address: this.address,
        eventName: "SnapshotCompleted",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs9(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event SnapshotCompleted for contract IpRoyaltyVaultImpl
     */
  }, {
    key: "parseTxSnapshotCompletedEvent",
    value: function parseTxSnapshotCompletedEvent(txReceipt) {
      var targetLogs = [];
      var _iterator9 = _createForOfIteratorHelper(txReceipt.logs),
        _step9;
      try {
        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
          var log = _step9.value;
          try {
            var event = viem.decodeEventLog({
              abi: ipRoyaltyVaultImplAbi,
              eventName: "SnapshotCompleted",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "SnapshotCompleted") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator9.e(err);
      } finally {
        _iterator9.f();
      }
      return targetLogs;
    }
  }]);
}();

/**
 * contract IpRoyaltyVaultImpl readonly method
 */
var IpRoyaltyVaultImplReadOnlyClient = /*#__PURE__*/function (_IpRoyaltyVaultImplEv) {
  function IpRoyaltyVaultImplReadOnlyClient(rpcClient, address) {
    _classCallCheck(this, IpRoyaltyVaultImplReadOnlyClient);
    return _callSuper(this, IpRoyaltyVaultImplReadOnlyClient, [rpcClient, address]);
  }

  /**
   * method claimableRevenue for contract IpRoyaltyVaultImpl
   *
   * @param request IpRoyaltyVaultImplClaimableRevenueRequest
   * @return Promise<IpRoyaltyVaultImplClaimableRevenueResponse>
   */
  _inherits(IpRoyaltyVaultImplReadOnlyClient, _IpRoyaltyVaultImplEv);
  return _createClass(IpRoyaltyVaultImplReadOnlyClient, [{
    key: "claimableRevenue",
    value: (function () {
      var _claimableRevenue = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(request) {
        return _regeneratorRuntime().wrap(function _callee12$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              _context12.next = 2;
              return this.rpcClient.readContract({
                abi: ipRoyaltyVaultImplAbi,
                address: this.address,
                functionName: "claimableRevenue",
                args: [request.account, request.snapshotId, request.token]
              });
            case 2:
              return _context12.abrupt("return", _context12.sent);
            case 3:
            case "end":
              return _context12.stop();
          }
        }, _callee12, this);
      }));
      function claimableRevenue(_x11) {
        return _claimableRevenue.apply(this, arguments);
      }
      return claimableRevenue;
    }()
    /**
     * method ipId for contract IpRoyaltyVaultImpl
     *
     * @param request IpRoyaltyVaultImplIpIdRequest
     * @return Promise<IpRoyaltyVaultImplIpIdResponse>
     */
    )
  }, {
    key: "ipId",
    value: (function () {
      var _ipId2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {
        return _regeneratorRuntime().wrap(function _callee13$(_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              _context13.next = 2;
              return this.rpcClient.readContract({
                abi: ipRoyaltyVaultImplAbi,
                address: this.address,
                functionName: "ipId"
              });
            case 2:
              return _context13.abrupt("return", _context13.sent);
            case 3:
            case "end":
              return _context13.stop();
          }
        }, _callee13, this);
      }));
      function ipId() {
        return _ipId2.apply(this, arguments);
      }
      return ipId;
    }())
  }]);
}(IpRoyaltyVaultImplEventClient);

/**
 * contract IpRoyaltyVaultImpl write method
 */
var IpRoyaltyVaultImplClient = /*#__PURE__*/function (_IpRoyaltyVaultImplRe) {
  function IpRoyaltyVaultImplClient(rpcClient, wallet, address) {
    var _this5;
    _classCallCheck(this, IpRoyaltyVaultImplClient);
    _this5 = _callSuper(this, IpRoyaltyVaultImplClient, [rpcClient, address]);
    _this5.wallet = wallet;
    return _this5;
  }

  /**
   * method claimRevenueBySnapshotBatch for contract IpRoyaltyVaultImpl
   *
   * @param request IpRoyaltyVaultImplClaimRevenueBySnapshotBatchRequest
   * @return Promise<WriteContractReturnType>
   */
  _inherits(IpRoyaltyVaultImplClient, _IpRoyaltyVaultImplRe);
  return _createClass(IpRoyaltyVaultImplClient, [{
    key: "claimRevenueBySnapshotBatch",
    value: (function () {
      var _claimRevenueBySnapshotBatch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(request) {
        var _yield$this$rpcClient9, call;
        return _regeneratorRuntime().wrap(function _callee14$(_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              _context14.next = 2;
              return this.rpcClient.simulateContract({
                abi: ipRoyaltyVaultImplAbi,
                address: this.address,
                functionName: "claimRevenueBySnapshotBatch",
                account: this.wallet.account,
                args: [request.snapshotIds, request.token]
              });
            case 2:
              _yield$this$rpcClient9 = _context14.sent;
              call = _yield$this$rpcClient9.request;
              _context14.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context14.abrupt("return", _context14.sent);
            case 7:
            case "end":
              return _context14.stop();
          }
        }, _callee14, this);
      }));
      function claimRevenueBySnapshotBatch(_x12) {
        return _claimRevenueBySnapshotBatch.apply(this, arguments);
      }
      return claimRevenueBySnapshotBatch;
    }()
    /**
     * method claimRevenueByTokenBatch for contract IpRoyaltyVaultImpl
     *
     * @param request IpRoyaltyVaultImplClaimRevenueByTokenBatchRequest
     * @return Promise<WriteContractReturnType>
     */
    )
  }, {
    key: "claimRevenueByTokenBatch",
    value: (function () {
      var _claimRevenueByTokenBatch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(request) {
        var _yield$this$rpcClient10, call;
        return _regeneratorRuntime().wrap(function _callee15$(_context15) {
          while (1) switch (_context15.prev = _context15.next) {
            case 0:
              _context15.next = 2;
              return this.rpcClient.simulateContract({
                abi: ipRoyaltyVaultImplAbi,
                address: this.address,
                functionName: "claimRevenueByTokenBatch",
                account: this.wallet.account,
                args: [request.snapshotId, request.tokenList]
              });
            case 2:
              _yield$this$rpcClient10 = _context15.sent;
              call = _yield$this$rpcClient10.request;
              _context15.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context15.abrupt("return", _context15.sent);
            case 7:
            case "end":
              return _context15.stop();
          }
        }, _callee15, this);
      }));
      function claimRevenueByTokenBatch(_x13) {
        return _claimRevenueByTokenBatch.apply(this, arguments);
      }
      return claimRevenueByTokenBatch;
    }()
    /**
     * method collectRoyaltyTokens for contract IpRoyaltyVaultImpl
     *
     * @param request IpRoyaltyVaultImplCollectRoyaltyTokensRequest
     * @return Promise<WriteContractReturnType>
     */
    )
  }, {
    key: "collectRoyaltyTokens",
    value: (function () {
      var _collectRoyaltyTokens = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(request) {
        var _yield$this$rpcClient11, call;
        return _regeneratorRuntime().wrap(function _callee16$(_context16) {
          while (1) switch (_context16.prev = _context16.next) {
            case 0:
              _context16.next = 2;
              return this.rpcClient.simulateContract({
                abi: ipRoyaltyVaultImplAbi,
                address: this.address,
                functionName: "collectRoyaltyTokens",
                account: this.wallet.account,
                args: [request.ancestorIpId]
              });
            case 2:
              _yield$this$rpcClient11 = _context16.sent;
              call = _yield$this$rpcClient11.request;
              _context16.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context16.abrupt("return", _context16.sent);
            case 7:
            case "end":
              return _context16.stop();
          }
        }, _callee16, this);
      }));
      function collectRoyaltyTokens(_x14) {
        return _collectRoyaltyTokens.apply(this, arguments);
      }
      return collectRoyaltyTokens;
    }()
    /**
     * method snapshot for contract IpRoyaltyVaultImpl
     *
     * @param request IpRoyaltyVaultImplSnapshotRequest
     * @return Promise<WriteContractReturnType>
     */
    )
  }, {
    key: "snapshot",
    value: (function () {
      var _snapshot = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17() {
        var _yield$this$rpcClient12, call;
        return _regeneratorRuntime().wrap(function _callee17$(_context17) {
          while (1) switch (_context17.prev = _context17.next) {
            case 0:
              _context17.next = 2;
              return this.rpcClient.simulateContract({
                abi: ipRoyaltyVaultImplAbi,
                address: this.address,
                functionName: "snapshot",
                account: this.wallet.account
              });
            case 2:
              _yield$this$rpcClient12 = _context17.sent;
              call = _yield$this$rpcClient12.request;
              _context17.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context17.abrupt("return", _context17.sent);
            case 7:
            case "end":
              return _context17.stop();
          }
        }, _callee17, this);
      }));
      function snapshot() {
        return _snapshot.apply(this, arguments);
      }
      return snapshot;
    }())
  }]);
}(IpRoyaltyVaultImplReadOnlyClient);

// Contract LicenseRegistry =============================================================

/**
 * LicenseRegistryAuthorityUpdatedEvent
 *
 * @param authority address
 */

/**
 * LicenseRegistryExpirationTimeSetEvent
 *
 * @param ipId address
 * @param expireTime uint256
 */

/**
 * LicenseRegistryInitializedEvent
 *
 * @param version uint64
 */

/**
 * LicenseRegistryLicenseTemplateRegisteredEvent
 *
 * @param licenseTemplate address
 */

/**
 * LicenseRegistryLicensingConfigSetForIpEvent
 *
 * @param ipId address
 * @param licensingConfig tuple
 */

/**
 * LicenseRegistryLicensingConfigSetForLicenseEvent
 *
 * @param ipId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 */

/**
 * LicenseRegistryUpgradedEvent
 *
 * @param implementation address
 */

/**
 * LicenseRegistryExistsRequest
 *
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 */

/**
 * LicenseRegistryGetAttachedLicenseTermsRequest
 *
 * @param ipId address
 * @param index uint256
 */

/**
 * LicenseRegistryGetAttachedLicenseTermsResponse
 *
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 */

/**
 * LicenseRegistryGetAttachedLicenseTermsCountRequest
 *
 * @param ipId address
 */

/**
 * LicenseRegistryGetDefaultLicenseTermsResponse
 *
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 */

/**
 * LicenseRegistryGetDerivativeIpRequest
 *
 * @param parentIpId address
 * @param index uint256
 */

/**
 * LicenseRegistryGetDerivativeIpResponse
 *
 * @param childIpId address
 */

/**
 * LicenseRegistryGetDerivativeIpCountRequest
 *
 * @param parentIpId address
 */

/**
 * LicenseRegistryGetExpireTimeRequest
 *
 * @param ipId address
 */

/**
 * LicenseRegistryGetLicensingConfigRequest
 *
 * @param ipId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 */

/**
 * LicenseRegistryGetParentIpRequest
 *
 * @param childIpId address
 * @param index uint256
 */

/**
 * LicenseRegistryGetParentIpResponse
 *
 * @param parentIpId address
 */

/**
 * LicenseRegistryGetParentIpCountRequest
 *
 * @param childIpId address
 */

/**
 * LicenseRegistryHasDerivativeIpsRequest
 *
 * @param parentIpId address
 */

/**
 * LicenseRegistryHasIpAttachedLicenseTermsRequest
 *
 * @param ipId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 */

/**
 * LicenseRegistryIsDerivativeIpRequest
 *
 * @param childIpId address
 */

/**
 * LicenseRegistryIsExpiredNowRequest
 *
 * @param ipId address
 */

/**
 * LicenseRegistryIsParentIpRequest
 *
 * @param parentIpId address
 * @param childIpId address
 */

/**
 * LicenseRegistryIsRegisteredLicenseTemplateRequest
 *
 * @param licenseTemplate address
 */

/**
 * LicenseRegistryVerifyMintLicenseTokenRequest
 *
 * @param licensorIpId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 * @param isMintedByIpOwner bool
 */

/**
 * LicenseRegistryAttachLicenseTermsToIpRequest
 *
 * @param ipId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 */

/**
 * LicenseRegistryInitializeRequest
 *
 * @param accessManager address
 */

/**
 * LicenseRegistryRegisterDerivativeIpRequest
 *
 * @param childIpId address
 * @param parentIpIds address[]
 * @param licenseTemplate address
 * @param licenseTermsIds uint256[]
 */

/**
 * LicenseRegistryRegisterLicenseTemplateRequest
 *
 * @param licenseTemplate address
 */

/**
 * LicenseRegistrySetAuthorityRequest
 *
 * @param newAuthority address
 */

/**
 * LicenseRegistrySetDefaultLicenseTermsRequest
 *
 * @param newLicenseTemplate address
 * @param newLicenseTermsId uint256
 */

/**
 * LicenseRegistrySetExpireTimeRequest
 *
 * @param ipId address
 * @param expireTime uint256
 */

/**
 * LicenseRegistrySetLicensingConfigForIpRequest
 *
 * @param ipId address
 * @param licensingConfig tuple
 */

/**
 * LicenseRegistrySetLicensingConfigForLicenseRequest
 *
 * @param ipId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 * @param licensingConfig tuple
 */

/**
 * LicenseRegistryUpgradeToAndCallRequest
 *
 * @param newImplementation address
 * @param data bytes
 */

/**
 * contract LicenseRegistry event
 */
var LicenseRegistryEventClient = /*#__PURE__*/function () {
  function LicenseRegistryEventClient(rpcClient, address) {
    var _rpcClient$chain7;
    _classCallCheck(this, LicenseRegistryEventClient);
    this.address = address || getAddress(licenseRegistryAddress, (_rpcClient$chain7 = rpcClient.chain) === null || _rpcClient$chain7 === void 0 ? void 0 : _rpcClient$chain7.id);
    this.rpcClient = rpcClient;
  }

  /**
   * event AuthorityUpdated for contract LicenseRegistry
   */
  return _createClass(LicenseRegistryEventClient, [{
    key: "watchAuthorityUpdatedEvent",
    value: function watchAuthorityUpdatedEvent(_onLogs10) {
      return this.rpcClient.watchContractEvent({
        abi: licenseRegistryAbi,
        address: this.address,
        eventName: "AuthorityUpdated",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs10(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event AuthorityUpdated for contract LicenseRegistry
     */
  }, {
    key: "parseTxAuthorityUpdatedEvent",
    value: function parseTxAuthorityUpdatedEvent(txReceipt) {
      var targetLogs = [];
      var _iterator10 = _createForOfIteratorHelper(txReceipt.logs),
        _step10;
      try {
        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
          var log = _step10.value;
          try {
            var event = viem.decodeEventLog({
              abi: licenseRegistryAbi,
              eventName: "AuthorityUpdated",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "AuthorityUpdated") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator10.e(err);
      } finally {
        _iterator10.f();
      }
      return targetLogs;
    }

    /**
     * event ExpirationTimeSet for contract LicenseRegistry
     */
  }, {
    key: "watchExpirationTimeSetEvent",
    value: function watchExpirationTimeSetEvent(_onLogs11) {
      return this.rpcClient.watchContractEvent({
        abi: licenseRegistryAbi,
        address: this.address,
        eventName: "ExpirationTimeSet",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs11(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event ExpirationTimeSet for contract LicenseRegistry
     */
  }, {
    key: "parseTxExpirationTimeSetEvent",
    value: function parseTxExpirationTimeSetEvent(txReceipt) {
      var targetLogs = [];
      var _iterator11 = _createForOfIteratorHelper(txReceipt.logs),
        _step11;
      try {
        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
          var log = _step11.value;
          try {
            var event = viem.decodeEventLog({
              abi: licenseRegistryAbi,
              eventName: "ExpirationTimeSet",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "ExpirationTimeSet") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator11.e(err);
      } finally {
        _iterator11.f();
      }
      return targetLogs;
    }

    /**
     * event Initialized for contract LicenseRegistry
     */
  }, {
    key: "watchInitializedEvent",
    value: function watchInitializedEvent(_onLogs12) {
      return this.rpcClient.watchContractEvent({
        abi: licenseRegistryAbi,
        address: this.address,
        eventName: "Initialized",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs12(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event Initialized for contract LicenseRegistry
     */
  }, {
    key: "parseTxInitializedEvent",
    value: function parseTxInitializedEvent(txReceipt) {
      var targetLogs = [];
      var _iterator12 = _createForOfIteratorHelper(txReceipt.logs),
        _step12;
      try {
        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
          var log = _step12.value;
          try {
            var event = viem.decodeEventLog({
              abi: licenseRegistryAbi,
              eventName: "Initialized",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "Initialized") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator12.e(err);
      } finally {
        _iterator12.f();
      }
      return targetLogs;
    }

    /**
     * event LicenseTemplateRegistered for contract LicenseRegistry
     */
  }, {
    key: "watchLicenseTemplateRegisteredEvent",
    value: function watchLicenseTemplateRegisteredEvent(_onLogs13) {
      return this.rpcClient.watchContractEvent({
        abi: licenseRegistryAbi,
        address: this.address,
        eventName: "LicenseTemplateRegistered",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs13(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event LicenseTemplateRegistered for contract LicenseRegistry
     */
  }, {
    key: "parseTxLicenseTemplateRegisteredEvent",
    value: function parseTxLicenseTemplateRegisteredEvent(txReceipt) {
      var targetLogs = [];
      var _iterator13 = _createForOfIteratorHelper(txReceipt.logs),
        _step13;
      try {
        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
          var log = _step13.value;
          try {
            var event = viem.decodeEventLog({
              abi: licenseRegistryAbi,
              eventName: "LicenseTemplateRegistered",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "LicenseTemplateRegistered") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator13.e(err);
      } finally {
        _iterator13.f();
      }
      return targetLogs;
    }

    /**
     * event LicensingConfigSetForIP for contract LicenseRegistry
     */
  }, {
    key: "watchLicensingConfigSetForIpEvent",
    value: function watchLicensingConfigSetForIpEvent(_onLogs14) {
      return this.rpcClient.watchContractEvent({
        abi: licenseRegistryAbi,
        address: this.address,
        eventName: "LicensingConfigSetForIP",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs14(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event LicensingConfigSetForIP for contract LicenseRegistry
     */
  }, {
    key: "parseTxLicensingConfigSetForIpEvent",
    value: function parseTxLicensingConfigSetForIpEvent(txReceipt) {
      var targetLogs = [];
      var _iterator14 = _createForOfIteratorHelper(txReceipt.logs),
        _step14;
      try {
        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
          var log = _step14.value;
          try {
            var event = viem.decodeEventLog({
              abi: licenseRegistryAbi,
              eventName: "LicensingConfigSetForIP",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "LicensingConfigSetForIP") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator14.e(err);
      } finally {
        _iterator14.f();
      }
      return targetLogs;
    }

    /**
     * event LicensingConfigSetForLicense for contract LicenseRegistry
     */
  }, {
    key: "watchLicensingConfigSetForLicenseEvent",
    value: function watchLicensingConfigSetForLicenseEvent(_onLogs15) {
      return this.rpcClient.watchContractEvent({
        abi: licenseRegistryAbi,
        address: this.address,
        eventName: "LicensingConfigSetForLicense",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs15(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event LicensingConfigSetForLicense for contract LicenseRegistry
     */
  }, {
    key: "parseTxLicensingConfigSetForLicenseEvent",
    value: function parseTxLicensingConfigSetForLicenseEvent(txReceipt) {
      var targetLogs = [];
      var _iterator15 = _createForOfIteratorHelper(txReceipt.logs),
        _step15;
      try {
        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
          var log = _step15.value;
          try {
            var event = viem.decodeEventLog({
              abi: licenseRegistryAbi,
              eventName: "LicensingConfigSetForLicense",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "LicensingConfigSetForLicense") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator15.e(err);
      } finally {
        _iterator15.f();
      }
      return targetLogs;
    }

    /**
     * event Upgraded for contract LicenseRegistry
     */
  }, {
    key: "watchUpgradedEvent",
    value: function watchUpgradedEvent(_onLogs16) {
      return this.rpcClient.watchContractEvent({
        abi: licenseRegistryAbi,
        address: this.address,
        eventName: "Upgraded",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs16(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event Upgraded for contract LicenseRegistry
     */
  }, {
    key: "parseTxUpgradedEvent",
    value: function parseTxUpgradedEvent(txReceipt) {
      var targetLogs = [];
      var _iterator16 = _createForOfIteratorHelper(txReceipt.logs),
        _step16;
      try {
        for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
          var log = _step16.value;
          try {
            var event = viem.decodeEventLog({
              abi: licenseRegistryAbi,
              eventName: "Upgraded",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "Upgraded") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator16.e(err);
      } finally {
        _iterator16.f();
      }
      return targetLogs;
    }
  }]);
}();

/**
 * contract LicenseRegistry readonly method
 */
var LicenseRegistryReadOnlyClient = /*#__PURE__*/function (_LicenseRegistryEvent) {
  function LicenseRegistryReadOnlyClient(rpcClient, address) {
    _classCallCheck(this, LicenseRegistryReadOnlyClient);
    return _callSuper(this, LicenseRegistryReadOnlyClient, [rpcClient, address]);
  }

  /**
   * method DISPUTE_MODULE for contract LicenseRegistry
   *
   * @param request LicenseRegistryDisputeModuleRequest
   * @return Promise<LicenseRegistryDisputeModuleResponse>
   */
  _inherits(LicenseRegistryReadOnlyClient, _LicenseRegistryEvent);
  return _createClass(LicenseRegistryReadOnlyClient, [{
    key: "disputeModule",
    value: (function () {
      var _disputeModule = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18() {
        return _regeneratorRuntime().wrap(function _callee18$(_context18) {
          while (1) switch (_context18.prev = _context18.next) {
            case 0:
              _context18.next = 2;
              return this.rpcClient.readContract({
                abi: licenseRegistryAbi,
                address: this.address,
                functionName: "DISPUTE_MODULE"
              });
            case 2:
              return _context18.abrupt("return", _context18.sent);
            case 3:
            case "end":
              return _context18.stop();
          }
        }, _callee18, this);
      }));
      function disputeModule() {
        return _disputeModule.apply(this, arguments);
      }
      return disputeModule;
    }()
    /**
     * method EXPIRATION_TIME for contract LicenseRegistry
     *
     * @param request LicenseRegistryExpirationTimeRequest
     * @return Promise<LicenseRegistryExpirationTimeResponse>
     */
    )
  }, {
    key: "expirationTime",
    value: (function () {
      var _expirationTime = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19() {
        return _regeneratorRuntime().wrap(function _callee19$(_context19) {
          while (1) switch (_context19.prev = _context19.next) {
            case 0:
              _context19.next = 2;
              return this.rpcClient.readContract({
                abi: licenseRegistryAbi,
                address: this.address,
                functionName: "EXPIRATION_TIME"
              });
            case 2:
              return _context19.abrupt("return", _context19.sent);
            case 3:
            case "end":
              return _context19.stop();
          }
        }, _callee19, this);
      }));
      function expirationTime() {
        return _expirationTime.apply(this, arguments);
      }
      return expirationTime;
    }()
    /**
     * method LICENSING_MODULE for contract LicenseRegistry
     *
     * @param request LicenseRegistryLicensingModuleRequest
     * @return Promise<LicenseRegistryLicensingModuleResponse>
     */
    )
  }, {
    key: "licensingModule",
    value: (function () {
      var _licensingModule = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20() {
        return _regeneratorRuntime().wrap(function _callee20$(_context20) {
          while (1) switch (_context20.prev = _context20.next) {
            case 0:
              _context20.next = 2;
              return this.rpcClient.readContract({
                abi: licenseRegistryAbi,
                address: this.address,
                functionName: "LICENSING_MODULE"
              });
            case 2:
              return _context20.abrupt("return", _context20.sent);
            case 3:
            case "end":
              return _context20.stop();
          }
        }, _callee20, this);
      }));
      function licensingModule() {
        return _licensingModule.apply(this, arguments);
      }
      return licensingModule;
    }()
    /**
     * method UPGRADE_INTERFACE_VERSION for contract LicenseRegistry
     *
     * @param request LicenseRegistryUpgradeInterfaceVersionRequest
     * @return Promise<LicenseRegistryUpgradeInterfaceVersionResponse>
     */
    )
  }, {
    key: "upgradeInterfaceVersion",
    value: (function () {
      var _upgradeInterfaceVersion = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21() {
        return _regeneratorRuntime().wrap(function _callee21$(_context21) {
          while (1) switch (_context21.prev = _context21.next) {
            case 0:
              _context21.next = 2;
              return this.rpcClient.readContract({
                abi: licenseRegistryAbi,
                address: this.address,
                functionName: "UPGRADE_INTERFACE_VERSION"
              });
            case 2:
              return _context21.abrupt("return", _context21.sent);
            case 3:
            case "end":
              return _context21.stop();
          }
        }, _callee21, this);
      }));
      function upgradeInterfaceVersion() {
        return _upgradeInterfaceVersion.apply(this, arguments);
      }
      return upgradeInterfaceVersion;
    }()
    /**
     * method authority for contract LicenseRegistry
     *
     * @param request LicenseRegistryAuthorityRequest
     * @return Promise<LicenseRegistryAuthorityResponse>
     */
    )
  }, {
    key: "authority",
    value: (function () {
      var _authority = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee22() {
        return _regeneratorRuntime().wrap(function _callee22$(_context22) {
          while (1) switch (_context22.prev = _context22.next) {
            case 0:
              _context22.next = 2;
              return this.rpcClient.readContract({
                abi: licenseRegistryAbi,
                address: this.address,
                functionName: "authority"
              });
            case 2:
              return _context22.abrupt("return", _context22.sent);
            case 3:
            case "end":
              return _context22.stop();
          }
        }, _callee22, this);
      }));
      function authority() {
        return _authority.apply(this, arguments);
      }
      return authority;
    }()
    /**
     * method exists for contract LicenseRegistry
     *
     * @param request LicenseRegistryExistsRequest
     * @return Promise<LicenseRegistryExistsResponse>
     */
    )
  }, {
    key: "exists",
    value: (function () {
      var _exists = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee23(request) {
        return _regeneratorRuntime().wrap(function _callee23$(_context23) {
          while (1) switch (_context23.prev = _context23.next) {
            case 0:
              _context23.next = 2;
              return this.rpcClient.readContract({
                abi: licenseRegistryAbi,
                address: this.address,
                functionName: "exists",
                args: [request.licenseTemplate, request.licenseTermsId]
              });
            case 2:
              return _context23.abrupt("return", _context23.sent);
            case 3:
            case "end":
              return _context23.stop();
          }
        }, _callee23, this);
      }));
      function exists(_x15) {
        return _exists.apply(this, arguments);
      }
      return exists;
    }()
    /**
     * method getAttachedLicenseTerms for contract LicenseRegistry
     *
     * @param request LicenseRegistryGetAttachedLicenseTermsRequest
     * @return Promise<LicenseRegistryGetAttachedLicenseTermsResponse>
     */
    )
  }, {
    key: "getAttachedLicenseTerms",
    value: (function () {
      var _getAttachedLicenseTerms = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee24(request) {
        var result;
        return _regeneratorRuntime().wrap(function _callee24$(_context24) {
          while (1) switch (_context24.prev = _context24.next) {
            case 0:
              _context24.next = 2;
              return this.rpcClient.readContract({
                abi: licenseRegistryAbi,
                address: this.address,
                functionName: "getAttachedLicenseTerms",
                args: [request.ipId, request.index]
              });
            case 2:
              result = _context24.sent;
              return _context24.abrupt("return", {
                licenseTemplate: result[0],
                licenseTermsId: result[1]
              });
            case 4:
            case "end":
              return _context24.stop();
          }
        }, _callee24, this);
      }));
      function getAttachedLicenseTerms(_x16) {
        return _getAttachedLicenseTerms.apply(this, arguments);
      }
      return getAttachedLicenseTerms;
    }()
    /**
     * method getAttachedLicenseTermsCount for contract LicenseRegistry
     *
     * @param request LicenseRegistryGetAttachedLicenseTermsCountRequest
     * @return Promise<LicenseRegistryGetAttachedLicenseTermsCountResponse>
     */
    )
  }, {
    key: "getAttachedLicenseTermsCount",
    value: (function () {
      var _getAttachedLicenseTermsCount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee25(request) {
        return _regeneratorRuntime().wrap(function _callee25$(_context25) {
          while (1) switch (_context25.prev = _context25.next) {
            case 0:
              _context25.next = 2;
              return this.rpcClient.readContract({
                abi: licenseRegistryAbi,
                address: this.address,
                functionName: "getAttachedLicenseTermsCount",
                args: [request.ipId]
              });
            case 2:
              return _context25.abrupt("return", _context25.sent);
            case 3:
            case "end":
              return _context25.stop();
          }
        }, _callee25, this);
      }));
      function getAttachedLicenseTermsCount(_x17) {
        return _getAttachedLicenseTermsCount.apply(this, arguments);
      }
      return getAttachedLicenseTermsCount;
    }()
    /**
     * method getDefaultLicenseTerms for contract LicenseRegistry
     *
     * @param request LicenseRegistryGetDefaultLicenseTermsRequest
     * @return Promise<LicenseRegistryGetDefaultLicenseTermsResponse>
     */
    )
  }, {
    key: "getDefaultLicenseTerms",
    value: (function () {
      var _getDefaultLicenseTerms = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee26() {
        var result;
        return _regeneratorRuntime().wrap(function _callee26$(_context26) {
          while (1) switch (_context26.prev = _context26.next) {
            case 0:
              _context26.next = 2;
              return this.rpcClient.readContract({
                abi: licenseRegistryAbi,
                address: this.address,
                functionName: "getDefaultLicenseTerms"
              });
            case 2:
              result = _context26.sent;
              return _context26.abrupt("return", {
                licenseTemplate: result[0],
                licenseTermsId: result[1]
              });
            case 4:
            case "end":
              return _context26.stop();
          }
        }, _callee26, this);
      }));
      function getDefaultLicenseTerms() {
        return _getDefaultLicenseTerms.apply(this, arguments);
      }
      return getDefaultLicenseTerms;
    }()
    /**
     * method getDerivativeIp for contract LicenseRegistry
     *
     * @param request LicenseRegistryGetDerivativeIpRequest
     * @return Promise<LicenseRegistryGetDerivativeIpResponse>
     */
    )
  }, {
    key: "getDerivativeIp",
    value: (function () {
      var _getDerivativeIp = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee27(request) {
        var result;
        return _regeneratorRuntime().wrap(function _callee27$(_context27) {
          while (1) switch (_context27.prev = _context27.next) {
            case 0:
              _context27.next = 2;
              return this.rpcClient.readContract({
                abi: licenseRegistryAbi,
                address: this.address,
                functionName: "getDerivativeIp",
                args: [request.parentIpId, request.index]
              });
            case 2:
              result = _context27.sent;
              return _context27.abrupt("return", {
                childIpId: result
              });
            case 4:
            case "end":
              return _context27.stop();
          }
        }, _callee27, this);
      }));
      function getDerivativeIp(_x18) {
        return _getDerivativeIp.apply(this, arguments);
      }
      return getDerivativeIp;
    }()
    /**
     * method getDerivativeIpCount for contract LicenseRegistry
     *
     * @param request LicenseRegistryGetDerivativeIpCountRequest
     * @return Promise<LicenseRegistryGetDerivativeIpCountResponse>
     */
    )
  }, {
    key: "getDerivativeIpCount",
    value: (function () {
      var _getDerivativeIpCount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee28(request) {
        return _regeneratorRuntime().wrap(function _callee28$(_context28) {
          while (1) switch (_context28.prev = _context28.next) {
            case 0:
              _context28.next = 2;
              return this.rpcClient.readContract({
                abi: licenseRegistryAbi,
                address: this.address,
                functionName: "getDerivativeIpCount",
                args: [request.parentIpId]
              });
            case 2:
              return _context28.abrupt("return", _context28.sent);
            case 3:
            case "end":
              return _context28.stop();
          }
        }, _callee28, this);
      }));
      function getDerivativeIpCount(_x19) {
        return _getDerivativeIpCount.apply(this, arguments);
      }
      return getDerivativeIpCount;
    }()
    /**
     * method getExpireTime for contract LicenseRegistry
     *
     * @param request LicenseRegistryGetExpireTimeRequest
     * @return Promise<LicenseRegistryGetExpireTimeResponse>
     */
    )
  }, {
    key: "getExpireTime",
    value: (function () {
      var _getExpireTime = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee29(request) {
        return _regeneratorRuntime().wrap(function _callee29$(_context29) {
          while (1) switch (_context29.prev = _context29.next) {
            case 0:
              _context29.next = 2;
              return this.rpcClient.readContract({
                abi: licenseRegistryAbi,
                address: this.address,
                functionName: "getExpireTime",
                args: [request.ipId]
              });
            case 2:
              return _context29.abrupt("return", _context29.sent);
            case 3:
            case "end":
              return _context29.stop();
          }
        }, _callee29, this);
      }));
      function getExpireTime(_x20) {
        return _getExpireTime.apply(this, arguments);
      }
      return getExpireTime;
    }()
    /**
     * method getLicensingConfig for contract LicenseRegistry
     *
     * @param request LicenseRegistryGetLicensingConfigRequest
     * @return Promise<LicenseRegistryGetLicensingConfigResponse>
     */
    )
  }, {
    key: "getLicensingConfig",
    value: (function () {
      var _getLicensingConfig = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee30(request) {
        return _regeneratorRuntime().wrap(function _callee30$(_context30) {
          while (1) switch (_context30.prev = _context30.next) {
            case 0:
              _context30.next = 2;
              return this.rpcClient.readContract({
                abi: licenseRegistryAbi,
                address: this.address,
                functionName: "getLicensingConfig",
                args: [request.ipId, request.licenseTemplate, request.licenseTermsId]
              });
            case 2:
              return _context30.abrupt("return", _context30.sent);
            case 3:
            case "end":
              return _context30.stop();
          }
        }, _callee30, this);
      }));
      function getLicensingConfig(_x21) {
        return _getLicensingConfig.apply(this, arguments);
      }
      return getLicensingConfig;
    }()
    /**
     * method getParentIp for contract LicenseRegistry
     *
     * @param request LicenseRegistryGetParentIpRequest
     * @return Promise<LicenseRegistryGetParentIpResponse>
     */
    )
  }, {
    key: "getParentIp",
    value: (function () {
      var _getParentIp = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee31(request) {
        var result;
        return _regeneratorRuntime().wrap(function _callee31$(_context31) {
          while (1) switch (_context31.prev = _context31.next) {
            case 0:
              _context31.next = 2;
              return this.rpcClient.readContract({
                abi: licenseRegistryAbi,
                address: this.address,
                functionName: "getParentIp",
                args: [request.childIpId, request.index]
              });
            case 2:
              result = _context31.sent;
              return _context31.abrupt("return", {
                parentIpId: result
              });
            case 4:
            case "end":
              return _context31.stop();
          }
        }, _callee31, this);
      }));
      function getParentIp(_x22) {
        return _getParentIp.apply(this, arguments);
      }
      return getParentIp;
    }()
    /**
     * method getParentIpCount for contract LicenseRegistry
     *
     * @param request LicenseRegistryGetParentIpCountRequest
     * @return Promise<LicenseRegistryGetParentIpCountResponse>
     */
    )
  }, {
    key: "getParentIpCount",
    value: (function () {
      var _getParentIpCount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee32(request) {
        return _regeneratorRuntime().wrap(function _callee32$(_context32) {
          while (1) switch (_context32.prev = _context32.next) {
            case 0:
              _context32.next = 2;
              return this.rpcClient.readContract({
                abi: licenseRegistryAbi,
                address: this.address,
                functionName: "getParentIpCount",
                args: [request.childIpId]
              });
            case 2:
              return _context32.abrupt("return", _context32.sent);
            case 3:
            case "end":
              return _context32.stop();
          }
        }, _callee32, this);
      }));
      function getParentIpCount(_x23) {
        return _getParentIpCount.apply(this, arguments);
      }
      return getParentIpCount;
    }()
    /**
     * method hasDerivativeIps for contract LicenseRegistry
     *
     * @param request LicenseRegistryHasDerivativeIpsRequest
     * @return Promise<LicenseRegistryHasDerivativeIpsResponse>
     */
    )
  }, {
    key: "hasDerivativeIps",
    value: (function () {
      var _hasDerivativeIps = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee33(request) {
        return _regeneratorRuntime().wrap(function _callee33$(_context33) {
          while (1) switch (_context33.prev = _context33.next) {
            case 0:
              _context33.next = 2;
              return this.rpcClient.readContract({
                abi: licenseRegistryAbi,
                address: this.address,
                functionName: "hasDerivativeIps",
                args: [request.parentIpId]
              });
            case 2:
              return _context33.abrupt("return", _context33.sent);
            case 3:
            case "end":
              return _context33.stop();
          }
        }, _callee33, this);
      }));
      function hasDerivativeIps(_x24) {
        return _hasDerivativeIps.apply(this, arguments);
      }
      return hasDerivativeIps;
    }()
    /**
     * method hasIpAttachedLicenseTerms for contract LicenseRegistry
     *
     * @param request LicenseRegistryHasIpAttachedLicenseTermsRequest
     * @return Promise<LicenseRegistryHasIpAttachedLicenseTermsResponse>
     */
    )
  }, {
    key: "hasIpAttachedLicenseTerms",
    value: (function () {
      var _hasIpAttachedLicenseTerms = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee34(request) {
        return _regeneratorRuntime().wrap(function _callee34$(_context34) {
          while (1) switch (_context34.prev = _context34.next) {
            case 0:
              _context34.next = 2;
              return this.rpcClient.readContract({
                abi: licenseRegistryAbi,
                address: this.address,
                functionName: "hasIpAttachedLicenseTerms",
                args: [request.ipId, request.licenseTemplate, request.licenseTermsId]
              });
            case 2:
              return _context34.abrupt("return", _context34.sent);
            case 3:
            case "end":
              return _context34.stop();
          }
        }, _callee34, this);
      }));
      function hasIpAttachedLicenseTerms(_x25) {
        return _hasIpAttachedLicenseTerms.apply(this, arguments);
      }
      return hasIpAttachedLicenseTerms;
    }()
    /**
     * method isConsumingScheduledOp for contract LicenseRegistry
     *
     * @param request LicenseRegistryIsConsumingScheduledOpRequest
     * @return Promise<LicenseRegistryIsConsumingScheduledOpResponse>
     */
    )
  }, {
    key: "isConsumingScheduledOp",
    value: (function () {
      var _isConsumingScheduledOp = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee35() {
        return _regeneratorRuntime().wrap(function _callee35$(_context35) {
          while (1) switch (_context35.prev = _context35.next) {
            case 0:
              _context35.next = 2;
              return this.rpcClient.readContract({
                abi: licenseRegistryAbi,
                address: this.address,
                functionName: "isConsumingScheduledOp"
              });
            case 2:
              return _context35.abrupt("return", _context35.sent);
            case 3:
            case "end":
              return _context35.stop();
          }
        }, _callee35, this);
      }));
      function isConsumingScheduledOp() {
        return _isConsumingScheduledOp.apply(this, arguments);
      }
      return isConsumingScheduledOp;
    }()
    /**
     * method isDerivativeIp for contract LicenseRegistry
     *
     * @param request LicenseRegistryIsDerivativeIpRequest
     * @return Promise<LicenseRegistryIsDerivativeIpResponse>
     */
    )
  }, {
    key: "isDerivativeIp",
    value: (function () {
      var _isDerivativeIp = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee36(request) {
        return _regeneratorRuntime().wrap(function _callee36$(_context36) {
          while (1) switch (_context36.prev = _context36.next) {
            case 0:
              _context36.next = 2;
              return this.rpcClient.readContract({
                abi: licenseRegistryAbi,
                address: this.address,
                functionName: "isDerivativeIp",
                args: [request.childIpId]
              });
            case 2:
              return _context36.abrupt("return", _context36.sent);
            case 3:
            case "end":
              return _context36.stop();
          }
        }, _callee36, this);
      }));
      function isDerivativeIp(_x26) {
        return _isDerivativeIp.apply(this, arguments);
      }
      return isDerivativeIp;
    }()
    /**
     * method isExpiredNow for contract LicenseRegistry
     *
     * @param request LicenseRegistryIsExpiredNowRequest
     * @return Promise<LicenseRegistryIsExpiredNowResponse>
     */
    )
  }, {
    key: "isExpiredNow",
    value: (function () {
      var _isExpiredNow = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee37(request) {
        return _regeneratorRuntime().wrap(function _callee37$(_context37) {
          while (1) switch (_context37.prev = _context37.next) {
            case 0:
              _context37.next = 2;
              return this.rpcClient.readContract({
                abi: licenseRegistryAbi,
                address: this.address,
                functionName: "isExpiredNow",
                args: [request.ipId]
              });
            case 2:
              return _context37.abrupt("return", _context37.sent);
            case 3:
            case "end":
              return _context37.stop();
          }
        }, _callee37, this);
      }));
      function isExpiredNow(_x27) {
        return _isExpiredNow.apply(this, arguments);
      }
      return isExpiredNow;
    }()
    /**
     * method isParentIp for contract LicenseRegistry
     *
     * @param request LicenseRegistryIsParentIpRequest
     * @return Promise<LicenseRegistryIsParentIpResponse>
     */
    )
  }, {
    key: "isParentIp",
    value: (function () {
      var _isParentIp = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee38(request) {
        return _regeneratorRuntime().wrap(function _callee38$(_context38) {
          while (1) switch (_context38.prev = _context38.next) {
            case 0:
              _context38.next = 2;
              return this.rpcClient.readContract({
                abi: licenseRegistryAbi,
                address: this.address,
                functionName: "isParentIp",
                args: [request.parentIpId, request.childIpId]
              });
            case 2:
              return _context38.abrupt("return", _context38.sent);
            case 3:
            case "end":
              return _context38.stop();
          }
        }, _callee38, this);
      }));
      function isParentIp(_x28) {
        return _isParentIp.apply(this, arguments);
      }
      return isParentIp;
    }()
    /**
     * method isRegisteredLicenseTemplate for contract LicenseRegistry
     *
     * @param request LicenseRegistryIsRegisteredLicenseTemplateRequest
     * @return Promise<LicenseRegistryIsRegisteredLicenseTemplateResponse>
     */
    )
  }, {
    key: "isRegisteredLicenseTemplate",
    value: (function () {
      var _isRegisteredLicenseTemplate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee39(request) {
        return _regeneratorRuntime().wrap(function _callee39$(_context39) {
          while (1) switch (_context39.prev = _context39.next) {
            case 0:
              _context39.next = 2;
              return this.rpcClient.readContract({
                abi: licenseRegistryAbi,
                address: this.address,
                functionName: "isRegisteredLicenseTemplate",
                args: [request.licenseTemplate]
              });
            case 2:
              return _context39.abrupt("return", _context39.sent);
            case 3:
            case "end":
              return _context39.stop();
          }
        }, _callee39, this);
      }));
      function isRegisteredLicenseTemplate(_x29) {
        return _isRegisteredLicenseTemplate.apply(this, arguments);
      }
      return isRegisteredLicenseTemplate;
    }()
    /**
     * method proxiableUUID for contract LicenseRegistry
     *
     * @param request LicenseRegistryProxiableUuidRequest
     * @return Promise<LicenseRegistryProxiableUuidResponse>
     */
    )
  }, {
    key: "proxiableUuid",
    value: (function () {
      var _proxiableUuid = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee40() {
        return _regeneratorRuntime().wrap(function _callee40$(_context40) {
          while (1) switch (_context40.prev = _context40.next) {
            case 0:
              _context40.next = 2;
              return this.rpcClient.readContract({
                abi: licenseRegistryAbi,
                address: this.address,
                functionName: "proxiableUUID"
              });
            case 2:
              return _context40.abrupt("return", _context40.sent);
            case 3:
            case "end":
              return _context40.stop();
          }
        }, _callee40, this);
      }));
      function proxiableUuid() {
        return _proxiableUuid.apply(this, arguments);
      }
      return proxiableUuid;
    }()
    /**
     * method verifyMintLicenseToken for contract LicenseRegistry
     *
     * @param request LicenseRegistryVerifyMintLicenseTokenRequest
     * @return Promise<LicenseRegistryVerifyMintLicenseTokenResponse>
     */
    )
  }, {
    key: "verifyMintLicenseToken",
    value: (function () {
      var _verifyMintLicenseToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee41(request) {
        return _regeneratorRuntime().wrap(function _callee41$(_context41) {
          while (1) switch (_context41.prev = _context41.next) {
            case 0:
              _context41.next = 2;
              return this.rpcClient.readContract({
                abi: licenseRegistryAbi,
                address: this.address,
                functionName: "verifyMintLicenseToken",
                args: [request.licensorIpId, request.licenseTemplate, request.licenseTermsId, request.isMintedByIpOwner]
              });
            case 2:
              return _context41.abrupt("return", _context41.sent);
            case 3:
            case "end":
              return _context41.stop();
          }
        }, _callee41, this);
      }));
      function verifyMintLicenseToken(_x30) {
        return _verifyMintLicenseToken.apply(this, arguments);
      }
      return verifyMintLicenseToken;
    }())
  }]);
}(LicenseRegistryEventClient);

// Contract LicenseToken =============================================================

/**
 * LicenseTokenOwnerOfRequest
 *
 * @param tokenId uint256
 */

/**
 * contract LicenseToken readonly method
 */
var LicenseTokenReadOnlyClient = /*#__PURE__*/function () {
  function LicenseTokenReadOnlyClient(rpcClient, address) {
    var _rpcClient$chain8;
    _classCallCheck(this, LicenseTokenReadOnlyClient);
    this.address = address || getAddress(licenseTokenAddress, (_rpcClient$chain8 = rpcClient.chain) === null || _rpcClient$chain8 === void 0 ? void 0 : _rpcClient$chain8.id);
    this.rpcClient = rpcClient;
  }

  /**
   * method ownerOf for contract LicenseToken
   *
   * @param request LicenseTokenOwnerOfRequest
   * @return Promise<LicenseTokenOwnerOfResponse>
   */
  return _createClass(LicenseTokenReadOnlyClient, [{
    key: "ownerOf",
    value: (function () {
      var _ownerOf = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee52(request) {
        return _regeneratorRuntime().wrap(function _callee52$(_context52) {
          while (1) switch (_context52.prev = _context52.next) {
            case 0:
              _context52.next = 2;
              return this.rpcClient.readContract({
                abi: licenseTokenAbi,
                address: this.address,
                functionName: "ownerOf",
                args: [request.tokenId]
              });
            case 2:
              return _context52.abrupt("return", _context52.sent);
            case 3:
            case "end":
              return _context52.stop();
          }
        }, _callee52, this);
      }));
      function ownerOf(_x41) {
        return _ownerOf.apply(this, arguments);
      }
      return ownerOf;
    }())
  }]);
}();

// Contract LicensingModule =============================================================

/**
 * LicensingModuleLicenseTermsAttachedEvent
 *
 * @param caller address
 * @param ipId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 */

/**
 * LicensingModuleLicenseTokensMintedEvent
 *
 * @param caller address
 * @param licensorIpId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 * @param amount uint256
 * @param receiver address
 * @param startLicenseTokenId uint256
 */

/**
 * LicensingModuleAttachLicenseTermsRequest
 *
 * @param ipId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 */

/**
 * LicensingModuleMintLicenseTokensRequest
 *
 * @param licensorIpId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 * @param amount uint256
 * @param receiver address
 * @param royaltyContext bytes
 */

/**
 * LicensingModuleRegisterDerivativeRequest
 *
 * @param childIpId address
 * @param parentIpIds address[]
 * @param licenseTermsIds uint256[]
 * @param licenseTemplate address
 * @param royaltyContext bytes
 */

/**
 * LicensingModuleRegisterDerivativeWithLicenseTokensRequest
 *
 * @param childIpId address
 * @param licenseTokenIds uint256[]
 * @param royaltyContext bytes
 */

/**
 * contract LicensingModule event
 */
var LicensingModuleEventClient = /*#__PURE__*/function () {
  function LicensingModuleEventClient(rpcClient, address) {
    var _rpcClient$chain9;
    _classCallCheck(this, LicensingModuleEventClient);
    this.address = address || getAddress(licensingModuleAddress, (_rpcClient$chain9 = rpcClient.chain) === null || _rpcClient$chain9 === void 0 ? void 0 : _rpcClient$chain9.id);
    this.rpcClient = rpcClient;
  }

  /**
   * event LicenseTermsAttached for contract LicensingModule
   */
  return _createClass(LicensingModuleEventClient, [{
    key: "watchLicenseTermsAttachedEvent",
    value: function watchLicenseTermsAttachedEvent(_onLogs17) {
      return this.rpcClient.watchContractEvent({
        abi: licensingModuleAbi,
        address: this.address,
        eventName: "LicenseTermsAttached",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs17(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event LicenseTermsAttached for contract LicensingModule
     */
  }, {
    key: "parseTxLicenseTermsAttachedEvent",
    value: function parseTxLicenseTermsAttachedEvent(txReceipt) {
      var targetLogs = [];
      var _iterator17 = _createForOfIteratorHelper(txReceipt.logs),
        _step17;
      try {
        for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
          var log = _step17.value;
          try {
            var event = viem.decodeEventLog({
              abi: licensingModuleAbi,
              eventName: "LicenseTermsAttached",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "LicenseTermsAttached") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator17.e(err);
      } finally {
        _iterator17.f();
      }
      return targetLogs;
    }

    /**
     * event LicenseTokensMinted for contract LicensingModule
     */
  }, {
    key: "watchLicenseTokensMintedEvent",
    value: function watchLicenseTokensMintedEvent(_onLogs18) {
      return this.rpcClient.watchContractEvent({
        abi: licensingModuleAbi,
        address: this.address,
        eventName: "LicenseTokensMinted",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs18(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event LicenseTokensMinted for contract LicensingModule
     */
  }, {
    key: "parseTxLicenseTokensMintedEvent",
    value: function parseTxLicenseTokensMintedEvent(txReceipt) {
      var targetLogs = [];
      var _iterator18 = _createForOfIteratorHelper(txReceipt.logs),
        _step18;
      try {
        for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {
          var log = _step18.value;
          try {
            var event = viem.decodeEventLog({
              abi: licensingModuleAbi,
              eventName: "LicenseTokensMinted",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "LicenseTokensMinted") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator18.e(err);
      } finally {
        _iterator18.f();
      }
      return targetLogs;
    }
  }]);
}();

/**
 * contract LicensingModule write method
 */
var LicensingModuleClient = /*#__PURE__*/function (_LicensingModuleEvent) {
  function LicensingModuleClient(rpcClient, wallet, address) {
    var _this7;
    _classCallCheck(this, LicensingModuleClient);
    _this7 = _callSuper(this, LicensingModuleClient, [rpcClient, address]);
    _this7.wallet = wallet;
    return _this7;
  }

  /**
   * method attachLicenseTerms for contract LicensingModule
   *
   * @param request LicensingModuleAttachLicenseTermsRequest
   * @return Promise<WriteContractReturnType>
   */
  _inherits(LicensingModuleClient, _LicensingModuleEvent);
  return _createClass(LicensingModuleClient, [{
    key: "attachLicenseTerms",
    value: (function () {
      var _attachLicenseTerms = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee53(request) {
        var _yield$this$rpcClient23, call;
        return _regeneratorRuntime().wrap(function _callee53$(_context53) {
          while (1) switch (_context53.prev = _context53.next) {
            case 0:
              _context53.next = 2;
              return this.rpcClient.simulateContract({
                abi: licensingModuleAbi,
                address: this.address,
                functionName: "attachLicenseTerms",
                account: this.wallet.account,
                args: [request.ipId, request.licenseTemplate, request.licenseTermsId]
              });
            case 2:
              _yield$this$rpcClient23 = _context53.sent;
              call = _yield$this$rpcClient23.request;
              _context53.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context53.abrupt("return", _context53.sent);
            case 7:
            case "end":
              return _context53.stop();
          }
        }, _callee53, this);
      }));
      function attachLicenseTerms(_x42) {
        return _attachLicenseTerms.apply(this, arguments);
      }
      return attachLicenseTerms;
    }()
    /**
     * method mintLicenseTokens for contract LicensingModule
     *
     * @param request LicensingModuleMintLicenseTokensRequest
     * @return Promise<WriteContractReturnType>
     */
    )
  }, {
    key: "mintLicenseTokens",
    value: (function () {
      var _mintLicenseTokens = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee54(request) {
        var _yield$this$rpcClient24, call;
        return _regeneratorRuntime().wrap(function _callee54$(_context54) {
          while (1) switch (_context54.prev = _context54.next) {
            case 0:
              _context54.next = 2;
              return this.rpcClient.simulateContract({
                abi: licensingModuleAbi,
                address: this.address,
                functionName: "mintLicenseTokens",
                account: this.wallet.account,
                args: [request.licensorIpId, request.licenseTemplate, request.licenseTermsId, request.amount, request.receiver, request.royaltyContext]
              });
            case 2:
              _yield$this$rpcClient24 = _context54.sent;
              call = _yield$this$rpcClient24.request;
              _context54.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context54.abrupt("return", _context54.sent);
            case 7:
            case "end":
              return _context54.stop();
          }
        }, _callee54, this);
      }));
      function mintLicenseTokens(_x43) {
        return _mintLicenseTokens.apply(this, arguments);
      }
      return mintLicenseTokens;
    }()
    /**
     * method registerDerivative for contract LicensingModule
     *
     * @param request LicensingModuleRegisterDerivativeRequest
     * @return Promise<WriteContractReturnType>
     */
    )
  }, {
    key: "registerDerivative",
    value: (function () {
      var _registerDerivative = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee55(request) {
        var _yield$this$rpcClient25, call;
        return _regeneratorRuntime().wrap(function _callee55$(_context55) {
          while (1) switch (_context55.prev = _context55.next) {
            case 0:
              _context55.next = 2;
              return this.rpcClient.simulateContract({
                abi: licensingModuleAbi,
                address: this.address,
                functionName: "registerDerivative",
                account: this.wallet.account,
                args: [request.childIpId, request.parentIpIds, request.licenseTermsIds, request.licenseTemplate, request.royaltyContext]
              });
            case 2:
              _yield$this$rpcClient25 = _context55.sent;
              call = _yield$this$rpcClient25.request;
              _context55.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context55.abrupt("return", _context55.sent);
            case 7:
            case "end":
              return _context55.stop();
          }
        }, _callee55, this);
      }));
      function registerDerivative(_x44) {
        return _registerDerivative.apply(this, arguments);
      }
      return registerDerivative;
    }()
    /**
     * method registerDerivativeWithLicenseTokens for contract LicensingModule
     *
     * @param request LicensingModuleRegisterDerivativeWithLicenseTokensRequest
     * @return Promise<WriteContractReturnType>
     */
    )
  }, {
    key: "registerDerivativeWithLicenseTokens",
    value: (function () {
      var _registerDerivativeWithLicenseTokens = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee56(request) {
        var _yield$this$rpcClient26, call;
        return _regeneratorRuntime().wrap(function _callee56$(_context56) {
          while (1) switch (_context56.prev = _context56.next) {
            case 0:
              _context56.next = 2;
              return this.rpcClient.simulateContract({
                abi: licensingModuleAbi,
                address: this.address,
                functionName: "registerDerivativeWithLicenseTokens",
                account: this.wallet.account,
                args: [request.childIpId, request.licenseTokenIds, request.royaltyContext]
              });
            case 2:
              _yield$this$rpcClient26 = _context56.sent;
              call = _yield$this$rpcClient26.request;
              _context56.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context56.abrupt("return", _context56.sent);
            case 7:
            case "end":
              return _context56.stop();
          }
        }, _callee56, this);
      }));
      function registerDerivativeWithLicenseTokens(_x45) {
        return _registerDerivativeWithLicenseTokens.apply(this, arguments);
      }
      return registerDerivativeWithLicenseTokens;
    }())
  }]);
}(LicensingModuleEventClient);

// Contract PILicenseTemplate =============================================================

/**
 * PiLicenseTemplateAuthorityUpdatedEvent
 *
 * @param authority address
 */

/**
 * PiLicenseTemplateDerivativeApprovedEvent
 *
 * @param licenseTermsId uint256
 * @param ipId address
 * @param caller address
 * @param approved bool
 */

/**
 * PiLicenseTemplateInitializedEvent
 *
 * @param version uint64
 */

/**
 * PiLicenseTemplateLicenseTermsRegisteredEvent
 *
 * @param licenseTermsId uint256
 * @param licenseTemplate address
 * @param licenseTerms bytes
 */

/**
 * PiLicenseTemplateUpgradedEvent
 *
 * @param implementation address
 */

/**
 * PiLicenseTemplateExistsRequest
 *
 * @param licenseTermsId uint256
 */

/**
 * PiLicenseTemplateGetEarlierExpireTimeRequest
 *
 * @param licenseTermsIds uint256[]
 * @param start uint256
 */

/**
 * PiLicenseTemplateGetExpireTimeRequest
 *
 * @param licenseTermsId uint256
 * @param start uint256
 */

/**
 * PiLicenseTemplateGetLicenseTermsRequest
 *
 * @param selectedLicenseTermsId uint256
 */

/**
 * PiLicenseTemplateGetLicenseTermsResponse
 *
 * @param terms tuple
 */

/**
 * PiLicenseTemplateGetLicenseTermsIdRequest
 *
 * @param terms tuple
 */

/**
 * PiLicenseTemplateGetLicenseTermsIdResponse
 *
 * @param selectedLicenseTermsId uint256
 */

/**
 * PiLicenseTemplateGetLicenseTermsUriRequest
 *
 * @param licenseTermsId uint256
 */

/**
 * PiLicenseTemplateGetRoyaltyPolicyRequest
 *
 * @param licenseTermsId uint256
 */

/**
 * PiLicenseTemplateGetRoyaltyPolicyResponse
 *
 * @param royaltyPolicy address
 * @param royaltyData bytes
 * @param mintingFee uint256
 * @param currency address
 */

/**
 * PiLicenseTemplateIsDerivativeApprovedRequest
 *
 * @param parentIpId address
 * @param licenseTermsId uint256
 * @param childIpId address
 */

/**
 * PiLicenseTemplateIsLicenseTransferableRequest
 *
 * @param licenseTermsId uint256
 */

/**
 * PiLicenseTemplateSupportsInterfaceRequest
 *
 * @param interfaceId bytes4
 */

/**
 * PiLicenseTemplateToJsonRequest
 *
 * @param licenseTermsId uint256
 */

/**
 * PiLicenseTemplateVerifyCompatibleLicensesRequest
 *
 * @param licenseTermsIds uint256[]
 */

/**
 * PiLicenseTemplateInitializeRequest
 *
 * @param accessManager address
 * @param name string
 * @param metadataURI string
 */

/**
 * PiLicenseTemplateRegisterLicenseTermsRequest
 *
 * @param terms tuple
 */

/**
 * PiLicenseTemplateSetApprovalRequest
 *
 * @param parentIpId address
 * @param licenseTermsId uint256
 * @param childIpId address
 * @param approved bool
 */

/**
 * PiLicenseTemplateSetAuthorityRequest
 *
 * @param newAuthority address
 */

/**
 * PiLicenseTemplateUpgradeToAndCallRequest
 *
 * @param newImplementation address
 * @param data bytes
 */

/**
 * PiLicenseTemplateVerifyMintLicenseTokenRequest
 *
 * @param 0 uint256
 * @param 1 address
 * @param 2 address
 * @param 3 uint256
 */

/**
 * PiLicenseTemplateVerifyRegisterDerivativeRequest
 *
 * @param childIpId address
 * @param parentIpId address
 * @param licenseTermsId uint256
 * @param licensee address
 */

/**
 * PiLicenseTemplateVerifyRegisterDerivativeForAllParentsRequest
 *
 * @param childIpId address
 * @param parentIpIds address[]
 * @param licenseTermsIds uint256[]
 * @param childIpOwner address
 */

/**
 * contract PILicenseTemplate event
 */
var PiLicenseTemplateEventClient = /*#__PURE__*/function () {
  function PiLicenseTemplateEventClient(rpcClient, address) {
    var _rpcClient$chain11;
    _classCallCheck(this, PiLicenseTemplateEventClient);
    this.address = address || getAddress(piLicenseTemplateAddress, (_rpcClient$chain11 = rpcClient.chain) === null || _rpcClient$chain11 === void 0 ? void 0 : _rpcClient$chain11.id);
    this.rpcClient = rpcClient;
  }

  /**
   * event AuthorityUpdated for contract PILicenseTemplate
   */
  return _createClass(PiLicenseTemplateEventClient, [{
    key: "watchAuthorityUpdatedEvent",
    value: function watchAuthorityUpdatedEvent(_onLogs19) {
      return this.rpcClient.watchContractEvent({
        abi: piLicenseTemplateAbi,
        address: this.address,
        eventName: "AuthorityUpdated",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs19(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event AuthorityUpdated for contract PILicenseTemplate
     */
  }, {
    key: "parseTxAuthorityUpdatedEvent",
    value: function parseTxAuthorityUpdatedEvent(txReceipt) {
      var targetLogs = [];
      var _iterator19 = _createForOfIteratorHelper(txReceipt.logs),
        _step19;
      try {
        for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {
          var log = _step19.value;
          try {
            var event = viem.decodeEventLog({
              abi: piLicenseTemplateAbi,
              eventName: "AuthorityUpdated",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "AuthorityUpdated") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator19.e(err);
      } finally {
        _iterator19.f();
      }
      return targetLogs;
    }

    /**
     * event DerivativeApproved for contract PILicenseTemplate
     */
  }, {
    key: "watchDerivativeApprovedEvent",
    value: function watchDerivativeApprovedEvent(_onLogs20) {
      return this.rpcClient.watchContractEvent({
        abi: piLicenseTemplateAbi,
        address: this.address,
        eventName: "DerivativeApproved",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs20(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event DerivativeApproved for contract PILicenseTemplate
     */
  }, {
    key: "parseTxDerivativeApprovedEvent",
    value: function parseTxDerivativeApprovedEvent(txReceipt) {
      var targetLogs = [];
      var _iterator20 = _createForOfIteratorHelper(txReceipt.logs),
        _step20;
      try {
        for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {
          var log = _step20.value;
          try {
            var event = viem.decodeEventLog({
              abi: piLicenseTemplateAbi,
              eventName: "DerivativeApproved",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "DerivativeApproved") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator20.e(err);
      } finally {
        _iterator20.f();
      }
      return targetLogs;
    }

    /**
     * event Initialized for contract PILicenseTemplate
     */
  }, {
    key: "watchInitializedEvent",
    value: function watchInitializedEvent(_onLogs21) {
      return this.rpcClient.watchContractEvent({
        abi: piLicenseTemplateAbi,
        address: this.address,
        eventName: "Initialized",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs21(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event Initialized for contract PILicenseTemplate
     */
  }, {
    key: "parseTxInitializedEvent",
    value: function parseTxInitializedEvent(txReceipt) {
      var targetLogs = [];
      var _iterator21 = _createForOfIteratorHelper(txReceipt.logs),
        _step21;
      try {
        for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {
          var log = _step21.value;
          try {
            var event = viem.decodeEventLog({
              abi: piLicenseTemplateAbi,
              eventName: "Initialized",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "Initialized") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator21.e(err);
      } finally {
        _iterator21.f();
      }
      return targetLogs;
    }

    /**
     * event LicenseTermsRegistered for contract PILicenseTemplate
     */
  }, {
    key: "watchLicenseTermsRegisteredEvent",
    value: function watchLicenseTermsRegisteredEvent(_onLogs22) {
      return this.rpcClient.watchContractEvent({
        abi: piLicenseTemplateAbi,
        address: this.address,
        eventName: "LicenseTermsRegistered",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs22(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event LicenseTermsRegistered for contract PILicenseTemplate
     */
  }, {
    key: "parseTxLicenseTermsRegisteredEvent",
    value: function parseTxLicenseTermsRegisteredEvent(txReceipt) {
      var targetLogs = [];
      var _iterator22 = _createForOfIteratorHelper(txReceipt.logs),
        _step22;
      try {
        for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {
          var log = _step22.value;
          try {
            var event = viem.decodeEventLog({
              abi: piLicenseTemplateAbi,
              eventName: "LicenseTermsRegistered",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "LicenseTermsRegistered") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator22.e(err);
      } finally {
        _iterator22.f();
      }
      return targetLogs;
    }

    /**
     * event Upgraded for contract PILicenseTemplate
     */
  }, {
    key: "watchUpgradedEvent",
    value: function watchUpgradedEvent(_onLogs23) {
      return this.rpcClient.watchContractEvent({
        abi: piLicenseTemplateAbi,
        address: this.address,
        eventName: "Upgraded",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs23(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event Upgraded for contract PILicenseTemplate
     */
  }, {
    key: "parseTxUpgradedEvent",
    value: function parseTxUpgradedEvent(txReceipt) {
      var targetLogs = [];
      var _iterator23 = _createForOfIteratorHelper(txReceipt.logs),
        _step23;
      try {
        for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {
          var log = _step23.value;
          try {
            var event = viem.decodeEventLog({
              abi: piLicenseTemplateAbi,
              eventName: "Upgraded",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "Upgraded") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator23.e(err);
      } finally {
        _iterator23.f();
      }
      return targetLogs;
    }
  }]);
}();

/**
 * contract PILicenseTemplate readonly method
 */
var PiLicenseTemplateReadOnlyClient = /*#__PURE__*/function (_PiLicenseTemplateEve) {
  function PiLicenseTemplateReadOnlyClient(rpcClient, address) {
    _classCallCheck(this, PiLicenseTemplateReadOnlyClient);
    return _callSuper(this, PiLicenseTemplateReadOnlyClient, [rpcClient, address]);
  }

  /**
   * method ACCESS_CONTROLLER for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateAccessControllerRequest
   * @return Promise<PiLicenseTemplateAccessControllerResponse>
   */
  _inherits(PiLicenseTemplateReadOnlyClient, _PiLicenseTemplateEve);
  return _createClass(PiLicenseTemplateReadOnlyClient, [{
    key: "accessController",
    value: (function () {
      var _accessController = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee58() {
        return _regeneratorRuntime().wrap(function _callee58$(_context58) {
          while (1) switch (_context58.prev = _context58.next) {
            case 0:
              _context58.next = 2;
              return this.rpcClient.readContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "ACCESS_CONTROLLER"
              });
            case 2:
              return _context58.abrupt("return", _context58.sent);
            case 3:
            case "end":
              return _context58.stop();
          }
        }, _callee58, this);
      }));
      function accessController() {
        return _accessController.apply(this, arguments);
      }
      return accessController;
    }()
    /**
     * method IP_ACCOUNT_REGISTRY for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateIpAccountRegistryRequest
     * @return Promise<PiLicenseTemplateIpAccountRegistryResponse>
     */
    )
  }, {
    key: "ipAccountRegistry",
    value: (function () {
      var _ipAccountRegistry = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee59() {
        return _regeneratorRuntime().wrap(function _callee59$(_context59) {
          while (1) switch (_context59.prev = _context59.next) {
            case 0:
              _context59.next = 2;
              return this.rpcClient.readContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "IP_ACCOUNT_REGISTRY"
              });
            case 2:
              return _context59.abrupt("return", _context59.sent);
            case 3:
            case "end":
              return _context59.stop();
          }
        }, _callee59, this);
      }));
      function ipAccountRegistry() {
        return _ipAccountRegistry.apply(this, arguments);
      }
      return ipAccountRegistry;
    }()
    /**
     * method LICENSE_REGISTRY for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateLicenseRegistryRequest
     * @return Promise<PiLicenseTemplateLicenseRegistryResponse>
     */
    )
  }, {
    key: "licenseRegistry",
    value: (function () {
      var _licenseRegistry = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee60() {
        return _regeneratorRuntime().wrap(function _callee60$(_context60) {
          while (1) switch (_context60.prev = _context60.next) {
            case 0:
              _context60.next = 2;
              return this.rpcClient.readContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "LICENSE_REGISTRY"
              });
            case 2:
              return _context60.abrupt("return", _context60.sent);
            case 3:
            case "end":
              return _context60.stop();
          }
        }, _callee60, this);
      }));
      function licenseRegistry() {
        return _licenseRegistry.apply(this, arguments);
      }
      return licenseRegistry;
    }()
    /**
     * method ROYALTY_MODULE for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateRoyaltyModuleRequest
     * @return Promise<PiLicenseTemplateRoyaltyModuleResponse>
     */
    )
  }, {
    key: "royaltyModule",
    value: (function () {
      var _royaltyModule = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee61() {
        return _regeneratorRuntime().wrap(function _callee61$(_context61) {
          while (1) switch (_context61.prev = _context61.next) {
            case 0:
              _context61.next = 2;
              return this.rpcClient.readContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "ROYALTY_MODULE"
              });
            case 2:
              return _context61.abrupt("return", _context61.sent);
            case 3:
            case "end":
              return _context61.stop();
          }
        }, _callee61, this);
      }));
      function royaltyModule() {
        return _royaltyModule.apply(this, arguments);
      }
      return royaltyModule;
    }()
    /**
     * method UPGRADE_INTERFACE_VERSION for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateUpgradeInterfaceVersionRequest
     * @return Promise<PiLicenseTemplateUpgradeInterfaceVersionResponse>
     */
    )
  }, {
    key: "upgradeInterfaceVersion",
    value: (function () {
      var _upgradeInterfaceVersion2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee62() {
        return _regeneratorRuntime().wrap(function _callee62$(_context62) {
          while (1) switch (_context62.prev = _context62.next) {
            case 0:
              _context62.next = 2;
              return this.rpcClient.readContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "UPGRADE_INTERFACE_VERSION"
              });
            case 2:
              return _context62.abrupt("return", _context62.sent);
            case 3:
            case "end":
              return _context62.stop();
          }
        }, _callee62, this);
      }));
      function upgradeInterfaceVersion() {
        return _upgradeInterfaceVersion2.apply(this, arguments);
      }
      return upgradeInterfaceVersion;
    }()
    /**
     * method authority for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateAuthorityRequest
     * @return Promise<PiLicenseTemplateAuthorityResponse>
     */
    )
  }, {
    key: "authority",
    value: (function () {
      var _authority2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee63() {
        return _regeneratorRuntime().wrap(function _callee63$(_context63) {
          while (1) switch (_context63.prev = _context63.next) {
            case 0:
              _context63.next = 2;
              return this.rpcClient.readContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "authority"
              });
            case 2:
              return _context63.abrupt("return", _context63.sent);
            case 3:
            case "end":
              return _context63.stop();
          }
        }, _callee63, this);
      }));
      function authority() {
        return _authority2.apply(this, arguments);
      }
      return authority;
    }()
    /**
     * method exists for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateExistsRequest
     * @return Promise<PiLicenseTemplateExistsResponse>
     */
    )
  }, {
    key: "exists",
    value: (function () {
      var _exists2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee64(request) {
        return _regeneratorRuntime().wrap(function _callee64$(_context64) {
          while (1) switch (_context64.prev = _context64.next) {
            case 0:
              _context64.next = 2;
              return this.rpcClient.readContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "exists",
                args: [request.licenseTermsId]
              });
            case 2:
              return _context64.abrupt("return", _context64.sent);
            case 3:
            case "end":
              return _context64.stop();
          }
        }, _callee64, this);
      }));
      function exists(_x47) {
        return _exists2.apply(this, arguments);
      }
      return exists;
    }()
    /**
     * method getEarlierExpireTime for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateGetEarlierExpireTimeRequest
     * @return Promise<PiLicenseTemplateGetEarlierExpireTimeResponse>
     */
    )
  }, {
    key: "getEarlierExpireTime",
    value: (function () {
      var _getEarlierExpireTime = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee65(request) {
        return _regeneratorRuntime().wrap(function _callee65$(_context65) {
          while (1) switch (_context65.prev = _context65.next) {
            case 0:
              _context65.next = 2;
              return this.rpcClient.readContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "getEarlierExpireTime",
                args: [request.licenseTermsIds, request.start]
              });
            case 2:
              return _context65.abrupt("return", _context65.sent);
            case 3:
            case "end":
              return _context65.stop();
          }
        }, _callee65, this);
      }));
      function getEarlierExpireTime(_x48) {
        return _getEarlierExpireTime.apply(this, arguments);
      }
      return getEarlierExpireTime;
    }()
    /**
     * method getExpireTime for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateGetExpireTimeRequest
     * @return Promise<PiLicenseTemplateGetExpireTimeResponse>
     */
    )
  }, {
    key: "getExpireTime",
    value: (function () {
      var _getExpireTime2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee66(request) {
        return _regeneratorRuntime().wrap(function _callee66$(_context66) {
          while (1) switch (_context66.prev = _context66.next) {
            case 0:
              _context66.next = 2;
              return this.rpcClient.readContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "getExpireTime",
                args: [request.licenseTermsId, request.start]
              });
            case 2:
              return _context66.abrupt("return", _context66.sent);
            case 3:
            case "end":
              return _context66.stop();
          }
        }, _callee66, this);
      }));
      function getExpireTime(_x49) {
        return _getExpireTime2.apply(this, arguments);
      }
      return getExpireTime;
    }()
    /**
     * method getLicenseTerms for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateGetLicenseTermsRequest
     * @return Promise<PiLicenseTemplateGetLicenseTermsResponse>
     */
    )
  }, {
    key: "getLicenseTerms",
    value: (function () {
      var _getLicenseTerms = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee67(request) {
        var result;
        return _regeneratorRuntime().wrap(function _callee67$(_context67) {
          while (1) switch (_context67.prev = _context67.next) {
            case 0:
              _context67.next = 2;
              return this.rpcClient.readContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "getLicenseTerms",
                args: [request.selectedLicenseTermsId]
              });
            case 2:
              result = _context67.sent;
              return _context67.abrupt("return", {
                terms: result
              });
            case 4:
            case "end":
              return _context67.stop();
          }
        }, _callee67, this);
      }));
      function getLicenseTerms(_x50) {
        return _getLicenseTerms.apply(this, arguments);
      }
      return getLicenseTerms;
    }()
    /**
     * method getLicenseTermsId for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateGetLicenseTermsIdRequest
     * @return Promise<PiLicenseTemplateGetLicenseTermsIdResponse>
     */
    )
  }, {
    key: "getLicenseTermsId",
    value: (function () {
      var _getLicenseTermsId = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee68(request) {
        var result;
        return _regeneratorRuntime().wrap(function _callee68$(_context68) {
          while (1) switch (_context68.prev = _context68.next) {
            case 0:
              _context68.next = 2;
              return this.rpcClient.readContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "getLicenseTermsId",
                args: [request.terms]
              });
            case 2:
              result = _context68.sent;
              return _context68.abrupt("return", {
                selectedLicenseTermsId: result
              });
            case 4:
            case "end":
              return _context68.stop();
          }
        }, _callee68, this);
      }));
      function getLicenseTermsId(_x51) {
        return _getLicenseTermsId.apply(this, arguments);
      }
      return getLicenseTermsId;
    }()
    /**
     * method getLicenseTermsURI for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateGetLicenseTermsUriRequest
     * @return Promise<PiLicenseTemplateGetLicenseTermsUriResponse>
     */
    )
  }, {
    key: "getLicenseTermsUri",
    value: (function () {
      var _getLicenseTermsUri = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee69(request) {
        return _regeneratorRuntime().wrap(function _callee69$(_context69) {
          while (1) switch (_context69.prev = _context69.next) {
            case 0:
              _context69.next = 2;
              return this.rpcClient.readContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "getLicenseTermsURI",
                args: [request.licenseTermsId]
              });
            case 2:
              return _context69.abrupt("return", _context69.sent);
            case 3:
            case "end":
              return _context69.stop();
          }
        }, _callee69, this);
      }));
      function getLicenseTermsUri(_x52) {
        return _getLicenseTermsUri.apply(this, arguments);
      }
      return getLicenseTermsUri;
    }()
    /**
     * method getMetadataURI for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateGetMetadataUriRequest
     * @return Promise<PiLicenseTemplateGetMetadataUriResponse>
     */
    )
  }, {
    key: "getMetadataUri",
    value: (function () {
      var _getMetadataUri = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee70() {
        return _regeneratorRuntime().wrap(function _callee70$(_context70) {
          while (1) switch (_context70.prev = _context70.next) {
            case 0:
              _context70.next = 2;
              return this.rpcClient.readContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "getMetadataURI"
              });
            case 2:
              return _context70.abrupt("return", _context70.sent);
            case 3:
            case "end":
              return _context70.stop();
          }
        }, _callee70, this);
      }));
      function getMetadataUri() {
        return _getMetadataUri.apply(this, arguments);
      }
      return getMetadataUri;
    }()
    /**
     * method getRoyaltyPolicy for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateGetRoyaltyPolicyRequest
     * @return Promise<PiLicenseTemplateGetRoyaltyPolicyResponse>
     */
    )
  }, {
    key: "getRoyaltyPolicy",
    value: (function () {
      var _getRoyaltyPolicy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee71(request) {
        var result;
        return _regeneratorRuntime().wrap(function _callee71$(_context71) {
          while (1) switch (_context71.prev = _context71.next) {
            case 0:
              _context71.next = 2;
              return this.rpcClient.readContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "getRoyaltyPolicy",
                args: [request.licenseTermsId]
              });
            case 2:
              result = _context71.sent;
              return _context71.abrupt("return", {
                royaltyPolicy: result[0],
                royaltyData: result[1],
                mintingFee: result[2],
                currency: result[3]
              });
            case 4:
            case "end":
              return _context71.stop();
          }
        }, _callee71, this);
      }));
      function getRoyaltyPolicy(_x53) {
        return _getRoyaltyPolicy.apply(this, arguments);
      }
      return getRoyaltyPolicy;
    }()
    /**
     * method isConsumingScheduledOp for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateIsConsumingScheduledOpRequest
     * @return Promise<PiLicenseTemplateIsConsumingScheduledOpResponse>
     */
    )
  }, {
    key: "isConsumingScheduledOp",
    value: (function () {
      var _isConsumingScheduledOp2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee72() {
        return _regeneratorRuntime().wrap(function _callee72$(_context72) {
          while (1) switch (_context72.prev = _context72.next) {
            case 0:
              _context72.next = 2;
              return this.rpcClient.readContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "isConsumingScheduledOp"
              });
            case 2:
              return _context72.abrupt("return", _context72.sent);
            case 3:
            case "end":
              return _context72.stop();
          }
        }, _callee72, this);
      }));
      function isConsumingScheduledOp() {
        return _isConsumingScheduledOp2.apply(this, arguments);
      }
      return isConsumingScheduledOp;
    }()
    /**
     * method isDerivativeApproved for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateIsDerivativeApprovedRequest
     * @return Promise<PiLicenseTemplateIsDerivativeApprovedResponse>
     */
    )
  }, {
    key: "isDerivativeApproved",
    value: (function () {
      var _isDerivativeApproved = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee73(request) {
        return _regeneratorRuntime().wrap(function _callee73$(_context73) {
          while (1) switch (_context73.prev = _context73.next) {
            case 0:
              _context73.next = 2;
              return this.rpcClient.readContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "isDerivativeApproved",
                args: [request.parentIpId, request.licenseTermsId, request.childIpId]
              });
            case 2:
              return _context73.abrupt("return", _context73.sent);
            case 3:
            case "end":
              return _context73.stop();
          }
        }, _callee73, this);
      }));
      function isDerivativeApproved(_x54) {
        return _isDerivativeApproved.apply(this, arguments);
      }
      return isDerivativeApproved;
    }()
    /**
     * method isLicenseTransferable for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateIsLicenseTransferableRequest
     * @return Promise<PiLicenseTemplateIsLicenseTransferableResponse>
     */
    )
  }, {
    key: "isLicenseTransferable",
    value: (function () {
      var _isLicenseTransferable = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee74(request) {
        return _regeneratorRuntime().wrap(function _callee74$(_context74) {
          while (1) switch (_context74.prev = _context74.next) {
            case 0:
              _context74.next = 2;
              return this.rpcClient.readContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "isLicenseTransferable",
                args: [request.licenseTermsId]
              });
            case 2:
              return _context74.abrupt("return", _context74.sent);
            case 3:
            case "end":
              return _context74.stop();
          }
        }, _callee74, this);
      }));
      function isLicenseTransferable(_x55) {
        return _isLicenseTransferable.apply(this, arguments);
      }
      return isLicenseTransferable;
    }()
    /**
     * method name for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateNameRequest
     * @return Promise<PiLicenseTemplateNameResponse>
     */
    )
  }, {
    key: "name",
    value: (function () {
      var _name = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee75() {
        return _regeneratorRuntime().wrap(function _callee75$(_context75) {
          while (1) switch (_context75.prev = _context75.next) {
            case 0:
              _context75.next = 2;
              return this.rpcClient.readContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "name"
              });
            case 2:
              return _context75.abrupt("return", _context75.sent);
            case 3:
            case "end":
              return _context75.stop();
          }
        }, _callee75, this);
      }));
      function name() {
        return _name.apply(this, arguments);
      }
      return name;
    }()
    /**
     * method proxiableUUID for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateProxiableUuidRequest
     * @return Promise<PiLicenseTemplateProxiableUuidResponse>
     */
    )
  }, {
    key: "proxiableUuid",
    value: (function () {
      var _proxiableUuid2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee76() {
        return _regeneratorRuntime().wrap(function _callee76$(_context76) {
          while (1) switch (_context76.prev = _context76.next) {
            case 0:
              _context76.next = 2;
              return this.rpcClient.readContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "proxiableUUID"
              });
            case 2:
              return _context76.abrupt("return", _context76.sent);
            case 3:
            case "end":
              return _context76.stop();
          }
        }, _callee76, this);
      }));
      function proxiableUuid() {
        return _proxiableUuid2.apply(this, arguments);
      }
      return proxiableUuid;
    }()
    /**
     * method supportsInterface for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateSupportsInterfaceRequest
     * @return Promise<PiLicenseTemplateSupportsInterfaceResponse>
     */
    )
  }, {
    key: "supportsInterface",
    value: (function () {
      var _supportsInterface = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee77(request) {
        return _regeneratorRuntime().wrap(function _callee77$(_context77) {
          while (1) switch (_context77.prev = _context77.next) {
            case 0:
              _context77.next = 2;
              return this.rpcClient.readContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "supportsInterface",
                args: [request.interfaceId]
              });
            case 2:
              return _context77.abrupt("return", _context77.sent);
            case 3:
            case "end":
              return _context77.stop();
          }
        }, _callee77, this);
      }));
      function supportsInterface(_x56) {
        return _supportsInterface.apply(this, arguments);
      }
      return supportsInterface;
    }()
    /**
     * method toJson for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateToJsonRequest
     * @return Promise<PiLicenseTemplateToJsonResponse>
     */
    )
  }, {
    key: "toJson",
    value: (function () {
      var _toJson = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee78(request) {
        return _regeneratorRuntime().wrap(function _callee78$(_context78) {
          while (1) switch (_context78.prev = _context78.next) {
            case 0:
              _context78.next = 2;
              return this.rpcClient.readContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "toJson",
                args: [request.licenseTermsId]
              });
            case 2:
              return _context78.abrupt("return", _context78.sent);
            case 3:
            case "end":
              return _context78.stop();
          }
        }, _callee78, this);
      }));
      function toJson(_x57) {
        return _toJson.apply(this, arguments);
      }
      return toJson;
    }()
    /**
     * method totalRegisteredLicenseTerms for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateTotalRegisteredLicenseTermsRequest
     * @return Promise<PiLicenseTemplateTotalRegisteredLicenseTermsResponse>
     */
    )
  }, {
    key: "totalRegisteredLicenseTerms",
    value: (function () {
      var _totalRegisteredLicenseTerms = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee79() {
        return _regeneratorRuntime().wrap(function _callee79$(_context79) {
          while (1) switch (_context79.prev = _context79.next) {
            case 0:
              _context79.next = 2;
              return this.rpcClient.readContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "totalRegisteredLicenseTerms"
              });
            case 2:
              return _context79.abrupt("return", _context79.sent);
            case 3:
            case "end":
              return _context79.stop();
          }
        }, _callee79, this);
      }));
      function totalRegisteredLicenseTerms() {
        return _totalRegisteredLicenseTerms.apply(this, arguments);
      }
      return totalRegisteredLicenseTerms;
    }()
    /**
     * method verifyCompatibleLicenses for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateVerifyCompatibleLicensesRequest
     * @return Promise<PiLicenseTemplateVerifyCompatibleLicensesResponse>
     */
    )
  }, {
    key: "verifyCompatibleLicenses",
    value: (function () {
      var _verifyCompatibleLicenses = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee80(request) {
        return _regeneratorRuntime().wrap(function _callee80$(_context80) {
          while (1) switch (_context80.prev = _context80.next) {
            case 0:
              _context80.next = 2;
              return this.rpcClient.readContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "verifyCompatibleLicenses",
                args: [request.licenseTermsIds]
              });
            case 2:
              return _context80.abrupt("return", _context80.sent);
            case 3:
            case "end":
              return _context80.stop();
          }
        }, _callee80, this);
      }));
      function verifyCompatibleLicenses(_x58) {
        return _verifyCompatibleLicenses.apply(this, arguments);
      }
      return verifyCompatibleLicenses;
    }())
  }]);
}(PiLicenseTemplateEventClient);

/**
 * contract PILicenseTemplate write method
 */
var PiLicenseTemplateClient = /*#__PURE__*/function (_PiLicenseTemplateRea) {
  function PiLicenseTemplateClient(rpcClient, wallet, address) {
    var _this8;
    _classCallCheck(this, PiLicenseTemplateClient);
    _this8 = _callSuper(this, PiLicenseTemplateClient, [rpcClient, address]);
    _this8.wallet = wallet;
    return _this8;
  }

  /**
   * method initialize for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateInitializeRequest
   * @return Promise<WriteContractReturnType>
   */
  _inherits(PiLicenseTemplateClient, _PiLicenseTemplateRea);
  return _createClass(PiLicenseTemplateClient, [{
    key: "initialize",
    value: (function () {
      var _initialize2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee81(request) {
        var _yield$this$rpcClient27, call;
        return _regeneratorRuntime().wrap(function _callee81$(_context81) {
          while (1) switch (_context81.prev = _context81.next) {
            case 0:
              _context81.next = 2;
              return this.rpcClient.simulateContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "initialize",
                account: this.wallet.account,
                args: [request.accessManager, request.name, request.metadataURI]
              });
            case 2:
              _yield$this$rpcClient27 = _context81.sent;
              call = _yield$this$rpcClient27.request;
              _context81.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context81.abrupt("return", _context81.sent);
            case 7:
            case "end":
              return _context81.stop();
          }
        }, _callee81, this);
      }));
      function initialize(_x59) {
        return _initialize2.apply(this, arguments);
      }
      return initialize;
    }()
    /**
     * method registerLicenseTerms for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateRegisterLicenseTermsRequest
     * @return Promise<WriteContractReturnType>
     */
    )
  }, {
    key: "registerLicenseTerms",
    value: (function () {
      var _registerLicenseTerms = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee82(request) {
        var _yield$this$rpcClient28, call;
        return _regeneratorRuntime().wrap(function _callee82$(_context82) {
          while (1) switch (_context82.prev = _context82.next) {
            case 0:
              _context82.next = 2;
              return this.rpcClient.simulateContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "registerLicenseTerms",
                account: this.wallet.account,
                args: [request.terms]
              });
            case 2:
              _yield$this$rpcClient28 = _context82.sent;
              call = _yield$this$rpcClient28.request;
              _context82.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context82.abrupt("return", _context82.sent);
            case 7:
            case "end":
              return _context82.stop();
          }
        }, _callee82, this);
      }));
      function registerLicenseTerms(_x60) {
        return _registerLicenseTerms.apply(this, arguments);
      }
      return registerLicenseTerms;
    }()
    /**
     * method setApproval for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateSetApprovalRequest
     * @return Promise<WriteContractReturnType>
     */
    )
  }, {
    key: "setApproval",
    value: (function () {
      var _setApproval = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee83(request) {
        var _yield$this$rpcClient29, call;
        return _regeneratorRuntime().wrap(function _callee83$(_context83) {
          while (1) switch (_context83.prev = _context83.next) {
            case 0:
              _context83.next = 2;
              return this.rpcClient.simulateContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "setApproval",
                account: this.wallet.account,
                args: [request.parentIpId, request.licenseTermsId, request.childIpId, request.approved]
              });
            case 2:
              _yield$this$rpcClient29 = _context83.sent;
              call = _yield$this$rpcClient29.request;
              _context83.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context83.abrupt("return", _context83.sent);
            case 7:
            case "end":
              return _context83.stop();
          }
        }, _callee83, this);
      }));
      function setApproval(_x61) {
        return _setApproval.apply(this, arguments);
      }
      return setApproval;
    }()
    /**
     * method setAuthority for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateSetAuthorityRequest
     * @return Promise<WriteContractReturnType>
     */
    )
  }, {
    key: "setAuthority",
    value: (function () {
      var _setAuthority2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee84(request) {
        var _yield$this$rpcClient30, call;
        return _regeneratorRuntime().wrap(function _callee84$(_context84) {
          while (1) switch (_context84.prev = _context84.next) {
            case 0:
              _context84.next = 2;
              return this.rpcClient.simulateContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "setAuthority",
                account: this.wallet.account,
                args: [request.newAuthority]
              });
            case 2:
              _yield$this$rpcClient30 = _context84.sent;
              call = _yield$this$rpcClient30.request;
              _context84.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context84.abrupt("return", _context84.sent);
            case 7:
            case "end":
              return _context84.stop();
          }
        }, _callee84, this);
      }));
      function setAuthority(_x62) {
        return _setAuthority2.apply(this, arguments);
      }
      return setAuthority;
    }()
    /**
     * method upgradeToAndCall for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateUpgradeToAndCallRequest
     * @return Promise<WriteContractReturnType>
     */
    )
  }, {
    key: "upgradeToAndCall",
    value: (function () {
      var _upgradeToAndCall2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee85(request) {
        var _yield$this$rpcClient31, call;
        return _regeneratorRuntime().wrap(function _callee85$(_context85) {
          while (1) switch (_context85.prev = _context85.next) {
            case 0:
              _context85.next = 2;
              return this.rpcClient.simulateContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "upgradeToAndCall",
                account: this.wallet.account,
                args: [request.newImplementation, request.data]
              });
            case 2:
              _yield$this$rpcClient31 = _context85.sent;
              call = _yield$this$rpcClient31.request;
              _context85.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context85.abrupt("return", _context85.sent);
            case 7:
            case "end":
              return _context85.stop();
          }
        }, _callee85, this);
      }));
      function upgradeToAndCall(_x63) {
        return _upgradeToAndCall2.apply(this, arguments);
      }
      return upgradeToAndCall;
    }()
    /**
     * method verifyMintLicenseToken for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateVerifyMintLicenseTokenRequest
     * @return Promise<WriteContractReturnType>
     */
    )
  }, {
    key: "verifyMintLicenseToken",
    value: (function () {
      var _verifyMintLicenseToken2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee86(request) {
        var _yield$this$rpcClient32, call;
        return _regeneratorRuntime().wrap(function _callee86$(_context86) {
          while (1) switch (_context86.prev = _context86.next) {
            case 0:
              _context86.next = 2;
              return this.rpcClient.simulateContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "verifyMintLicenseToken",
                account: this.wallet.account,
                args: [request[0], request[1], request[2], request[3]]
              });
            case 2:
              _yield$this$rpcClient32 = _context86.sent;
              call = _yield$this$rpcClient32.request;
              _context86.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context86.abrupt("return", _context86.sent);
            case 7:
            case "end":
              return _context86.stop();
          }
        }, _callee86, this);
      }));
      function verifyMintLicenseToken(_x64) {
        return _verifyMintLicenseToken2.apply(this, arguments);
      }
      return verifyMintLicenseToken;
    }()
    /**
     * method verifyRegisterDerivative for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateVerifyRegisterDerivativeRequest
     * @return Promise<WriteContractReturnType>
     */
    )
  }, {
    key: "verifyRegisterDerivative",
    value: (function () {
      var _verifyRegisterDerivative = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee87(request) {
        var _yield$this$rpcClient33, call;
        return _regeneratorRuntime().wrap(function _callee87$(_context87) {
          while (1) switch (_context87.prev = _context87.next) {
            case 0:
              _context87.next = 2;
              return this.rpcClient.simulateContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "verifyRegisterDerivative",
                account: this.wallet.account,
                args: [request.childIpId, request.parentIpId, request.licenseTermsId, request.licensee]
              });
            case 2:
              _yield$this$rpcClient33 = _context87.sent;
              call = _yield$this$rpcClient33.request;
              _context87.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context87.abrupt("return", _context87.sent);
            case 7:
            case "end":
              return _context87.stop();
          }
        }, _callee87, this);
      }));
      function verifyRegisterDerivative(_x65) {
        return _verifyRegisterDerivative.apply(this, arguments);
      }
      return verifyRegisterDerivative;
    }()
    /**
     * method verifyRegisterDerivativeForAllParents for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateVerifyRegisterDerivativeForAllParentsRequest
     * @return Promise<WriteContractReturnType>
     */
    )
  }, {
    key: "verifyRegisterDerivativeForAllParents",
    value: (function () {
      var _verifyRegisterDerivativeForAllParents = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee88(request) {
        var _yield$this$rpcClient34, call;
        return _regeneratorRuntime().wrap(function _callee88$(_context88) {
          while (1) switch (_context88.prev = _context88.next) {
            case 0:
              _context88.next = 2;
              return this.rpcClient.simulateContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "verifyRegisterDerivativeForAllParents",
                account: this.wallet.account,
                args: [request.childIpId, request.parentIpIds, request.licenseTermsIds, request.childIpOwner]
              });
            case 2:
              _yield$this$rpcClient34 = _context88.sent;
              call = _yield$this$rpcClient34.request;
              _context88.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context88.abrupt("return", _context88.sent);
            case 7:
            case "end":
              return _context88.stop();
          }
        }, _callee88, this);
      }));
      function verifyRegisterDerivativeForAllParents(_x66) {
        return _verifyRegisterDerivativeForAllParents.apply(this, arguments);
      }
      return verifyRegisterDerivativeForAllParents;
    }())
  }]);
}(PiLicenseTemplateReadOnlyClient);

// Contract RoyaltyModule =============================================================

/**
 * RoyaltyModulePayRoyaltyOnBehalfRequest
 *
 * @param receiverIpId address
 * @param payerIpId address
 * @param token address
 * @param amount uint256
 */

/**
 * contract RoyaltyModule write method
 */
var RoyaltyModuleClient = /*#__PURE__*/function () {
  function RoyaltyModuleClient(rpcClient, wallet, address) {
    var _rpcClient$chain12;
    _classCallCheck(this, RoyaltyModuleClient);
    this.address = address || getAddress(royaltyModuleAddress, (_rpcClient$chain12 = rpcClient.chain) === null || _rpcClient$chain12 === void 0 ? void 0 : _rpcClient$chain12.id);
    this.rpcClient = rpcClient;
    this.wallet = wallet;
  }

  /**
   * method payRoyaltyOnBehalf for contract RoyaltyModule
   *
   * @param request RoyaltyModulePayRoyaltyOnBehalfRequest
   * @return Promise<WriteContractReturnType>
   */
  return _createClass(RoyaltyModuleClient, [{
    key: "payRoyaltyOnBehalf",
    value: (function () {
      var _payRoyaltyOnBehalf = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee89(request) {
        var _yield$this$rpcClient35, call;
        return _regeneratorRuntime().wrap(function _callee89$(_context89) {
          while (1) switch (_context89.prev = _context89.next) {
            case 0:
              _context89.next = 2;
              return this.rpcClient.simulateContract({
                abi: royaltyModuleAbi,
                address: this.address,
                functionName: "payRoyaltyOnBehalf",
                account: this.wallet.account,
                args: [request.receiverIpId, request.payerIpId, request.token, request.amount]
              });
            case 2:
              _yield$this$rpcClient35 = _context89.sent;
              call = _yield$this$rpcClient35.request;
              _context89.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context89.abrupt("return", _context89.sent);
            case 7:
            case "end":
              return _context89.stop();
          }
        }, _callee89, this);
      }));
      function payRoyaltyOnBehalf(_x67) {
        return _payRoyaltyOnBehalf.apply(this, arguments);
      }
      return payRoyaltyOnBehalf;
    }())
  }]);
}();

// Contract RoyaltyPolicyLAP =============================================================

/**
 * RoyaltyPolicyLapGetRoyaltyDataRequest
 *
 * @param ipId address
 */

/**
 * RoyaltyPolicyLapGetRoyaltyDataResponse
 *
 * @param 0 bool
 * @param 1 address
 * @param 2 uint32
 * @param 3 address[]
 * @param 4 uint32[]
 */

/**
 * RoyaltyPolicyLapOnRoyaltyPaymentRequest
 *
 * @param caller address
 * @param ipId address
 * @param token address
 * @param amount uint256
 */

/**
 * contract RoyaltyPolicyLAP readonly method
 */
var RoyaltyPolicyLapReadOnlyClient = /*#__PURE__*/function () {
  function RoyaltyPolicyLapReadOnlyClient(rpcClient, address) {
    var _rpcClient$chain13;
    _classCallCheck(this, RoyaltyPolicyLapReadOnlyClient);
    this.address = address || getAddress(royaltyPolicyLapAddress, (_rpcClient$chain13 = rpcClient.chain) === null || _rpcClient$chain13 === void 0 ? void 0 : _rpcClient$chain13.id);
    this.rpcClient = rpcClient;
  }

  /**
   * method getRoyaltyData for contract RoyaltyPolicyLAP
   *
   * @param request RoyaltyPolicyLapGetRoyaltyDataRequest
   * @return Promise<RoyaltyPolicyLapGetRoyaltyDataResponse>
   */
  return _createClass(RoyaltyPolicyLapReadOnlyClient, [{
    key: "getRoyaltyData",
    value: (function () {
      var _getRoyaltyData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee90(request) {
        return _regeneratorRuntime().wrap(function _callee90$(_context90) {
          while (1) switch (_context90.prev = _context90.next) {
            case 0:
              _context90.next = 2;
              return this.rpcClient.readContract({
                abi: royaltyPolicyLapAbi,
                address: this.address,
                functionName: "getRoyaltyData",
                args: [request.ipId]
              });
            case 2:
              return _context90.abrupt("return", _context90.sent);
            case 3:
            case "end":
              return _context90.stop();
          }
        }, _callee90, this);
      }));
      function getRoyaltyData(_x68) {
        return _getRoyaltyData.apply(this, arguments);
      }
      return getRoyaltyData;
    }())
  }]);
}();

/**
 * contract RoyaltyPolicyLAP write method
 */
var RoyaltyPolicyLapClient = /*#__PURE__*/function (_RoyaltyPolicyLapRead) {
  function RoyaltyPolicyLapClient(rpcClient, wallet, address) {
    var _this9;
    _classCallCheck(this, RoyaltyPolicyLapClient);
    _this9 = _callSuper(this, RoyaltyPolicyLapClient, [rpcClient, address]);
    _this9.wallet = wallet;
    return _this9;
  }

  /**
   * method onRoyaltyPayment for contract RoyaltyPolicyLAP
   *
   * @param request RoyaltyPolicyLapOnRoyaltyPaymentRequest
   * @return Promise<WriteContractReturnType>
   */
  _inherits(RoyaltyPolicyLapClient, _RoyaltyPolicyLapRead);
  return _createClass(RoyaltyPolicyLapClient, [{
    key: "onRoyaltyPayment",
    value: (function () {
      var _onRoyaltyPayment = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee91(request) {
        var _yield$this$rpcClient36, call;
        return _regeneratorRuntime().wrap(function _callee91$(_context91) {
          while (1) switch (_context91.prev = _context91.next) {
            case 0:
              _context91.next = 2;
              return this.rpcClient.simulateContract({
                abi: royaltyPolicyLapAbi,
                address: this.address,
                functionName: "onRoyaltyPayment",
                account: this.wallet.account,
                args: [request.caller, request.ipId, request.token, request.amount]
              });
            case 2:
              _yield$this$rpcClient36 = _context91.sent;
              call = _yield$this$rpcClient36.request;
              _context91.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context91.abrupt("return", _context91.sent);
            case 7:
            case "end":
              return _context91.stop();
          }
        }, _callee91, this);
      }));
      function onRoyaltyPayment(_x69) {
        return _onRoyaltyPayment.apply(this, arguments);
      }
      return onRoyaltyPayment;
    }())
  }]);
}(RoyaltyPolicyLapReadOnlyClient);

// Contract SPG =============================================================

/**
 * SpgCollectionCreatedEvent
 *
 * @param nftContract address
 */

/**
 * SpgCreateCollectionRequest
 *
 * @param name string
 * @param symbol string
 * @param maxSupply uint32
 * @param mintCost uint256
 * @param mintToken address
 * @param owner address
 */

/**
 * SpgMintAndRegisterIpRequest
 *
 * @param nftContract address
 * @param recipient address
 * @param metadata tuple
 */

/**
 * SpgMintAndRegisterIpAndAttachPilTermsRequest
 *
 * @param nftContract address
 * @param recipient address
 * @param metadata tuple
 * @param terms tuple
 */

/**
 * SpgMintAndRegisterIpAndMakeDerivativeRequest
 *
 * @param nftContract address
 * @param derivData tuple
 * @param metadata tuple
 * @param recipient address
 */

/**
 * SpgMintAndRegisterIpAndMakeDerivativeWithLicenseTokensRequest
 *
 * @param nftContract address
 * @param licenseTokenIds uint256[]
 * @param royaltyContext bytes
 * @param metadata tuple
 * @param recipient address
 */

/**
 * SpgRegisterIpAndAttachPilTermsRequest
 *
 * @param nftContract address
 * @param tokenId uint256
 * @param metadata tuple
 * @param terms tuple
 * @param sigMetadata tuple
 * @param sigAttach tuple
 */

/**
 * SpgRegisterIpAndMakeDerivativeRequest
 *
 * @param nftContract address
 * @param tokenId uint256
 * @param derivData tuple
 * @param metadata tuple
 * @param sigMetadata tuple
 * @param sigRegister tuple
 */

/**
 * SpgRegisterIpAndMakeDerivativeWithLicenseTokensRequest
 *
 * @param nftContract address
 * @param tokenId uint256
 * @param licenseTokenIds uint256[]
 * @param royaltyContext bytes
 * @param metadata tuple
 * @param sigMetadata tuple
 * @param sigRegister tuple
 */

/**
 * SpgRegisterPilTermsAndAttachRequest
 *
 * @param ipId address
 * @param terms tuple
 */

/**
 * contract SPG event
 */
var SpgEventClient = /*#__PURE__*/function () {
  function SpgEventClient(rpcClient, address) {
    var _rpcClient$chain14;
    _classCallCheck(this, SpgEventClient);
    this.address = address || getAddress(spgAddress, (_rpcClient$chain14 = rpcClient.chain) === null || _rpcClient$chain14 === void 0 ? void 0 : _rpcClient$chain14.id);
    this.rpcClient = rpcClient;
  }

  /**
   * event CollectionCreated for contract SPG
   */
  return _createClass(SpgEventClient, [{
    key: "watchCollectionCreatedEvent",
    value: function watchCollectionCreatedEvent(_onLogs24) {
      return this.rpcClient.watchContractEvent({
        abi: spgAbi,
        address: this.address,
        eventName: "CollectionCreated",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs24(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event CollectionCreated for contract SPG
     */
  }, {
    key: "parseTxCollectionCreatedEvent",
    value: function parseTxCollectionCreatedEvent(txReceipt) {
      var targetLogs = [];
      var _iterator24 = _createForOfIteratorHelper(txReceipt.logs),
        _step24;
      try {
        for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {
          var log = _step24.value;
          try {
            var event = viem.decodeEventLog({
              abi: spgAbi,
              eventName: "CollectionCreated",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "CollectionCreated") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator24.e(err);
      } finally {
        _iterator24.f();
      }
      return targetLogs;
    }
  }]);
}();

/**
 * contract SPG write method
 */
var SpgClient = /*#__PURE__*/function (_SpgEventClient) {
  function SpgClient(rpcClient, wallet, address) {
    var _this10;
    _classCallCheck(this, SpgClient);
    _this10 = _callSuper(this, SpgClient, [rpcClient, address]);
    _this10.wallet = wallet;
    return _this10;
  }

  /**
   * method createCollection for contract SPG
   *
   * @param request SpgCreateCollectionRequest
   * @return Promise<WriteContractReturnType>
   */
  _inherits(SpgClient, _SpgEventClient);
  return _createClass(SpgClient, [{
    key: "createCollection",
    value: (function () {
      var _createCollection = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee92(request) {
        var _yield$this$rpcClient37, call;
        return _regeneratorRuntime().wrap(function _callee92$(_context92) {
          while (1) switch (_context92.prev = _context92.next) {
            case 0:
              _context92.next = 2;
              return this.rpcClient.simulateContract({
                abi: spgAbi,
                address: this.address,
                functionName: "createCollection",
                account: this.wallet.account,
                args: [request.name, request.symbol, request.maxSupply, request.mintCost, request.mintToken, request.owner]
              });
            case 2:
              _yield$this$rpcClient37 = _context92.sent;
              call = _yield$this$rpcClient37.request;
              _context92.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context92.abrupt("return", _context92.sent);
            case 7:
            case "end":
              return _context92.stop();
          }
        }, _callee92, this);
      }));
      function createCollection(_x70) {
        return _createCollection.apply(this, arguments);
      }
      return createCollection;
    }()
    /**
     * method mintAndRegisterIp for contract SPG
     *
     * @param request SpgMintAndRegisterIpRequest
     * @return Promise<WriteContractReturnType>
     */
    )
  }, {
    key: "mintAndRegisterIp",
    value: (function () {
      var _mintAndRegisterIp = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee93(request) {
        var _yield$this$rpcClient38, call;
        return _regeneratorRuntime().wrap(function _callee93$(_context93) {
          while (1) switch (_context93.prev = _context93.next) {
            case 0:
              _context93.next = 2;
              return this.rpcClient.simulateContract({
                abi: spgAbi,
                address: this.address,
                functionName: "mintAndRegisterIp",
                account: this.wallet.account,
                args: [request.nftContract, request.recipient, request.metadata]
              });
            case 2:
              _yield$this$rpcClient38 = _context93.sent;
              call = _yield$this$rpcClient38.request;
              _context93.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context93.abrupt("return", _context93.sent);
            case 7:
            case "end":
              return _context93.stop();
          }
        }, _callee93, this);
      }));
      function mintAndRegisterIp(_x71) {
        return _mintAndRegisterIp.apply(this, arguments);
      }
      return mintAndRegisterIp;
    }()
    /**
     * method mintAndRegisterIpAndAttachPILTerms for contract SPG
     *
     * @param request SpgMintAndRegisterIpAndAttachPilTermsRequest
     * @return Promise<WriteContractReturnType>
     */
    )
  }, {
    key: "mintAndRegisterIpAndAttachPilTerms",
    value: (function () {
      var _mintAndRegisterIpAndAttachPilTerms = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee94(request) {
        var _yield$this$rpcClient39, call;
        return _regeneratorRuntime().wrap(function _callee94$(_context94) {
          while (1) switch (_context94.prev = _context94.next) {
            case 0:
              _context94.next = 2;
              return this.rpcClient.simulateContract({
                abi: spgAbi,
                address: this.address,
                functionName: "mintAndRegisterIpAndAttachPILTerms",
                account: this.wallet.account,
                args: [request.nftContract, request.recipient, request.metadata, request.terms]
              });
            case 2:
              _yield$this$rpcClient39 = _context94.sent;
              call = _yield$this$rpcClient39.request;
              _context94.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context94.abrupt("return", _context94.sent);
            case 7:
            case "end":
              return _context94.stop();
          }
        }, _callee94, this);
      }));
      function mintAndRegisterIpAndAttachPilTerms(_x72) {
        return _mintAndRegisterIpAndAttachPilTerms.apply(this, arguments);
      }
      return mintAndRegisterIpAndAttachPilTerms;
    }()
    /**
     * method mintAndRegisterIpAndMakeDerivative for contract SPG
     *
     * @param request SpgMintAndRegisterIpAndMakeDerivativeRequest
     * @return Promise<WriteContractReturnType>
     */
    )
  }, {
    key: "mintAndRegisterIpAndMakeDerivative",
    value: (function () {
      var _mintAndRegisterIpAndMakeDerivative = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee95(request) {
        var _yield$this$rpcClient40, call;
        return _regeneratorRuntime().wrap(function _callee95$(_context95) {
          while (1) switch (_context95.prev = _context95.next) {
            case 0:
              _context95.next = 2;
              return this.rpcClient.simulateContract({
                abi: spgAbi,
                address: this.address,
                functionName: "mintAndRegisterIpAndMakeDerivative",
                account: this.wallet.account,
                args: [request.nftContract, request.derivData, request.metadata, request.recipient]
              });
            case 2:
              _yield$this$rpcClient40 = _context95.sent;
              call = _yield$this$rpcClient40.request;
              _context95.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context95.abrupt("return", _context95.sent);
            case 7:
            case "end":
              return _context95.stop();
          }
        }, _callee95, this);
      }));
      function mintAndRegisterIpAndMakeDerivative(_x73) {
        return _mintAndRegisterIpAndMakeDerivative.apply(this, arguments);
      }
      return mintAndRegisterIpAndMakeDerivative;
    }()
    /**
     * method mintAndRegisterIpAndMakeDerivativeWithLicenseTokens for contract SPG
     *
     * @param request SpgMintAndRegisterIpAndMakeDerivativeWithLicenseTokensRequest
     * @return Promise<WriteContractReturnType>
     */
    )
  }, {
    key: "mintAndRegisterIpAndMakeDerivativeWithLicenseTokens",
    value: (function () {
      var _mintAndRegisterIpAndMakeDerivativeWithLicenseTokens = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee96(request) {
        var _yield$this$rpcClient41, call;
        return _regeneratorRuntime().wrap(function _callee96$(_context96) {
          while (1) switch (_context96.prev = _context96.next) {
            case 0:
              _context96.next = 2;
              return this.rpcClient.simulateContract({
                abi: spgAbi,
                address: this.address,
                functionName: "mintAndRegisterIpAndMakeDerivativeWithLicenseTokens",
                account: this.wallet.account,
                args: [request.nftContract, request.licenseTokenIds, request.royaltyContext, request.metadata, request.recipient]
              });
            case 2:
              _yield$this$rpcClient41 = _context96.sent;
              call = _yield$this$rpcClient41.request;
              _context96.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context96.abrupt("return", _context96.sent);
            case 7:
            case "end":
              return _context96.stop();
          }
        }, _callee96, this);
      }));
      function mintAndRegisterIpAndMakeDerivativeWithLicenseTokens(_x74) {
        return _mintAndRegisterIpAndMakeDerivativeWithLicenseTokens.apply(this, arguments);
      }
      return mintAndRegisterIpAndMakeDerivativeWithLicenseTokens;
    }()
    /**
     * method registerIpAndAttachPILTerms for contract SPG
     *
     * @param request SpgRegisterIpAndAttachPilTermsRequest
     * @return Promise<WriteContractReturnType>
     */
    )
  }, {
    key: "registerIpAndAttachPilTerms",
    value: (function () {
      var _registerIpAndAttachPilTerms = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee97(request) {
        var _yield$this$rpcClient42, call;
        return _regeneratorRuntime().wrap(function _callee97$(_context97) {
          while (1) switch (_context97.prev = _context97.next) {
            case 0:
              _context97.next = 2;
              return this.rpcClient.simulateContract({
                abi: spgAbi,
                address: this.address,
                functionName: "registerIpAndAttachPILTerms",
                account: this.wallet.account,
                args: [request.nftContract, request.tokenId, request.metadata, request.terms, request.sigMetadata, request.sigAttach]
              });
            case 2:
              _yield$this$rpcClient42 = _context97.sent;
              call = _yield$this$rpcClient42.request;
              _context97.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context97.abrupt("return", _context97.sent);
            case 7:
            case "end":
              return _context97.stop();
          }
        }, _callee97, this);
      }));
      function registerIpAndAttachPilTerms(_x75) {
        return _registerIpAndAttachPilTerms.apply(this, arguments);
      }
      return registerIpAndAttachPilTerms;
    }()
    /**
     * method registerIpAndMakeDerivative for contract SPG
     *
     * @param request SpgRegisterIpAndMakeDerivativeRequest
     * @return Promise<WriteContractReturnType>
     */
    )
  }, {
    key: "registerIpAndMakeDerivative",
    value: (function () {
      var _registerIpAndMakeDerivative = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee98(request) {
        var _yield$this$rpcClient43, call;
        return _regeneratorRuntime().wrap(function _callee98$(_context98) {
          while (1) switch (_context98.prev = _context98.next) {
            case 0:
              _context98.next = 2;
              return this.rpcClient.simulateContract({
                abi: spgAbi,
                address: this.address,
                functionName: "registerIpAndMakeDerivative",
                account: this.wallet.account,
                args: [request.nftContract, request.tokenId, request.derivData, request.metadata, request.sigMetadata, request.sigRegister]
              });
            case 2:
              _yield$this$rpcClient43 = _context98.sent;
              call = _yield$this$rpcClient43.request;
              _context98.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context98.abrupt("return", _context98.sent);
            case 7:
            case "end":
              return _context98.stop();
          }
        }, _callee98, this);
      }));
      function registerIpAndMakeDerivative(_x76) {
        return _registerIpAndMakeDerivative.apply(this, arguments);
      }
      return registerIpAndMakeDerivative;
    }()
    /**
     * method registerIpAndMakeDerivativeWithLicenseTokens for contract SPG
     *
     * @param request SpgRegisterIpAndMakeDerivativeWithLicenseTokensRequest
     * @return Promise<WriteContractReturnType>
     */
    )
  }, {
    key: "registerIpAndMakeDerivativeWithLicenseTokens",
    value: (function () {
      var _registerIpAndMakeDerivativeWithLicenseTokens = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee99(request) {
        var _yield$this$rpcClient44, call;
        return _regeneratorRuntime().wrap(function _callee99$(_context99) {
          while (1) switch (_context99.prev = _context99.next) {
            case 0:
              _context99.next = 2;
              return this.rpcClient.simulateContract({
                abi: spgAbi,
                address: this.address,
                functionName: "registerIpAndMakeDerivativeWithLicenseTokens",
                account: this.wallet.account,
                args: [request.nftContract, request.tokenId, request.licenseTokenIds, request.royaltyContext, request.metadata, request.sigMetadata, request.sigRegister]
              });
            case 2:
              _yield$this$rpcClient44 = _context99.sent;
              call = _yield$this$rpcClient44.request;
              _context99.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context99.abrupt("return", _context99.sent);
            case 7:
            case "end":
              return _context99.stop();
          }
        }, _callee99, this);
      }));
      function registerIpAndMakeDerivativeWithLicenseTokens(_x77) {
        return _registerIpAndMakeDerivativeWithLicenseTokens.apply(this, arguments);
      }
      return registerIpAndMakeDerivativeWithLicenseTokens;
    }()
    /**
     * method registerPILTermsAndAttach for contract SPG
     *
     * @param request SpgRegisterPilTermsAndAttachRequest
     * @return Promise<WriteContractReturnType>
     */
    )
  }, {
    key: "registerPilTermsAndAttach",
    value: (function () {
      var _registerPilTermsAndAttach = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee100(request) {
        var _yield$this$rpcClient45, call;
        return _regeneratorRuntime().wrap(function _callee100$(_context100) {
          while (1) switch (_context100.prev = _context100.next) {
            case 0:
              _context100.next = 2;
              return this.rpcClient.simulateContract({
                abi: spgAbi,
                address: this.address,
                functionName: "registerPILTermsAndAttach",
                account: this.wallet.account,
                args: [request.ipId, request.terms]
              });
            case 2:
              _yield$this$rpcClient45 = _context100.sent;
              call = _yield$this$rpcClient45.request;
              _context100.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context100.abrupt("return", _context100.sent);
            case 7:
            case "end":
              return _context100.stop();
          }
        }, _callee100, this);
      }));
      function registerPilTermsAndAttach(_x78) {
        return _registerPilTermsAndAttach.apply(this, arguments);
      }
      return registerPilTermsAndAttach;
    }())
  }]);
}(SpgEventClient);

var PIL_TYPE = /*#__PURE__*/function (PIL_TYPE) {
  PIL_TYPE[PIL_TYPE["NON_COMMERCIAL_REMIX"] = 0] = "NON_COMMERCIAL_REMIX";
  PIL_TYPE[PIL_TYPE["COMMERCIAL_USE"] = 1] = "COMMERCIAL_USE";
  PIL_TYPE[PIL_TYPE["COMMERCIAL_REMIX"] = 2] = "COMMERCIAL_REMIX";
  return PIL_TYPE;
}({});

function getLicenseTermByType(type, term) {
  var licenseTerms = {
    transferable: true,
    royaltyPolicy: viem.zeroAddress,
    mintingFee: BigInt(0),
    expiration: BigInt(0),
    commercialUse: false,
    commercialAttribution: false,
    commercializerChecker: viem.zeroAddress,
    commercializerCheckerData: viem.zeroAddress,
    commercialRevShare: 0,
    commercialRevCelling: BigInt(0),
    derivativesAllowed: true,
    derivativesAttribution: true,
    derivativesApproval: false,
    derivativesReciprocal: true,
    derivativeRevCelling: BigInt(0),
    currency: viem.zeroAddress,
    uri: ""
  };
  if (type === PIL_TYPE.NON_COMMERCIAL_REMIX) {
    return licenseTerms;
  } else if (type === PIL_TYPE.COMMERCIAL_USE) {
    if (!term || term.mintingFee === undefined || term.currency === undefined) {
      throw new Error("mintingFee currency are required for commercial use PIL.");
    }
    licenseTerms.royaltyPolicy = viem.getAddress(term.royaltyPolicyLAPAddress);
    licenseTerms.mintingFee = BigInt(term.mintingFee);
    licenseTerms.commercialUse = true;
    licenseTerms.commercialAttribution = true;
    licenseTerms.derivativesReciprocal = false;
    licenseTerms.currency = viem.getAddress(term.currency);
    return licenseTerms;
  } else {
    if (!term || term.mintingFee === undefined || term.currency === undefined || term.commercialRevShare === undefined) {
      throw new Error("mintingFee, currency and commercialRevShare are required for commercial remix PIL.");
    }
    licenseTerms.royaltyPolicy = viem.getAddress(term.royaltyPolicyLAPAddress);
    licenseTerms.mintingFee = BigInt(term.mintingFee);
    licenseTerms.commercialUse = true;
    licenseTerms.commercialAttribution = true;
    licenseTerms.commercialRevShare = term.commercialRevShare;
    licenseTerms.derivativesReciprocal = true;
    licenseTerms.currency = viem.getAddress(term.currency);
    return licenseTerms;
  }
}

var IPAssetClient = /*#__PURE__*/function () {
  function IPAssetClient(rpcClient, wallet, chainId) {
    _classCallCheck(this, IPAssetClient);
    this.licensingModuleClient = new LicensingModuleClient(rpcClient, wallet);
    this.ipAssetRegistryClient = new IpAssetRegistryClient(rpcClient, wallet);
    this.licenseTemplateClient = new PiLicenseTemplateClient(rpcClient, wallet);
    this.licenseRegistryReadOnlyClient = new LicenseRegistryReadOnlyClient(rpcClient);
    this.licenseTokenReadOnlyClient = new LicenseTokenReadOnlyClient(rpcClient);
    this.royaltyPolicyLAPClient = new RoyaltyPolicyLapClient(rpcClient, wallet);
    this.spgClient = new SpgClient(rpcClient, wallet);
    this.rpcClient = rpcClient;
    this.wallet = wallet;
    this.chainId = chainId;
  }

  /**
   * Registers an NFT as IP, creating a corresponding IP record.
   * @param request - The request object that contains all data needed to register IP.
   *   @param request.nftContract The address of the NFT.
   *   @param request.tokenId The token identifier of the NFT.
   *   @param request.txOptions [Optional] The transaction options.
   * @returns A Promise that resolves to an object containing the transaction hash and optional IP ID if waitForTxn is set to true.
   * @emits IPRegistered (ipId, chainId, tokenContract, tokenId, resolverAddr, metadataProviderAddress, metadata)
   */
  return _createClass(IPAssetClient, [{
    key: "register",
    value: (function () {
      var _register = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {
        var _request$txOptions, tokenId, ipId, txHash, txReceipt, targetLogs;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              tokenId = BigInt(request.tokenId);
              _context.next = 4;
              return this.isNftRegistered(request.nftContract, tokenId);
            case 4:
              ipId = _context.sent;
              if (!(ipId !== "0x")) {
                _context.next = 7;
                break;
              }
              return _context.abrupt("return", {
                ipId: ipId
              });
            case 7:
              _context.next = 9;
              return this.ipAssetRegistryClient.register({
                tokenContract: viem.getAddress(request.nftContract),
                tokenId: tokenId,
                chainid: chain[this.chainId]
              });
            case 9:
              txHash = _context.sent;
              if (!((_request$txOptions = request.txOptions) !== null && _request$txOptions !== void 0 && _request$txOptions.waitForTransaction)) {
                _context.next = 18;
                break;
              }
              _context.next = 13;
              return this.rpcClient.waitForTransactionReceipt({
                hash: txHash
              });
            case 13:
              txReceipt = _context.sent;
              targetLogs = this.ipAssetRegistryClient.parseTxIpRegisteredEvent(txReceipt);
              return _context.abrupt("return", {
                txHash: txHash,
                ipId: targetLogs[0].ipId
              });
            case 18:
              return _context.abrupt("return", {
                txHash: txHash
              });
            case 19:
              _context.next = 24;
              break;
            case 21:
              _context.prev = 21;
              _context.t0 = _context["catch"](0);
              handleError(_context.t0, "Failed to register IP");
            case 24:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[0, 21]]);
      }));
      function register(_x) {
        return _register.apply(this, arguments);
      }
      return register;
    }()
    /**
     * Registers a derivative directly with parent IP's license terms, without needing license tokens,
     * and attaches the license terms of the parent IPs to the derivative IP.
     * The license terms must be attached to the parent IP before calling this function.
     * All IPs attached default license terms by default.
     * The derivative IP owner must be the caller or an authorized operator.
     * @param request - The request object that contains all data needed to register derivative IP.
     *   @param request.childIpId The derivative IP ID.
     *   @param request.parentIpIds The parent IP IDs.
     *   @param request.licenseTermsIds The IDs of the license terms that the parent IP supports.
     *   @param request.txOptions [Optional] The transaction options.
     * @returns A Promise that resolves to an object containing the transaction hash.
     */
    )
  }, {
    key: "registerDerivative",
    value: (function () {
      var _registerDerivative = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(request) {
        var _request$txOptions2, isChildIpIdRegistered, _iterator, _step, parentId, isParentIpIdRegistered, i, isAttachedLicenseTerms, txHash;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.prev = 0;
              _context2.next = 3;
              return this.isRegistered(request.childIpId);
            case 3:
              isChildIpIdRegistered = _context2.sent;
              if (isChildIpIdRegistered) {
                _context2.next = 6;
                break;
              }
              throw new Error("The child IP with id ".concat(request.childIpId, " is not registered."));
            case 6:
              _iterator = _createForOfIteratorHelper(request.parentIpIds);
              _context2.prev = 7;
              _iterator.s();
            case 9:
              if ((_step = _iterator.n()).done) {
                _context2.next = 18;
                break;
              }
              parentId = _step.value;
              _context2.next = 13;
              return this.isRegistered(viem.getAddress(parentId));
            case 13:
              isParentIpIdRegistered = _context2.sent;
              if (isParentIpIdRegistered) {
                _context2.next = 16;
                break;
              }
              throw new Error("The parent IP with id ".concat(parentId, " is not registered."));
            case 16:
              _context2.next = 9;
              break;
            case 18:
              _context2.next = 23;
              break;
            case 20:
              _context2.prev = 20;
              _context2.t0 = _context2["catch"](7);
              _iterator.e(_context2.t0);
            case 23:
              _context2.prev = 23;
              _iterator.f();
              return _context2.finish(23);
            case 26:
              if (!(request.parentIpIds.length !== request.licenseTermsIds.length)) {
                _context2.next = 28;
                break;
              }
              throw new Error("Parent IP IDs and License terms IDs must be provided in pairs.");
            case 28:
              i = 0;
            case 29:
              if (!(i < request.parentIpIds.length)) {
                _context2.next = 38;
                break;
              }
              _context2.next = 32;
              return this.licenseRegistryReadOnlyClient.hasIpAttachedLicenseTerms({
                ipId: viem.getAddress(request.parentIpIds[i]),
                licenseTemplate: request.licenseTemplate && viem.getAddress(request.licenseTemplate) || this.licenseTemplateClient.address,
                licenseTermsId: BigInt(request.licenseTermsIds[i])
              });
            case 32:
              isAttachedLicenseTerms = _context2.sent;
              if (isAttachedLicenseTerms) {
                _context2.next = 35;
                break;
              }
              throw new Error("License terms id ".concat(request.licenseTermsIds[i], " must be attached to the parent ipId ").concat(request.parentIpIds[i], " before registering derivative."));
            case 35:
              i++;
              _context2.next = 29;
              break;
            case 38:
              _context2.next = 40;
              return this.licensingModuleClient.registerDerivative({
                childIpId: request.childIpId,
                parentIpIds: request.parentIpIds,
                licenseTermsIds: request.licenseTermsIds.map(function (id) {
                  return BigInt(id);
                }),
                licenseTemplate: request.licenseTemplate || this.licenseTemplateClient.address,
                royaltyContext: viem.zeroAddress
              });
            case 40:
              txHash = _context2.sent;
              if (!((_request$txOptions2 = request.txOptions) !== null && _request$txOptions2 !== void 0 && _request$txOptions2.waitForTransaction)) {
                _context2.next = 47;
                break;
              }
              _context2.next = 44;
              return this.rpcClient.waitForTransactionReceipt({
                hash: txHash
              });
            case 44:
              return _context2.abrupt("return", {
                txHash: txHash
              });
            case 47:
              return _context2.abrupt("return", {
                txHash: txHash
              });
            case 48:
              _context2.next = 53;
              break;
            case 50:
              _context2.prev = 50;
              _context2.t1 = _context2["catch"](0);
              handleError(_context2.t1, "Failed to register derivative");
            case 53:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[0, 50], [7, 20, 23, 26]]);
      }));
      function registerDerivative(_x2) {
        return _registerDerivative.apply(this, arguments);
      }
      return registerDerivative;
    }()
    /**
     * Registers a derivative with license tokens.
     * the derivative IP is registered with license tokens minted from the parent IP's license terms.
     * the license terms of the parent IPs issued with license tokens are attached to the derivative IP.
     * the caller must be the derivative IP owner or an authorized operator.
     * @param request - The request object that contains all data needed to register derivative license tokens.
     *   @param request.childIpId The derivative IP ID.
     *   @param request.licenseTokenIds The IDs of the license tokens.
     *   @param request.txOptions [Optional] The transaction options.
     * @returns A Promise that resolves to an object containing the transaction hash.
     */
    )
  }, {
    key: "registerDerivativeWithLicenseTokens",
    value: (function () {
      var _registerDerivativeWithLicenseTokens = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(request) {
        var _request$txOptions3, isChildIpIdRegistered, _iterator2, _step2, licenseTokenId, tokenOwnerAddress, txHash;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.prev = 0;
              _context3.next = 3;
              return this.isRegistered(request.childIpId);
            case 3:
              isChildIpIdRegistered = _context3.sent;
              if (isChildIpIdRegistered) {
                _context3.next = 6;
                break;
              }
              throw new Error("The child IP with id ".concat(request.childIpId, " is not registered."));
            case 6:
              request.licenseTokenIds = request.licenseTokenIds.map(function (id) {
                return BigInt(id);
              });
              _iterator2 = _createForOfIteratorHelper(request.licenseTokenIds);
              _context3.prev = 8;
              _iterator2.s();
            case 10:
              if ((_step2 = _iterator2.n()).done) {
                _context3.next = 19;
                break;
              }
              licenseTokenId = _step2.value;
              _context3.next = 14;
              return this.licenseTokenReadOnlyClient.ownerOf({
                tokenId: licenseTokenId
              });
            case 14:
              tokenOwnerAddress = _context3.sent;
              if (tokenOwnerAddress) {
                _context3.next = 17;
                break;
              }
              throw new Error("License token id ".concat(licenseTokenId, " must be owned by the caller."));
            case 17:
              _context3.next = 10;
              break;
            case 19:
              _context3.next = 24;
              break;
            case 21:
              _context3.prev = 21;
              _context3.t0 = _context3["catch"](8);
              _iterator2.e(_context3.t0);
            case 24:
              _context3.prev = 24;
              _iterator2.f();
              return _context3.finish(24);
            case 27:
              _context3.next = 29;
              return this.licensingModuleClient.registerDerivativeWithLicenseTokens({
                childIpId: viem.getAddress(request.childIpId),
                licenseTokenIds: request.licenseTokenIds,
                royaltyContext: viem.zeroAddress
              });
            case 29:
              txHash = _context3.sent;
              if (!((_request$txOptions3 = request.txOptions) !== null && _request$txOptions3 !== void 0 && _request$txOptions3.waitForTransaction)) {
                _context3.next = 36;
                break;
              }
              _context3.next = 33;
              return this.rpcClient.waitForTransactionReceipt({
                hash: txHash
              });
            case 33:
              return _context3.abrupt("return", {
                txHash: txHash
              });
            case 36:
              return _context3.abrupt("return", {
                txHash: txHash
              });
            case 37:
              _context3.next = 42;
              break;
            case 39:
              _context3.prev = 39;
              _context3.t1 = _context3["catch"](0);
              handleError(_context3.t1, "Failed to register derivative with license tokens");
            case 42:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[0, 39], [8, 21, 24, 27]]);
      }));
      function registerDerivativeWithLicenseTokens(_x3) {
        return _registerDerivativeWithLicenseTokens.apply(this, arguments);
      }
      return registerDerivativeWithLicenseTokens;
    }()
    /**
     * Mint an NFT from a collection and register it as an IP.
     * @param request - The request object that contains all data needed to mint and register ip.
     *   @param request.nftContract The address of the NFT collection.
     *   @param request.pilType The type of the PIL.
     *   @param request.metadata - The metadata for the IP.
     *   @param request.metadataURI The URI of the metadata for the IP.
     *   @param request.metadata [Optional] The metadata for the IP.
     *   @param request.nftMetadata The metadata for the IP NFT.
     *   @param request.recipient [Optional] The address of the recipient of the minted NFT.
     *   @param request.mintingFee [Optional] The fee to be paid when minting a license.
     *   @param request.commercialRevShare [Optional] Percentage of revenue that must be shared with the licensor.
     *   @param request.currency [Optional] The ERC20 token to be used to pay the minting fee. the token must be registered in story protocol.
     *   @param request.txOptions [Optional] The transaction options.
     * @returns A Promise that resolves to an object containing the transaction hash and optional IP ID, Token ID, License Terms Id if waitForTxn is set to true.
     * @emits IPRegistered (ipId, chainId, tokenContract, tokenId, name, uri, registrationDate)
     * @emits LicenseTermsAttached (caller, ipId, licenseTemplate, licenseTermsId)
     */
    )
  }, {
    key: "createIpAssetWithPilTerms",
    value: (function () {
      var _createIpAssetWithPilTerms = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(request) {
        var _request$txOptions4, licenseTerm, object, txHash, txReceipt, iPRegisteredLog, licenseTermsId;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.prev = 0;
              if (!(request.pilType === undefined || request.pilType === null)) {
                _context4.next = 3;
                break;
              }
              throw new Error("PIL type is required.");
            case 3:
              licenseTerm = getLicenseTermByType(request.pilType, {
                mintingFee: request.mintingFee,
                currency: request.currency,
                royaltyPolicyLAPAddress: this.royaltyPolicyLAPClient.address,
                commercialRevShare: request.commercialRevShare
              });
              object = {
                nftContract: viem.getAddress(request.nftContract),
                recipient: request.recipient && viem.getAddress(request.recipient) || this.wallet.account.address,
                terms: licenseTerm,
                metadata: {
                  metadataURI: "",
                  metadataHash: viem.toHex("", {
                    size: 32
                  }),
                  nftMetadataHash: viem.toHex("", {
                    size: 32
                  })
                }
              };
              if (request.metadata && request.metadata.metadataURI && request.metadata.metadata && request.metadata.nftMetadata) {
                object.metadata = {
                  metadataURI: request.metadata.metadataURI,
                  metadataHash: viem.toHex(request.metadata.metadata, {
                    size: 32
                  }),
                  nftMetadataHash: viem.toHex(request.metadata.nftMetadata, {
                    size: 32
                  })
                };
              }
              _context4.next = 8;
              return this.spgClient.mintAndRegisterIpAndAttachPilTerms(object);
            case 8:
              txHash = _context4.sent;
              if (!((_request$txOptions4 = request.txOptions) !== null && _request$txOptions4 !== void 0 && _request$txOptions4.waitForTransaction)) {
                _context4.next = 16;
                break;
              }
              _context4.next = 12;
              return this.rpcClient.waitForTransactionReceipt({
                hash: txHash
              });
            case 12:
              txReceipt = _context4.sent;
              iPRegisteredLog = this.ipAssetRegistryClient.parseTxIpRegisteredEvent(txReceipt)[0];
              licenseTermsId = this.licensingModuleClient.parseTxLicenseTermsAttachedEvent(txReceipt)[0].licenseTermsId;
              return _context4.abrupt("return", {
                txHash: txHash,
                ipId: iPRegisteredLog.ipId,
                licenseTermsId: licenseTermsId,
                tokenId: iPRegisteredLog.tokenId
              });
            case 16:
              return _context4.abrupt("return", {
                txHash: txHash
              });
            case 19:
              _context4.prev = 19;
              _context4.t0 = _context4["catch"](0);
              handleError(_context4.t0, "Failed to mint and register IP and attach PIL terms");
            case 22:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this, [[0, 19]]);
      }));
      function createIpAssetWithPilTerms(_x4) {
        return _createIpAssetWithPilTerms.apply(this, arguments);
      }
      return createIpAssetWithPilTerms;
    }()
    /**
     * Register a given NFT as an IP and attach Programmable IP License Terms.R.
     * @param request - The request object that contains all data needed to mint and register ip.
     *   @param request.nftContract The address of the NFT collection.
     *   @param request.tokenId The ID of the NFT.
     *   @param request.pilType The type of the PIL.
     *   @param request.metadata - [Optional] The desired metadata for the newly registered IP.
     *   @param request.metadataURI The the metadata for the IP hash.
     *   @param request.metadata The metadata for the IP.
     *   @param request.nftMetadata The metadata for the IP NFT.
     *   @param request.sigMetadata - [Optional] The signature data for execution via IP Account.
     *   @param request.sigMetadata.signer The address of the signer for execution with signature.
     *   @param request.sigMetadata.deadline The deadline for the signature.
     *   @param request.sigMetadata.signature The signature for the execution via IP Account.
     *   @param request.sigAttach - The signature data for execution via IP Account.
     *   @param request.sigAttach.signer The address of the signer for execution with signature.
     *   @param request.sigAttach.deadline The deadline for the signature.
     *   @param request.sigAttach.signature The signature for the execution via IP Account.
     *   @param request.mintingFee [Optional] The fee to be paid when minting a license.
     *   @param request.commercialRevShare [Optional] Percentage of revenue that must be shared with the licensor.
     *   @param request.currency [Optional] The ERC20 token to be used to pay the minting fee. the token must be registered in story protocol.
     *   @param request.txOptions [Optional] The transaction options.
     * @returns A Promise that resolves to an object containing the transaction hash and optional IP ID, License Terms Id if waitForTxn is set to true.
     * @emits LicenseTermsAttached (caller, ipId, licenseTemplate, licenseTermsId)
     */
    )
  }, {
    key: "registerIpAndAttachPilTerms",
    value: (function () {
      var _registerIpAndAttachPilTerms = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(request) {
        var _request$txOptions5, ipId, licenseTerm, object, txHash, txReceipt, log;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _context5.prev = 0;
              if (!(request.pilType === undefined || request.pilType === null)) {
                _context5.next = 3;
                break;
              }
              throw new Error("PIL type is required.");
            case 3:
              request.tokenId = BigInt(request.tokenId);
              _context5.next = 6;
              return this.isNftRegistered(request.nftContract, request.tokenId);
            case 6:
              ipId = _context5.sent;
              if (!(ipId !== "0x")) {
                _context5.next = 9;
                break;
              }
              throw new Error("The NFT with id ".concat(request.tokenId, " is already registered as IP."));
            case 9:
              licenseTerm = getLicenseTermByType(request.pilType, {
                mintingFee: request.mintingFee,
                currency: request.currency,
                royaltyPolicyLAPAddress: this.royaltyPolicyLAPClient.address,
                commercialRevShare: request.commercialRevShare
              });
              object = {
                nftContract: viem.getAddress(request.nftContract),
                tokenId: request.tokenId,
                terms: licenseTerm,
                metadata: {
                  metadataURI: "",
                  metadataHash: viem.toHex("", {
                    size: 32
                  }),
                  nftMetadataHash: viem.toHex("", {
                    size: 32
                  })
                },
                sigMetadata: {
                  signer: viem.zeroAddress,
                  deadline: BigInt(0),
                  signature: viem.zeroAddress
                },
                sigAttach: {
                  signer: viem.getAddress(request.sigAttach.signer),
                  deadline: BigInt(request.sigAttach.deadline),
                  signature: request.sigAttach.signature
                }
              };
              if (request.metadata && request.metadata.metadataURI && request.metadata.metadata && request.metadata.nftMetadata) {
                object.metadata = {
                  metadataURI: request.metadata.metadataURI,
                  metadataHash: viem.toHex(request.metadata.metadata, {
                    size: 32
                  }),
                  nftMetadataHash: viem.toHex(request.metadata.nftMetadata, {
                    size: 32
                  })
                };
              }
              if (request.sigMetadata && request.sigMetadata.signature && request.sigMetadata.signer && request.sigMetadata.deadline) {
                object.sigMetadata = {
                  signer: viem.getAddress(request.sigMetadata.signer),
                  deadline: BigInt(request.sigMetadata.deadline),
                  signature: request.sigMetadata.signature
                };
              }
              _context5.next = 15;
              return this.spgClient.registerIpAndAttachPilTerms(object);
            case 15:
              txHash = _context5.sent;
              if (!((_request$txOptions5 = request.txOptions) !== null && _request$txOptions5 !== void 0 && _request$txOptions5.waitForTransaction)) {
                _context5.next = 22;
                break;
              }
              _context5.next = 19;
              return this.rpcClient.waitForTransactionReceipt({
                hash: txHash
              });
            case 19:
              txReceipt = _context5.sent;
              log = this.licensingModuleClient.parseTxLicenseTermsAttachedEvent(txReceipt)[0];
              return _context5.abrupt("return", {
                txHash: txHash,
                licenseTermsId: log.licenseTermsId,
                ipId: log.ipId
              });
            case 22:
              return _context5.abrupt("return", {
                txHash: txHash
              });
            case 25:
              _context5.prev = 25;
              _context5.t0 = _context5["catch"](0);
              handleError(_context5.t0, "Failed to register IP and attach PIL terms");
            case 28:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this, [[0, 25]]);
      }));
      function registerIpAndAttachPilTerms(_x5) {
        return _registerIpAndAttachPilTerms.apply(this, arguments);
      }
      return registerIpAndAttachPilTerms;
    }()
    /**
     * Register the given NFT as a derivative IP with metadata without using license tokens.
     * @param request - The request object that contains all data needed to register derivative IP.
     *   @param request.nftContract The address of the NFT collection.
     *   @param request.tokenId The ID of the NFT.
     *   @param request.derivData The derivative data to be used for registerDerivative.
     *   @param request.derivData.parentIpIds The IDs of the parent IPs to link the registered derivative IP.
     *   @param request.derivData.licenseTemplate [Optional] The address of the license template to be used for the linking.
     *   @param request.derivData.licenseTermsIds The IDs of the license terms to be used for the linking.
     *   @param request.sigRegister Signature data for registerDerivative for the IP via the Licensing Module.
     *   @param request.sigRegister.signer The address of the signer for execution with signature.
     *   @param request.sigRegister.deadline The deadline for the signature.
     *   @param request.sigRegister.signature The signature for the execution via IP Account.
     *   @param request.metadata - [Optional] The desired metadata for the newly registered IP.
     *   @param request.metadata.metadataURI The URI of the metadata for the IP.
     *   @param request.metadata.metadata The metadata for the IP.
     *   @param request.metadata.nftMetadata The the metadata for the IP NFT.
     *   @param request.sigMetadata - [Optional] Signature data for setAll (metadata) for the IP via the Core Metadata Module.
     *   @param request.sigMetadata.signer The address of the signer for execution with signature.
     *   @param request.sigMetadata.deadline The deadline for the signature.
     *   @param request.sigMetadata.signature The signature for the execution via IP Account.
     *   @param request.txOptions [Optional] The transaction options.
     * @returns A Promise that resolves to an object containing the transaction hash and optional IP ID if waitForTxn is set to true.
     * @emits IPRegistered (ipId, chainId, tokenContract, tokenId, name, uri, registrationDate)
     */
    )
  }, {
    key: "registerDerivativeIp",
    value: (function () {
      var _registerDerivativeIp = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(request) {
        var _request$txOptions6, tokenId, ipId, i, isAttachedLicenseTerms, object, txHash, receipt, log;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              _context6.prev = 0;
              tokenId = BigInt(request.tokenId);
              _context6.next = 4;
              return this.isNftRegistered(request.nftContract, tokenId);
            case 4:
              ipId = _context6.sent;
              if (!(ipId !== "0x")) {
                _context6.next = 7;
                break;
              }
              throw new Error("The NFT with id ".concat(tokenId, " is already registered as IP."));
            case 7:
              if (!(request.derivData.parentIpIds.length !== request.derivData.licenseTermsIds.length)) {
                _context6.next = 9;
                break;
              }
              throw new Error("Parent IP IDs and License terms IDs must be provided in pairs.");
            case 9:
              i = 0;
            case 10:
              if (!(i < request.derivData.parentIpIds.length)) {
                _context6.next = 19;
                break;
              }
              _context6.next = 13;
              return this.licenseRegistryReadOnlyClient.hasIpAttachedLicenseTerms({
                ipId: viem.getAddress(request.derivData.parentIpIds[i]),
                licenseTemplate: request.derivData.licenseTemplate && viem.getAddress(request.derivData.licenseTemplate) || this.licenseTemplateClient.address,
                licenseTermsId: BigInt(request.derivData.licenseTermsIds[i])
              });
            case 13:
              isAttachedLicenseTerms = _context6.sent;
              if (isAttachedLicenseTerms) {
                _context6.next = 16;
                break;
              }
              throw new Error("License terms id ".concat(request.derivData.licenseTermsIds[i], " must be attached to the parent ipId ").concat(request.derivData.parentIpIds[i], " before registering derivative."));
            case 16:
              i++;
              _context6.next = 10;
              break;
            case 19:
              object = {
                nftContract: viem.getAddress(request.nftContract),
                tokenId: BigInt(request.tokenId),
                derivData: {
                  parentIpIds: request.derivData.parentIpIds.map(function (id) {
                    return viem.getAddress(id);
                  }),
                  licenseTermsIds: request.derivData.licenseTermsIds.map(function (id) {
                    return BigInt(id);
                  }),
                  licenseTemplate: request.derivData.licenseTemplate && viem.getAddress(request.derivData.licenseTemplate) || this.licenseTemplateClient.address,
                  royaltyContext: viem.zeroAddress
                },
                sigRegister: {
                  signer: viem.getAddress(request.sigRegister.signer),
                  deadline: BigInt(request.sigRegister.deadline),
                  signature: request.sigRegister.signature
                },
                sigMetadata: {
                  signer: viem.zeroAddress,
                  deadline: BigInt(0),
                  signature: viem.zeroAddress
                },
                metadata: {
                  metadataURI: "",
                  metadataHash: viem.toHex("", {
                    size: 32
                  }),
                  nftMetadataHash: viem.toHex("", {
                    size: 32
                  })
                }
              };
              if (request.sigMetadata && request.sigMetadata.signature && request.sigMetadata.signature.length > 0 && request.sigMetadata.signer && request.sigMetadata.signer !== viem.zeroAddress && request.sigMetadata.deadline !== 0n) {
                object.sigMetadata = {
                  signer: viem.getAddress(request.sigMetadata.signer),
                  deadline: BigInt(request.sigMetadata.deadline),
                  signature: request.sigMetadata.signature
                };
              }
              if (request.metadata && request.metadata.metadata && request.metadata.metadataURI && request.metadata.nftMetadata) {
                object.metadata = {
                  metadataURI: request.metadata.metadataURI,
                  metadataHash: viem.toHex(request.metadata.metadata, {
                    size: 32
                  }),
                  nftMetadataHash: viem.toHex(request.metadata.nftMetadata, {
                    size: 32
                  })
                };
              }
              _context6.next = 24;
              return this.spgClient.registerIpAndMakeDerivative(object);
            case 24:
              txHash = _context6.sent;
              if (!((_request$txOptions6 = request.txOptions) !== null && _request$txOptions6 !== void 0 && _request$txOptions6.waitForTransaction)) {
                _context6.next = 31;
                break;
              }
              _context6.next = 28;
              return this.rpcClient.waitForTransactionReceipt({
                hash: txHash
              });
            case 28:
              receipt = _context6.sent;
              log = this.ipAssetRegistryClient.parseTxIpRegisteredEvent(receipt)[0];
              return _context6.abrupt("return", {
                txHash: txHash,
                ipId: log.ipId
              });
            case 31:
              return _context6.abrupt("return", {
                txHash: txHash
              });
            case 34:
              _context6.prev = 34;
              _context6.t0 = _context6["catch"](0);
              handleError(_context6.t0, "Failed to register derivative IP");
            case 37:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this, [[0, 34]]);
      }));
      function registerDerivativeIp(_x6) {
        return _registerDerivativeIp.apply(this, arguments);
      }
      return registerDerivativeIp;
    }()
    /**
     * Gets the canonical IP identifier associated with an IP NFT.
     * @param nftContract The address of the NFT collection.
     * @param tokenId The token identifier of the IP.
     * @returns The IP's canonical address identifier.
     */
    )
  }, {
    key: "getIpIdAddress",
    value: (function () {
      var _getIpIdAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(nftContract, tokenId) {
        var ipId;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              _context7.next = 2;
              return this.ipAssetRegistryClient.ipId({
                chainId: chain[this.chainId],
                tokenContract: viem.getAddress(nftContract),
                tokenId: BigInt(tokenId)
              });
            case 2:
              ipId = _context7.sent;
              return _context7.abrupt("return", ipId);
            case 4:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));
      function getIpIdAddress(_x7, _x8) {
        return _getIpIdAddress.apply(this, arguments);
      }
      return getIpIdAddress;
    }())
  }, {
    key: "isNftRegistered",
    value: function () {
      var _isNftRegistered = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(nftContract, tokenId) {
        var ipId, isRegistered;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              _context8.next = 2;
              return this.getIpIdAddress(nftContract, tokenId);
            case 2:
              ipId = _context8.sent;
              _context8.next = 5;
              return this.ipAssetRegistryClient.isRegistered({
                id: ipId
              });
            case 5:
              isRegistered = _context8.sent;
              return _context8.abrupt("return", isRegistered ? ipId : "0x");
            case 7:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this);
      }));
      function isNftRegistered(_x9, _x10) {
        return _isNftRegistered.apply(this, arguments);
      }
      return isNftRegistered;
    }()
  }, {
    key: "isRegistered",
    value: function () {
      var _isRegistered = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(ipId) {
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              _context9.next = 2;
              return this.ipAssetRegistryClient.isRegistered({
                id: viem.getAddress(ipId)
              });
            case 2:
              return _context9.abrupt("return", _context9.sent);
            case 3:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this);
      }));
      function isRegistered(_x11) {
        return _isRegistered.apply(this, arguments);
      }
      return isRegistered;
    }()
  }]);
}();

var PermissionClient = /*#__PURE__*/function () {
  function PermissionClient(rpcClient, wallet) {
    _classCallCheck(this, PermissionClient);
    this.rpcClient = rpcClient;
    this.wallet = wallet;
    this.accessControllerClient = new AccessControllerClient(this.rpcClient, this.wallet);
  }

  /**
   * Sets the permission for a specific function call
   * Each policy is represented as a mapping from an IP account address to a signer address to a recipient
   * address to a function selector to a permission level. The permission level can be 0 (ABSTAIN), 1 (ALLOW), or
   * 2 (DENY).
   * By default, all policies are set to 0 (ABSTAIN), which means that the permission is not set.
   * The owner of ipAccount by default has all permission.
   * address(0) => wildcard
   * bytes4(0) => wildcard
   * Specific permission overrides wildcard permission.
   * @param request - The request object containing necessary data to set permissions.
   *   @param request.ipAsset The address of the IP account that grants the permission for `signer`
   *   @param request.signer The address that can call `to` on behalf of the `ipAccount`
   *   @param request.to The address that can be called by the `signer` (currently only modules can be `to`)
   *   @param request.func Optional. The function selector string of `to` that can be called by the `signer` on behalf of the `ipAccount`. Be default, it allows all functions.
   *   @param request.permission The new permission level
   * @returns A Promise that resolves to an object containing the transaction hash
   * @emits PermissionSet (ipAccountOwner, ipAccount, signer, to, func, permission)
   */
  return _createClass(PermissionClient, [{
    key: "setPermission",
    value: (function () {
      var _setPermission = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {
        var _request$txOptions, ipAccountClient, txHash;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              ipAccountClient = new IpAccountImplClient(this.rpcClient, this.wallet, viem.getAddress(request.ipId));
              _context.next = 4;
              return ipAccountClient.execute({
                to: this.accessControllerClient.address,
                value: BigInt(0),
                data: viem.encodeFunctionData({
                  abi: accessControllerAbi,
                  functionName: "setPermission",
                  args: [viem.getAddress(request.ipId),
                  // 0x Address
                  viem.getAddress(request.signer),
                  // 0x Address
                  viem.getAddress(request.to),
                  // 0x Address
                  request.func || "0x00000000",
                  // bytes4
                  request.permission // uint8
                  ]
                })
              });
            case 4:
              txHash = _context.sent;
              if (!((_request$txOptions = request.txOptions) !== null && _request$txOptions !== void 0 && _request$txOptions.waitForTransaction)) {
                _context.next = 11;
                break;
              }
              _context.next = 8;
              return this.rpcClient.waitForTransactionReceipt({
                hash: txHash
              });
            case 8:
              return _context.abrupt("return", {
                txHash: txHash,
                success: true
              });
            case 11:
              return _context.abrupt("return", {
                txHash: txHash
              });
            case 12:
              _context.next = 17;
              break;
            case 14:
              _context.prev = 14;
              _context.t0 = _context["catch"](0);
              handleError(_context.t0, "Failed to set permissions");
            case 17:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[0, 14]]);
      }));
      function setPermission(_x) {
        return _setPermission.apply(this, arguments);
      }
      return setPermission;
    }())
  }]);
}();

var LicenseClient = /*#__PURE__*/function () {
  function LicenseClient(rpcClient, wallet) {
    _classCallCheck(this, LicenseClient);
    this.licensingModuleClient = new LicensingModuleClient(rpcClient, wallet);
    this.licenseRegistryClient = new LicenseRegistryEventClient(rpcClient);
    this.piLicenseTemplateReadOnlyClient = new PiLicenseTemplateReadOnlyClient(rpcClient);
    this.licenseTemplateClient = new PiLicenseTemplateClient(rpcClient, wallet);
    this.royaltyPolicyLAPClient = new RoyaltyPolicyLapClient(rpcClient, wallet);
    this.licenseRegistryReadOnlyClient = new LicenseRegistryReadOnlyClient(rpcClient);
    this.ipAssetRegistryClient = new IpAssetRegistryClient(rpcClient, wallet);
    this.rpcClient = rpcClient;
    this.wallet = wallet;
  }
  /**
   * Convenient function to register a PIL non commercial social remix license to the registry
   * @param request - [Optional] The request object that contains all data needed to register a PIL non commercial social remix license.
   *   @param request.txOptions [Optional] The transaction options.
   * @returns A Promise that resolves to an object containing the optional transaction hash and optional license terms Id.
   * @emits LicenseTermsRegistered (licenseTermsId, licenseTemplate, licenseTerms);
   */
  return _createClass(LicenseClient, [{
    key: "registerNonComSocialRemixingPIL",
    value: (function () {
      var _registerNonComSocialRemixingPIL = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {
        var _request$txOptions, licenseTerms, licenseTermsId, txHash, txReceipt, targetLogs;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              licenseTerms = getLicenseTermByType(PIL_TYPE.NON_COMMERCIAL_REMIX);
              _context.next = 4;
              return this.getLicenseTermsId(licenseTerms);
            case 4:
              licenseTermsId = _context.sent;
              if (!(licenseTermsId !== 0n)) {
                _context.next = 7;
                break;
              }
              return _context.abrupt("return", {
                licenseTermsId: licenseTermsId
              });
            case 7:
              _context.next = 9;
              return this.licenseTemplateClient.registerLicenseTerms({
                terms: licenseTerms
              });
            case 9:
              txHash = _context.sent;
              if (!(request !== null && request !== void 0 && (_request$txOptions = request.txOptions) !== null && _request$txOptions !== void 0 && _request$txOptions.waitForTransaction)) {
                _context.next = 18;
                break;
              }
              _context.next = 13;
              return this.rpcClient.waitForTransactionReceipt({
                hash: txHash
              });
            case 13:
              txReceipt = _context.sent;
              targetLogs = this.licenseTemplateClient.parseTxLicenseTermsRegisteredEvent(txReceipt);
              return _context.abrupt("return", {
                txHash: txHash,
                licenseTermsId: targetLogs[0].licenseTermsId
              });
            case 18:
              return _context.abrupt("return", {
                txHash: txHash
              });
            case 19:
              _context.next = 24;
              break;
            case 21:
              _context.prev = 21;
              _context.t0 = _context["catch"](0);
              handleError(_context.t0, "Failed to register non commercial social remixing PIL");
            case 24:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[0, 21]]);
      }));
      function registerNonComSocialRemixingPIL(_x) {
        return _registerNonComSocialRemixingPIL.apply(this, arguments);
      }
      return registerNonComSocialRemixingPIL;
    }()
    /**
     * Convenient function to register a PIL commercial use license to the registry.
     * @param request - The request object that contains all data needed to register a PIL commercial use license.
     *   @param request.mintingFee The fee to be paid when minting a license.
     *   @param request.currency The ERC20 token to be used to pay the minting fee and the token must be registered in story protocol.
     *   @param request.txOptions [Optional] The transaction options.
     * @returns A Promise that resolves to an object containing the optional transaction hash and optional license terms Id.
     * @emits LicenseTermsRegistered (licenseTermsId, licenseTemplate, licenseTerms);
     */
    )
  }, {
    key: "registerCommercialUsePIL",
    value: (function () {
      var _registerCommercialUsePIL = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(request) {
        var _request$txOptions2, licenseTerms, licenseTermsId, txHash, txReceipt, targetLogs;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.prev = 0;
              licenseTerms = getLicenseTermByType(PIL_TYPE.COMMERCIAL_USE, {
                mintingFee: request.mintingFee,
                currency: request.currency,
                royaltyPolicyLAPAddress: this.royaltyPolicyLAPClient.address
              });
              _context2.next = 4;
              return this.getLicenseTermsId(licenseTerms);
            case 4:
              licenseTermsId = _context2.sent;
              if (!(licenseTermsId !== 0n)) {
                _context2.next = 7;
                break;
              }
              return _context2.abrupt("return", {
                licenseTermsId: licenseTermsId
              });
            case 7:
              _context2.next = 9;
              return this.licenseTemplateClient.registerLicenseTerms({
                terms: licenseTerms
              });
            case 9:
              txHash = _context2.sent;
              if (!((_request$txOptions2 = request.txOptions) !== null && _request$txOptions2 !== void 0 && _request$txOptions2.waitForTransaction)) {
                _context2.next = 18;
                break;
              }
              _context2.next = 13;
              return this.rpcClient.waitForTransactionReceipt({
                hash: txHash
              });
            case 13:
              txReceipt = _context2.sent;
              targetLogs = this.licenseTemplateClient.parseTxLicenseTermsRegisteredEvent(txReceipt);
              return _context2.abrupt("return", {
                txHash: txHash,
                licenseTermsId: targetLogs[0].licenseTermsId
              });
            case 18:
              return _context2.abrupt("return", {
                txHash: txHash
              });
            case 19:
              _context2.next = 24;
              break;
            case 21:
              _context2.prev = 21;
              _context2.t0 = _context2["catch"](0);
              handleError(_context2.t0, "Failed to register commercial use PIL");
            case 24:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[0, 21]]);
      }));
      function registerCommercialUsePIL(_x2) {
        return _registerCommercialUsePIL.apply(this, arguments);
      }
      return registerCommercialUsePIL;
    }()
    /**
     * Convenient function to register a PIL commercial Remix license to the registry.
     * @param request - The request object that contains all data needed to register license.
     *   @param request.mintingFee The fee to be paid when minting a license.
     *   @param request.commercialRevShare Percentage of revenue that must be shared with the licensor.
     *   @param request.currency The ERC20 token to be used to pay the minting fee. the token must be registered in story protocol.
     *   @param request.txOptions [Optional] The transaction options.
     * @returns A Promise that resolves to an object containing the optional transaction hash and optional license terms Id.
     * @emits LicenseTermsRegistered (licenseTermsId, licenseTemplate, licenseTerms);
     */
    )
  }, {
    key: "registerCommercialRemixPIL",
    value: (function () {
      var _registerCommercialRemixPIL = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(request) {
        var _request$txOptions3, licenseTerms, licenseTermsId, txHash, txReceipt, targetLogs;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.prev = 0;
              licenseTerms = getLicenseTermByType(PIL_TYPE.COMMERCIAL_REMIX, {
                mintingFee: request.mintingFee,
                currency: request.currency,
                royaltyPolicyLAPAddress: this.royaltyPolicyLAPClient.address,
                commercialRevShare: request.commercialRevShare
              });
              _context3.next = 4;
              return this.getLicenseTermsId(licenseTerms);
            case 4:
              licenseTermsId = _context3.sent;
              if (!(licenseTermsId !== 0n)) {
                _context3.next = 7;
                break;
              }
              return _context3.abrupt("return", {
                licenseTermsId: licenseTermsId
              });
            case 7:
              _context3.next = 9;
              return this.licenseTemplateClient.registerLicenseTerms({
                terms: licenseTerms
              });
            case 9:
              txHash = _context3.sent;
              if (!((_request$txOptions3 = request.txOptions) !== null && _request$txOptions3 !== void 0 && _request$txOptions3.waitForTransaction)) {
                _context3.next = 18;
                break;
              }
              _context3.next = 13;
              return this.rpcClient.waitForTransactionReceipt({
                hash: txHash
              });
            case 13:
              txReceipt = _context3.sent;
              targetLogs = this.licenseTemplateClient.parseTxLicenseTermsRegisteredEvent(txReceipt);
              return _context3.abrupt("return", {
                txHash: txHash,
                licenseTermsId: targetLogs[0].licenseTermsId
              });
            case 18:
              return _context3.abrupt("return", {
                txHash: txHash
              });
            case 19:
              _context3.next = 24;
              break;
            case 21:
              _context3.prev = 21;
              _context3.t0 = _context3["catch"](0);
              handleError(_context3.t0, "Failed to register commercial remix PIL");
            case 24:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[0, 21]]);
      }));
      function registerCommercialRemixPIL(_x3) {
        return _registerCommercialRemixPIL.apply(this, arguments);
      }
      return registerCommercialRemixPIL;
    }()
    /**
     * Attaches license terms to an IP.
     * @param request - The request object that contains all data needed to attach license terms.
     *   @param request.ipId The address of the IP to which the license terms are attached.
     *   @param request.licenseTemplate The address of the license template.
     *   @param request.licenseTermsId The ID of the license terms.
     *   @param request.txOptions [Optional] The transaction options.
     * @returns A Promise that resolves to an object containing the transaction hash.
     */
    )
  }, {
    key: "attachLicenseTerms",
    value: (function () {
      var _attachLicenseTerms = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(request) {
        var _request$txOptions4, isRegistered, isExisted, isAttachedLicenseTerms, txHash;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.prev = 0;
              request.licenseTermsId = BigInt(request.licenseTermsId);
              _context4.next = 4;
              return this.ipAssetRegistryClient.isRegistered({
                id: viem.getAddress(request.ipId)
              });
            case 4:
              isRegistered = _context4.sent;
              if (isRegistered) {
                _context4.next = 7;
                break;
              }
              throw new Error("The IP with id ".concat(request.ipId, " is not registered."));
            case 7:
              _context4.next = 9;
              return this.piLicenseTemplateReadOnlyClient.exists({
                licenseTermsId: request.licenseTermsId
              });
            case 9:
              isExisted = _context4.sent;
              if (isExisted) {
                _context4.next = 12;
                break;
              }
              throw new Error("License terms id ".concat(request.licenseTermsId, " do not exist."));
            case 12:
              _context4.next = 14;
              return this.licenseRegistryReadOnlyClient.hasIpAttachedLicenseTerms({
                ipId: request.ipId,
                licenseTemplate: request.licenseTemplate && viem.getAddress(request.licenseTemplate) || this.licenseTemplateClient.address,
                licenseTermsId: request.licenseTermsId
              });
            case 14:
              isAttachedLicenseTerms = _context4.sent;
              if (!isAttachedLicenseTerms) {
                _context4.next = 17;
                break;
              }
              throw new Error("License terms id ".concat(request.licenseTermsId, " is already attached to the IP with id ").concat(request.ipId, "."));
            case 17:
              _context4.next = 19;
              return this.licensingModuleClient.attachLicenseTerms({
                ipId: request.ipId,
                licenseTemplate: request.licenseTemplate || this.licenseTemplateClient.address,
                licenseTermsId: request.licenseTermsId
              });
            case 19:
              txHash = _context4.sent;
              if (!((_request$txOptions4 = request.txOptions) !== null && _request$txOptions4 !== void 0 && _request$txOptions4.waitForTransaction)) {
                _context4.next = 26;
                break;
              }
              _context4.next = 23;
              return this.rpcClient.waitForTransactionReceipt({
                hash: txHash
              });
            case 23:
              return _context4.abrupt("return", {
                txHash: txHash
              });
            case 26:
              return _context4.abrupt("return", {
                txHash: txHash
              });
            case 27:
              _context4.next = 32;
              break;
            case 29:
              _context4.prev = 29;
              _context4.t0 = _context4["catch"](0);
              handleError(_context4.t0, "Failed to attach license terms");
            case 32:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this, [[0, 29]]);
      }));
      function attachLicenseTerms(_x4) {
        return _attachLicenseTerms.apply(this, arguments);
      }
      return attachLicenseTerms;
    }()
    /**
     * Mints license tokens for the license terms attached to an IP.
     * The license tokens are minted to the receiver.
     * The license terms must be attached to the IP before calling this function.
     * But it can mint license token of default license terms without attaching the default license terms,
     * since it is attached to all IPs by default.
     * IP owners can mint license tokens for their IPs for arbitrary license terms
     * without attaching the license terms to IP.
     * It might require the caller pay the minting fee, depending on the license terms or configured by the iP owner.
     * The minting fee is paid in the minting fee token specified in the license terms or configured by the IP owner.
     * IP owners can configure the minting fee of their IPs or
     * configure the minting fee module to determine the minting fee.
     * @param request - The request object that contains all data needed to mint license tokens.
     *   @param request.licensorIpId The licensor IP ID.
     *   @param request.licenseTemplate The address of the license template.
     *   @param request.licenseTermsId The ID of the license terms within the license template.
     *   @param request.amount The amount of license tokens to mint.
     *   @param request.receiver The address of the receiver.
     *   @param request.txOptions [Optional] The transaction options.
     * @returns A Promise that resolves to an object containing the transaction hash and optional license token ID if waitForTxn is set to true.
     * @emits LicenseTokensMinted (msg.sender, licensorIpId, licenseTemplate, licenseTermsId, amount, receiver, startLicenseTokenId);
     */
    )
  }, {
    key: "mintLicenseTokens",
    value: (function () {
      var _mintLicenseTokens = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(request) {
        var _request$txOptions5, isLicenseIpIdRegistered, isExisted, isAttachedLicenseTerms, txHash, txReceipt, targetLogs;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _context5.prev = 0;
              request.licenseTermsId = BigInt(request.licenseTermsId);
              _context5.next = 4;
              return this.ipAssetRegistryClient.isRegistered({
                id: viem.getAddress(request.licensorIpId)
              });
            case 4:
              isLicenseIpIdRegistered = _context5.sent;
              if (isLicenseIpIdRegistered) {
                _context5.next = 7;
                break;
              }
              throw new Error("The licensor IP with id ".concat(request.licensorIpId, " is not registered."));
            case 7:
              _context5.next = 9;
              return this.piLicenseTemplateReadOnlyClient.exists({
                licenseTermsId: request.licenseTermsId
              });
            case 9:
              isExisted = _context5.sent;
              if (isExisted) {
                _context5.next = 12;
                break;
              }
              throw new Error("License terms id ".concat(request.licenseTermsId, " do not exist."));
            case 12:
              _context5.next = 14;
              return this.licenseRegistryReadOnlyClient.hasIpAttachedLicenseTerms({
                ipId: request.licensorIpId,
                licenseTemplate: request.licenseTemplate && viem.getAddress(request.licenseTemplate) || this.licenseTemplateClient.address,
                licenseTermsId: request.licenseTermsId
              });
            case 14:
              isAttachedLicenseTerms = _context5.sent;
              if (isAttachedLicenseTerms) {
                _context5.next = 17;
                break;
              }
              throw new Error("License terms id ".concat(request.licenseTermsId, " is not attached to the IP with id ").concat(request.licensorIpId, "."));
            case 17:
              _context5.next = 19;
              return this.licensingModuleClient.mintLicenseTokens({
                licensorIpId: request.licensorIpId,
                licenseTemplate: request.licenseTemplate || this.licenseTemplateClient.address,
                licenseTermsId: request.licenseTermsId,
                amount: BigInt(request.amount || 1),
                receiver: request.receiver && viem.getAddress(request.receiver) || this.wallet.account.address,
                royaltyContext: viem.zeroAddress
              });
            case 19:
              txHash = _context5.sent;
              if (!((_request$txOptions5 = request.txOptions) !== null && _request$txOptions5 !== void 0 && _request$txOptions5.waitForTransaction)) {
                _context5.next = 28;
                break;
              }
              _context5.next = 23;
              return this.rpcClient.waitForTransactionReceipt({
                hash: txHash
              });
            case 23:
              txReceipt = _context5.sent;
              targetLogs = this.licensingModuleClient.parseTxLicenseTokensMintedEvent(txReceipt);
              return _context5.abrupt("return", {
                txHash: txHash,
                licenseTokenId: targetLogs[0].startLicenseTokenId
              });
            case 28:
              return _context5.abrupt("return", {
                txHash: txHash
              });
            case 29:
              _context5.next = 34;
              break;
            case 31:
              _context5.prev = 31;
              _context5.t0 = _context5["catch"](0);
              handleError(_context5.t0, "Failed to mint license tokens");
            case 34:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this, [[0, 31]]);
      }));
      function mintLicenseTokens(_x5) {
        return _mintLicenseTokens.apply(this, arguments);
      }
      return mintLicenseTokens;
    }()
    /**
     * Gets license terms of the given ID.
     * @param selectedLicenseTermsId The ID of the license terms.
     * @returns A Promise that resolves to an object containing the PILTerms associate with the given ID.
     */
    )
  }, {
    key: "getLicenseTerms",
    value: (function () {
      var _getLicenseTerms = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(selectedLicenseTermsId) {
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              _context6.prev = 0;
              _context6.next = 3;
              return this.piLicenseTemplateReadOnlyClient.getLicenseTerms({
                selectedLicenseTermsId: BigInt(selectedLicenseTermsId)
              });
            case 3:
              return _context6.abrupt("return", _context6.sent);
            case 6:
              _context6.prev = 6;
              _context6.t0 = _context6["catch"](0);
              handleError(_context6.t0, "Failed to get license terms");
            case 9:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this, [[0, 6]]);
      }));
      function getLicenseTerms(_x6) {
        return _getLicenseTerms.apply(this, arguments);
      }
      return getLicenseTerms;
    }())
  }, {
    key: "getLicenseTermsId",
    value: function () {
      var _getLicenseTermsId = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(request) {
        var licenseRes;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              _context7.next = 2;
              return this.licenseTemplateClient.getLicenseTermsId({
                terms: request
              });
            case 2:
              licenseRes = _context7.sent;
              return _context7.abrupt("return", licenseRes.selectedLicenseTermsId);
            case 4:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));
      function getLicenseTermsId(_x7) {
        return _getLicenseTermsId.apply(this, arguments);
      }
      return getLicenseTermsId;
    }()
  }]);
}();

var DisputeClient = /*#__PURE__*/function () {
  function DisputeClient(rpcClient, wallet) {
    _classCallCheck(this, DisputeClient);
    this.rpcClient = rpcClient;
    this.disputeModuleClient = new DisputeModuleClient(rpcClient, wallet);
  }

  /**
   * Raises a dispute on a given ipId
   * @param request - The request object containing necessary data to raise a dispute.
   *   @param request.targetIpId - The IP ID that is the target of the dispute.
   *   @param request.arbitrationPolicy - The address of the arbitration policy.
   *   @param request.linkToDisputeEvidence - The link to the dispute evidence.
   *   @param request.targetTag - The target tag of the dispute.
   *   @param request.calldata - Optional calldata to initialize the policy.
   *   @param request.txOptions - Optional transaction options.
   * @returns A Promise that resolves to a RaiseDisputeResponse containing the transaction hash.
   * @throws `NotRegisteredIpId` if targetIpId is not registered in the IPA Registry.
   * @throws `NotWhitelistedDisputeTag` if targetTag is not whitelisted.
   * @throws `ZeroLinkToDisputeEvidence` if linkToDisputeEvidence is empty
   * @calls raiseDispute(address _targetIpId, string memory _linkToDisputeEvidence, bytes32 _targetTag, bytes calldata _data) external nonReentrant returns (uint256) {
   * @emits DisputeRaised (disputeId_, targetIpId, msg.sender, arbitrationPolicy, linkToDisputeEvidence, targetTag, calldata);
   */
  return _createClass(DisputeClient, [{
    key: "raiseDispute",
    value: (function () {
      var _raiseDispute = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {
        var _request$txOptions, txHash, txReceipt, targetLogs;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              _context.next = 3;
              return this.disputeModuleClient.raiseDispute({
                targetIpId: request.targetIpId,
                linkToDisputeEvidence: request.linkToDisputeEvidence,
                targetTag: viem.stringToHex(request.targetTag, {
                  size: 32
                }),
                data: request.calldata || "0x"
              });
            case 3:
              txHash = _context.sent;
              if (!((_request$txOptions = request.txOptions) !== null && _request$txOptions !== void 0 && _request$txOptions.waitForTransaction)) {
                _context.next = 10;
                break;
              }
              _context.next = 7;
              return this.rpcClient.waitForTransactionReceipt({
                hash: txHash
              });
            case 7:
              txReceipt = _context.sent;
              targetLogs = this.disputeModuleClient.parseTxDisputeRaisedEvent(txReceipt);
              return _context.abrupt("return", {
                txHash: txHash,
                disputeId: targetLogs[0].disputeId
              });
            case 10:
              return _context.abrupt("return", {
                txHash: txHash
              });
            case 13:
              _context.prev = 13;
              _context.t0 = _context["catch"](0);
              handleError(_context.t0, "Failed to raise dispute");
            case 16:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[0, 13]]);
      }));
      function raiseDispute(_x) {
        return _raiseDispute.apply(this, arguments);
      }
      return raiseDispute;
    }()
    /**
     * Cancels an ongoing dispute
     * @param request - The request object containing details to cancel the dispute.
     *   @param request.disputeId The ID of the dispute to be cancelled.
     *   @param request.calldata Optional additional data used in the cancellation process.
     * @returns A Promise that resolves to a CancelDisputeResponse containing the transaction hash.
     * @throws NotInDisputeState, if the currentTag of the Dispute is not being disputed
     * @throws NotDisputeInitiator, if the transaction executor is not the one that initiated the dispute
     * @throws error if the Dispute's ArbitrationPolicy contract is not valid
     * @calls cancelDispute(uint256 _disputeId, bytes calldata _data) external nonReentrant {
     * @emits DisputeCancelled (_disputeId, _data);
     */
    )
  }, {
    key: "cancelDispute",
    value: (function () {
      var _cancelDispute = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(request) {
        var _request$txOptions2, txHash;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.prev = 0;
              _context2.next = 3;
              return this.disputeModuleClient.cancelDispute({
                disputeId: BigInt(request.disputeId),
                data: request.calldata ? request.calldata : "0x"
              });
            case 3:
              txHash = _context2.sent;
              if (!((_request$txOptions2 = request.txOptions) !== null && _request$txOptions2 !== void 0 && _request$txOptions2.waitForTransaction)) {
                _context2.next = 7;
                break;
              }
              _context2.next = 7;
              return this.rpcClient.waitForTransactionReceipt({
                hash: txHash
              });
            case 7:
              return _context2.abrupt("return", {
                txHash: txHash
              });
            case 10:
              _context2.prev = 10;
              _context2.t0 = _context2["catch"](0);
              handleError(_context2.t0, "Failed to cancel dispute");
            case 13:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[0, 10]]);
      }));
      function cancelDispute(_x2) {
        return _cancelDispute.apply(this, arguments);
      }
      return cancelDispute;
    }()
    /**
     * Resolves a dispute after it has been judged
     * @param request - The request object containing details to resolve the dispute.
     *   @param request.disputeId The ID of the dispute to be resolved.
     *   @param request.data The data to resolve the dispute.
     * @returns A Promise that resolves to a ResolveDisputeResponse.
     * @throws NotAbleToResolve, if currentTag is still in dispute (i.e still needs a judgement to be set)
     * @throws NotDisputeInitiator, if the transaction executor is not the one that initiated the dispute
     * @emits DisputeResolved (_disputeId)
     */
    )
  }, {
    key: "resolveDispute",
    value: (function () {
      var _resolveDispute = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(request) {
        var _request$txOptions3, txHash;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.prev = 0;
              _context3.next = 3;
              return this.disputeModuleClient.resolveDispute({
                disputeId: BigInt(request.disputeId),
                data: request.data
              });
            case 3:
              txHash = _context3.sent;
              if (!((_request$txOptions3 = request.txOptions) !== null && _request$txOptions3 !== void 0 && _request$txOptions3.waitForTransaction)) {
                _context3.next = 7;
                break;
              }
              _context3.next = 7;
              return this.rpcClient.waitForTransactionReceipt({
                hash: txHash
              });
            case 7:
              return _context3.abrupt("return", {
                txHash: txHash
              });
            case 10:
              _context3.prev = 10;
              _context3.t0 = _context3["catch"](0);
              handleError(_context3.t0, "Failed to cancel dispute");
            case 13:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[0, 10]]);
      }));
      function resolveDispute(_x3) {
        return _resolveDispute.apply(this, arguments);
      }
      return resolveDispute;
    }())
  }]);
}();

var IPAccountClient = /*#__PURE__*/function () {
  function IPAccountClient(rpcClient, wallet) {
    _classCallCheck(this, IPAccountClient);
    this.wallet = wallet;
    this.rpcClient = rpcClient;
  }

  /** Executes a transaction from the IP Account.
   * @param request - The request object containing necessary data to execute IP Account a transaction.
   *   @param request.to The recipient of the transaction.
   *   @param request.value The amount of Ether to send.
   *   @param request.accountAddress The ipId to send.
   *   @param request.data The data to send along with the transaction.
   * @returns Tx hash for the transaction.
   */
  return _createClass(IPAccountClient, [{
    key: "execute",
    value: (function () {
      var _execute = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {
        var _request$txOptions, ipAccountClient, txHash;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              ipAccountClient = new IpAccountImplClient(this.rpcClient, this.wallet, viem.getAddress(request.accountAddress));
              _context.next = 4;
              return ipAccountClient.execute({
                to: request.to,
                value: BigInt(0),
                data: request.data
              });
            case 4:
              txHash = _context.sent;
              if (!((_request$txOptions = request.txOptions) !== null && _request$txOptions !== void 0 && _request$txOptions.waitForTransaction)) {
                _context.next = 8;
                break;
              }
              _context.next = 8;
              return this.rpcClient.waitForTransactionReceipt({
                hash: txHash
              });
            case 8:
              return _context.abrupt("return", {
                txHash: txHash
              });
            case 11:
              _context.prev = 11;
              _context.t0 = _context["catch"](0);
              handleError(_context.t0, "Failed to execute the IP Account transaction");
            case 14:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[0, 11]]);
      }));
      function execute(_x) {
        return _execute.apply(this, arguments);
      }
      return execute;
    }()
    /** Executes a transaction from the IP Account.
     * @param request - The request object containing necessary data to execute IP Account a transaction.
     *   @param request.to The recipient of the transaction.
     *   @param request.value The amount of Ether to send.
     *   @param request.data The data to send along with the transaction.
     *   @param request.signer The signer of the transaction.
     *   @param request.deadline The deadline of the transaction signature.
     *   @param request.signature The signature of the transaction, EIP-712 encoded.
     * @returns Tx hash for the transaction.
     */
    )
  }, {
    key: "executeWithSig",
    value: (function () {
      var _executeWithSig = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(request) {
        var _request$txOptions2, ipAccountClient, txHash;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.prev = 0;
              ipAccountClient = new IpAccountImplClient(this.rpcClient, this.wallet, viem.getAddress(request.accountAddress));
              _context2.next = 4;
              return ipAccountClient.executeWithSig({
                to: request.to,
                value: BigInt(0),
                data: request.data,
                signer: request.signer,
                deadline: BigInt(request.deadline),
                signature: request.signature
              });
            case 4:
              txHash = _context2.sent;
              if (!((_request$txOptions2 = request.txOptions) !== null && _request$txOptions2 !== void 0 && _request$txOptions2.waitForTransaction)) {
                _context2.next = 8;
                break;
              }
              _context2.next = 8;
              return this.rpcClient.waitForTransactionReceipt({
                hash: txHash
              });
            case 8:
              return _context2.abrupt("return", {
                txHash: txHash
              });
            case 11:
              _context2.prev = 11;
              _context2.t0 = _context2["catch"](0);
              handleError(_context2.t0, "Failed to execute with signature for the IP Account transaction");
            case 14:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[0, 11]]);
      }));
      function executeWithSig(_x2) {
        return _executeWithSig.apply(this, arguments);
      }
      return executeWithSig;
    }()
    /** Returns the IPAccount's internal nonce for transaction ordering.
     * @param ipId The derivative IP ID
     * @returns The IPAccount's internal nonce for transaction ordering.
     */
    )
  }, {
    key: "getIpAccountNonce",
    value: (function () {
      var _getIpAccountNonce = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(ipId) {
        var ipAccount;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              ipAccount = new IpAccountImplClient(this.rpcClient, this.wallet, viem.getAddress(ipId));
              _context3.next = 3;
              return ipAccount.state();
            case 3:
              return _context3.abrupt("return", _context3.sent);
            case 4:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function getIpAccountNonce(_x3) {
        return _getIpAccountNonce.apply(this, arguments);
      }
      return getIpAccountNonce;
    }())
  }]);
}();

var RoyaltyClient = /*#__PURE__*/function () {
  function RoyaltyClient(rpcClient, wallet) {
    _classCallCheck(this, RoyaltyClient);
    this.royaltyPolicyLapClient = new RoyaltyPolicyLapClient(rpcClient, wallet);
    this.royaltyModuleClient = new RoyaltyModuleClient(rpcClient, wallet);
    this.ipAssetRegistryClient = new IpAssetRegistryClient(rpcClient, wallet);
    this.ipAccountClient = new IPAccountClient(rpcClient, wallet);
    this.rpcClient = rpcClient;
    this.wallet = wallet;
  }

  /**
   * Allows ancestors to claim the royalty tokens and any accrued revenue tokens
   * @param request - The request object that contains all data needed to collect royalty tokens.
   *   @param request.parentIpId The ip id of the ancestor to whom the royalty tokens belong to.
   *   @param request.royaltyVaultIpId The id of the royalty vault.
   *   @param request.txOptions [Optional] The transaction options.
   * @returns A Promise that resolves to an object containing the transaction hash and optional the amount of royalty tokens collected if waitForTxn is set to true.
   * @emits RoyaltyTokensCollected (ancestorIpId, royaltyTokensCollected)
   */
  return _createClass(RoyaltyClient, [{
    key: "collectRoyaltyTokens",
    value: (function () {
      var _collectRoyaltyTokens = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {
        var _request$txOptions, isParentIpIdRegistered, proxyAddress, ipRoyaltyVault, txHash, txReceipt, targetLogs;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              _context.next = 3;
              return this.ipAssetRegistryClient.isRegistered({
                id: viem.getAddress(request.parentIpId)
              });
            case 3:
              isParentIpIdRegistered = _context.sent;
              if (isParentIpIdRegistered) {
                _context.next = 6;
                break;
              }
              throw new Error("The parent IP with id ".concat(request.parentIpId, " is not registered."));
            case 6:
              _context.next = 8;
              return this.getRoyaltyVaultAddress(viem.getAddress(request.royaltyVaultIpId));
            case 8:
              proxyAddress = _context.sent;
              ipRoyaltyVault = new IpRoyaltyVaultImplClient(this.rpcClient, this.wallet, proxyAddress);
              _context.next = 12;
              return ipRoyaltyVault.collectRoyaltyTokens({
                ancestorIpId: request.parentIpId
              });
            case 12:
              txHash = _context.sent;
              if (!((_request$txOptions = request.txOptions) !== null && _request$txOptions !== void 0 && _request$txOptions.waitForTransaction)) {
                _context.next = 21;
                break;
              }
              _context.next = 16;
              return this.rpcClient.waitForTransactionReceipt({
                hash: txHash
              });
            case 16:
              txReceipt = _context.sent;
              targetLogs = ipRoyaltyVault.parseTxRoyaltyTokensCollectedEvent(txReceipt);
              return _context.abrupt("return", {
                txHash: txHash,
                royaltyTokensCollected: targetLogs[0].royaltyTokensCollected
              });
            case 21:
              return _context.abrupt("return", {
                txHash: txHash
              });
            case 22:
              _context.next = 27;
              break;
            case 24:
              _context.prev = 24;
              _context.t0 = _context["catch"](0);
              handleError(_context.t0, "Failed to collect royalty tokens");
            case 27:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[0, 24]]);
      }));
      function collectRoyaltyTokens(_x) {
        return _collectRoyaltyTokens.apply(this, arguments);
      }
      return collectRoyaltyTokens;
    }()
    /**
     * Allows the function caller to pay royalties to the receiver IP asset on behalf of the payer IP asset.
     * @param request - The request object that contains all data needed to pay royalty on behalf.
     *   @param request.receiverIpId The ipId that receives the royalties.
     *   @param request.payerIpId The ID of the IP asset that pays the royalties.
     *   @param request.token The token to use to pay the royalties.
     *   @param request.amount The amount to pay.
     *   @param request.txOptions [Optional] The transaction options.
     * @returns A Promise that resolves to an object containing the transaction hash.
     */
    )
  }, {
    key: "payRoyaltyOnBehalf",
    value: (function () {
      var _payRoyaltyOnBehalf = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(request) {
        var _request$txOptions2, isReceiverRegistered, isPayerRegistered, txHash;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.prev = 0;
              _context2.next = 3;
              return this.ipAssetRegistryClient.isRegistered({
                id: viem.getAddress(request.receiverIpId)
              });
            case 3:
              isReceiverRegistered = _context2.sent;
              if (isReceiverRegistered) {
                _context2.next = 6;
                break;
              }
              throw new Error("The receiver IP with id ".concat(request.receiverIpId, " is not registered."));
            case 6:
              _context2.next = 8;
              return this.ipAssetRegistryClient.isRegistered({
                id: viem.getAddress(request.payerIpId)
              });
            case 8:
              isPayerRegistered = _context2.sent;
              if (isPayerRegistered) {
                _context2.next = 11;
                break;
              }
              throw new Error("The payer IP with id ".concat(request.payerIpId, " is not registered."));
            case 11:
              _context2.next = 13;
              return this.royaltyModuleClient.payRoyaltyOnBehalf({
                receiverIpId: request.receiverIpId,
                payerIpId: request.payerIpId,
                token: viem.getAddress(request.token),
                amount: BigInt(request.amount)
              });
            case 13:
              txHash = _context2.sent;
              if (!((_request$txOptions2 = request.txOptions) !== null && _request$txOptions2 !== void 0 && _request$txOptions2.waitForTransaction)) {
                _context2.next = 20;
                break;
              }
              _context2.next = 17;
              return this.rpcClient.waitForTransactionReceipt({
                hash: txHash
              });
            case 17:
              return _context2.abrupt("return", {
                txHash: txHash
              });
            case 20:
              return _context2.abrupt("return", {
                txHash: txHash
              });
            case 21:
              _context2.next = 26;
              break;
            case 23:
              _context2.prev = 23;
              _context2.t0 = _context2["catch"](0);
              handleError(_context2.t0, "Failed to pay royalty on behalf");
            case 26:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[0, 23]]);
      }));
      function payRoyaltyOnBehalf(_x2) {
        return _payRoyaltyOnBehalf.apply(this, arguments);
      }
      return payRoyaltyOnBehalf;
    }()
    /**
     * Calculates the amount of revenue token claimable by a token holder at certain snapshot.
     * @param request - The request object that contains all data needed to claim Revenue.
     *   @param request.royaltyVaultIpId The id of the royalty vault.
     *   @param request.account The address of the token holder.
     *   @param request.snapshotId The snapshot id.
     *   @param request.token The revenue token to claim.
     *   @param request.txOptions [Optional] The transaction options.
     * @returns A Promise that contains the amount of revenue token claimable
     */
    )
  }, {
    key: "claimableRevenue",
    value: (function () {
      var _claimableRevenue = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(request) {
        var proxyAddress, ipRoyaltyVault;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.prev = 0;
              _context3.next = 3;
              return this.getRoyaltyVaultAddress(viem.getAddress(request.royaltyVaultIpId));
            case 3:
              proxyAddress = _context3.sent;
              ipRoyaltyVault = new IpRoyaltyVaultImplClient(this.rpcClient, this.wallet, proxyAddress);
              _context3.next = 7;
              return ipRoyaltyVault.claimableRevenue({
                account: viem.getAddress(request.account),
                snapshotId: BigInt(request.snapshotId),
                token: viem.getAddress(request.token)
              });
            case 7:
              return _context3.abrupt("return", _context3.sent);
            case 10:
              _context3.prev = 10;
              _context3.t0 = _context3["catch"](0);
              handleError(_context3.t0, "Failed to calculate claimable revenue");
            case 13:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[0, 10]]);
      }));
      function claimableRevenue(_x3) {
        return _claimableRevenue.apply(this, arguments);
      }
      return claimableRevenue;
    }()
    /**
     * Allows token holders to claim by a list of snapshot ids based on the token balance at certain snapshot
     * @param request - The request object that contains all data needed to claim revenue.
     *   @param request.snapshotIds The list of snapshot ids.
     *   @param request.royaltyVaultIpId The id of the royalty vault.
     *   @param request.token The revenue token to claim.
     *   @param request.account [Optional] The ipId to send.
     *   @param request.txOptions [Optional] The transaction options.
     * @returns A Promise that resolves to an object containing the transaction hash and optional claimableToken if waitForTxn is set to true.
     * @emits RevenueTokenClaimed (claimer, token, amount).
     */
    )
  }, {
    key: "claimRevenue",
    value: (function () {
      var _claimRevenue = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(request) {
        var _request$txOptions3, proxyAddress, ipRoyaltyVault, txHash, iPAccountExecuteResponse, txReceipt, targetLogs;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.prev = 0;
              _context4.next = 3;
              return this.getRoyaltyVaultAddress(viem.getAddress(request.royaltyVaultIpId));
            case 3:
              proxyAddress = _context4.sent;
              ipRoyaltyVault = new IpRoyaltyVaultImplClient(this.rpcClient, this.wallet, proxyAddress);
              request.snapshotIds = request.snapshotIds.map(function (item) {
                return BigInt(item);
              });
              if (!request.account) {
                _context4.next = 13;
                break;
              }
              _context4.next = 9;
              return this.ipAccountClient.execute({
                to: proxyAddress,
                value: 0,
                accountAddress: viem.getAddress(request.account),
                txOptions: {
                  waitForTransaction: true
                },
                data: viem.encodeFunctionData({
                  abi: ipRoyaltyVaultImplAbi,
                  functionName: "claimRevenueBySnapshotBatch",
                  args: [request.snapshotIds, request.token]
                })
              });
            case 9:
              iPAccountExecuteResponse = _context4.sent;
              txHash = iPAccountExecuteResponse.txHash;
              _context4.next = 16;
              break;
            case 13:
              _context4.next = 15;
              return ipRoyaltyVault.claimRevenueBySnapshotBatch({
                snapshotIds: request.snapshotIds,
                token: viem.getAddress(request.token)
              });
            case 15:
              txHash = _context4.sent;
            case 16:
              if (!((_request$txOptions3 = request.txOptions) !== null && _request$txOptions3 !== void 0 && _request$txOptions3.waitForTransaction)) {
                _context4.next = 24;
                break;
              }
              _context4.next = 19;
              return this.rpcClient.waitForTransactionReceipt({
                hash: txHash
              });
            case 19:
              txReceipt = _context4.sent;
              targetLogs = ipRoyaltyVault.parseTxRevenueTokenClaimedEvent(txReceipt);
              return _context4.abrupt("return", {
                txHash: txHash,
                claimableToken: targetLogs[0].amount
              });
            case 24:
              return _context4.abrupt("return", {
                txHash: txHash
              });
            case 25:
              _context4.next = 30;
              break;
            case 27:
              _context4.prev = 27;
              _context4.t0 = _context4["catch"](0);
              handleError(_context4.t0, "Failed to claim revenue");
            case 30:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this, [[0, 27]]);
      }));
      function claimRevenue(_x4) {
        return _claimRevenue.apply(this, arguments);
      }
      return claimRevenue;
    }()
    /**
     * Snapshots the claimable revenue and royalty token amounts.
     * @param request - The request object that contains all data needed to snapshot.
     *   @param request.royaltyVaultIpId The id of the royalty vault.
     *   @param request.txOptions [Optional] The transaction options.
     * @returns A Promise that resolves to an object containing the transaction hash and optional snapshotId if waitForTxn is set to true.
     * @emits SnapshotCompleted (snapshotId, snapshotTimestamp, unclaimedTokens).
     */
    )
  }, {
    key: "snapshot",
    value: (function () {
      var _snapshot = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(request) {
        var _request$txOptions4, proxyAddress, ipRoyaltyVault, txHash, txReceipt, targetLogs;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _context5.prev = 0;
              _context5.next = 3;
              return this.getRoyaltyVaultAddress(viem.getAddress(request.royaltyVaultIpId));
            case 3:
              proxyAddress = _context5.sent;
              ipRoyaltyVault = new IpRoyaltyVaultImplClient(this.rpcClient, this.wallet, proxyAddress);
              _context5.next = 7;
              return ipRoyaltyVault.snapshot();
            case 7:
              txHash = _context5.sent;
              if (!((_request$txOptions4 = request.txOptions) !== null && _request$txOptions4 !== void 0 && _request$txOptions4.waitForTransaction)) {
                _context5.next = 16;
                break;
              }
              _context5.next = 11;
              return this.rpcClient.waitForTransactionReceipt({
                hash: txHash
              });
            case 11:
              txReceipt = _context5.sent;
              targetLogs = ipRoyaltyVault.parseTxSnapshotCompletedEvent(txReceipt);
              return _context5.abrupt("return", {
                txHash: txHash,
                snapshotId: targetLogs[0].snapshotId
              });
            case 16:
              return _context5.abrupt("return", {
                txHash: txHash
              });
            case 17:
              _context5.next = 22;
              break;
            case 19:
              _context5.prev = 19;
              _context5.t0 = _context5["catch"](0);
              handleError(_context5.t0, "Failed to snapshot");
            case 22:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this, [[0, 19]]);
      }));
      function snapshot(_x5) {
        return _snapshot.apply(this, arguments);
      }
      return snapshot;
    }()
    /**
     * Get the royalty vault proxy address of given royaltyVaultIpId.
     * @param royaltyVaultIpId the id of the royalty vault.
     * @returns A Promise that resolves to an object containing the royalty vault address.
     */
    )
  }, {
    key: "getRoyaltyVaultAddress",
    value: (function () {
      var _getRoyaltyVaultAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(royaltyVaultIpId) {
        var isRoyaltyVaultIpIdRegistered, data;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              _context6.next = 2;
              return this.ipAssetRegistryClient.isRegistered({
                id: viem.getAddress(royaltyVaultIpId)
              });
            case 2:
              isRoyaltyVaultIpIdRegistered = _context6.sent;
              if (isRoyaltyVaultIpIdRegistered) {
                _context6.next = 5;
                break;
              }
              throw new Error("The royalty vault IP with id ".concat(royaltyVaultIpId, " is not registered."));
            case 5:
              _context6.next = 7;
              return this.royaltyPolicyLapClient.getRoyaltyData({
                ipId: royaltyVaultIpId
              });
            case 7:
              data = _context6.sent;
              if (!(!data[1] || data[1] === "0x")) {
                _context6.next = 10;
                break;
              }
              throw new Error("The royalty vault IP with id ".concat(royaltyVaultIpId, " address is not set."));
            case 10:
              return _context6.abrupt("return", data[1]);
            case 11:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function getRoyaltyVaultAddress(_x6) {
        return _getRoyaltyVaultAddress.apply(this, arguments);
      }
      return getRoyaltyVaultAddress;
    }())
  }]);
}();

var NftClient = /*#__PURE__*/function () {
  function NftClient(rpcClient, wallet) {
    _classCallCheck(this, NftClient);
    this.rpcClient = rpcClient;
    this.wallet = wallet;
    this.spgClient = new SpgClient(rpcClient, wallet);
  }

  /**
   * Creates a new SPG NFT Collection.
   * @param request - The request object containing necessary data to create a SPG NFT Collection.
   *   @param request.name - The name of the collection.
   * 	 @param request.symbol - The symbol of the collection.
   * 	 @param request.maxSupply - The maximum supply of the collection.
   * 	 @param request.mintCost - The cost to mint a token.
   * 	 @param request.mintToken - The token to mint.
   * 	 @param request.owner - The owner of the collection.
   *   @param request.txOptions - Optional transaction options.
   * @returns A Promise that resolves to a CreateNFTCollectionResponse containing the transaction hash and collection address.
   * @emits CollectionCreated (nftContract);
   */
  return _createClass(NftClient, [{
    key: "createNFTCollection",
    value: (function () {
      var _createNFTCollection = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {
        var _request$maxSupply, _request$mintCost, _request$mintToken, _request$txOptions, txHash, txReceipt, targetLogs;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              if (!(request.mintCost && request.mintCost > 0n && !viem.isAddress(request.mintToken || ""))) {
                _context.next = 3;
                break;
              }
              throw new Error("Invalid mint token address, mint cost is greater than 0.");
            case 3:
              _context.next = 5;
              return this.spgClient.createCollection({
                name: request.name,
                symbol: request.symbol,
                maxSupply: (_request$maxSupply = request.maxSupply) !== null && _request$maxSupply !== void 0 ? _request$maxSupply : Number(viem.maxUint32),
                mintCost: (_request$mintCost = request.mintCost) !== null && _request$mintCost !== void 0 ? _request$mintCost : 0n,
                mintToken: (_request$mintToken = request.mintToken) !== null && _request$mintToken !== void 0 ? _request$mintToken : viem.zeroAddress,
                owner: request.owner && viem.getAddress(request.owner) || this.wallet.account.address
              });
            case 5:
              txHash = _context.sent;
              if (!((_request$txOptions = request.txOptions) !== null && _request$txOptions !== void 0 && _request$txOptions.waitForTransaction)) {
                _context.next = 12;
                break;
              }
              _context.next = 9;
              return this.rpcClient.waitForTransactionReceipt({
                hash: txHash
              });
            case 9:
              txReceipt = _context.sent;
              targetLogs = this.spgClient.parseTxCollectionCreatedEvent(txReceipt);
              return _context.abrupt("return", {
                txHash: txHash,
                nftContract: targetLogs[0].nftContract
              });
            case 12:
              return _context.abrupt("return", {
                txHash: txHash
              });
            case 15:
              _context.prev = 15;
              _context.t0 = _context["catch"](0);
              handleError(_context.t0, "Failed to create a SPG NFT collection");
            case 18:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[0, 15]]);
      }));
      function createNFTCollection(_x) {
        return _createNFTCollection.apply(this, arguments);
      }
      return createNFTCollection;
    }())
  }]);
}();

if (typeof process !== "undefined") {
  dotenv__namespace.config();
}
/**
 * The StoryClient is the main entry point for the SDK.
 */
var StoryClient = /*#__PURE__*/function () {
  /**
   * @param config - the configuration for the SDK client
   */
  function StoryClient(config) {
    _classCallCheck(this, StoryClient);
    _defineProperty(this, "_ipAsset", null);
    _defineProperty(this, "_permission", null);
    _defineProperty(this, "_license", null);
    _defineProperty(this, "_dispute", null);
    _defineProperty(this, "_ipAccount", null);
    _defineProperty(this, "_royalty", null);
    _defineProperty(this, "_nftClient", null);
    this.config = _objectSpread2(_objectSpread2({}, config), {}, {
      chainId: config.chainId || "sepolia"
    });
    if (!this.config.transport) {
      throw new Error("transport is null, please pass in a valid RPC Provider URL as the transport.");
    }
    var clientConfig = {
      chain: chainStringToViemChain(this.config.chainId),
      transport: this.config.transport
    };
    this.rpcClient = viem.createPublicClient(clientConfig);
    if (this.config.wallet) {
      this.wallet = this.config.wallet;
    } else if (this.config.account) {
      var account = this.config.account;
      this.wallet = viem.createWalletClient(_objectSpread2(_objectSpread2({}, clientConfig), {}, {
        account: account
      }));
    } else {
      throw new Error("must specify a wallet or account");
    }
  }

  /**
   * Factory method for creating a SDK client with a signer.
   *
   * @param config StoryClient - the configuration for a new SDK client
   */
  return _createClass(StoryClient, [{
    key: "ipAsset",
    get:
    /**
     * Getter for the ip asset client. The client is lazily created when
     * this method is called.
     *
     * @returns the IPAssetClient instance
     */
    function get() {
      if (this._ipAsset === null) {
        this._ipAsset = new IPAssetClient(this.rpcClient, this.wallet, this.config.chainId);
      }
      return this._ipAsset;
    }

    /**
     * Getter for the permission client. The client is lazily created when
     * this method is called.
     *
     * @returns the PermissionClient instance
     */
  }, {
    key: "permission",
    get: function get() {
      if (this._permission === null) {
        this._permission = new PermissionClient(this.rpcClient, this.wallet);
      }
      return this._permission;
    }

    /**
     * Getter for the license client. The client is lazily created when
     * this method is called.
     *
     * @returns the LicenseClient instance
     */
  }, {
    key: "license",
    get: function get() {
      if (this._license === null) {
        this._license = new LicenseClient(this.rpcClient, this.wallet);
      }
      return this._license;
    }

    /**
     * Getter for the dispute client. The client is lazily created when
     * this method is called.
     *
     * @returns the DisputeClient instance
     */
  }, {
    key: "dispute",
    get: function get() {
      if (this._dispute === null) {
        this._dispute = new DisputeClient(this.rpcClient, this.wallet);
      }
      return this._dispute;
    }

    /**
     * Getter for the ip account client. The client is lazily created when
     * this method is called.
     *
     * @returns the IPAccountClient instance
     */
  }, {
    key: "ipAccount",
    get: function get() {
      if (this._ipAccount === null) {
        this._ipAccount = new IPAccountClient(this.rpcClient, this.wallet);
      }
      return this._ipAccount;
    }

    /**
     * Getter for the royalty client. The client is lazily created when
     * this method is called.
     *
     * @returns the RoyaltyClient instance
     */
  }, {
    key: "royalty",
    get: function get() {
      if (this._royalty === null) {
        this._royalty = new RoyaltyClient(this.rpcClient, this.wallet);
      }
      return this._royalty;
    }

    /**
     * Getter for the NFT client. The client is lazily created when
     * this method is called.
     *
     * @returns the NftClient instance
     */
  }, {
    key: "nftClient",
    get: function get() {
      if (this._nftClient === null) {
        this._nftClient = new NftClient(this.rpcClient, this.wallet);
      }
      return this._nftClient;
    }
  }], [{
    key: "newClient",
    value: function newClient(config) {
      return new StoryClient(config);
    }

    /**
     * Factory method for creating a SDK client with a signer.
     *
     * @param config WalletClientConfig - the configuration for a new SDK client
     */
  }, {
    key: "newClientUseWallet",
    value: function newClientUseWallet(config) {
      return new StoryClient({
        chainId: config.chainId,
        transport: config.transport,
        wallet: config.wallet
      });
    }

    /**
     * Factory method for creating a SDK client with a signer.
     *
     * @param config UseAccountStoryConfig - the configuration for a new SDK client
     */
  }, {
    key: "newClientUseAccount",
    value: function newClientUseAccount(config) {
      return new StoryClient({
        account: config.account,
        chainId: config.chainId,
        transport: config.transport
      });
    }
  }]);
}();

var AddressZero = "0x0000000000000000000000000000000000000000";
var HashZero = "0x0000000000000000000000000000000000000000000000000000000000000000";

exports.AddressZero = AddressZero;
exports.DisputeClient = DisputeClient;
exports.HashZero = HashZero;
exports.IPAssetClient = IPAssetClient;
exports.LicenseClient = LicenseClient;
exports.NftClient = NftClient;
exports.PermissionClient = PermissionClient;
exports.StoryClient = StoryClient;
